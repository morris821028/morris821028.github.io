<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Morris&#39; Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://morris821028.github.io/"/>
  <updated>2020-11-01T05:24:55.358Z</updated>
  <id>http://morris821028.github.io/</id>
  
  <author>
    <name>Shiang-Yun Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ADA 2020 Fall P3. ADA Party</title>
    <link href="http://morris821028.github.io/2020/10/31/lesson/ada-2020-hw1-p3/"/>
    <id>http://morris821028.github.io/2020/10/31/lesson/ada-2020-hw1-p3/</id>
    <published>2020-10-31T08:30:00.000Z</published>
    <updated>2020-11-01T05:24:55.358Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Algorithm Design and Analysis (NTU CSIE, Fall 2020)</p></blockquote><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>給 <span>$N$</span><!-- Has MathJax --> 個堆，每個堆有 <span>$a_i$</span><!-- Has MathJax --> 個糖果，現在邀請 <span>$K$</span><!-- Has MathJax --> 個人，現在問有多少種挑選區間的方法，滿足扣掉最大堆和最小堆後，區間內的糖果總數可以被 <span>$K$</span><!-- Has MathJax --> 整除。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10 2</div><div class="line">6 9 3 4 5 6 1 7 8 3</div></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">25</div></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><blockquote><p>由於沒辦法參與課程，就測測自己產的測試資料，正確性有待確認。</p></blockquote><p>分治處理可行解的組合，每一次剖半計算，統計跨區間的答案個數。</p><p>討論項目分別為</p><ul><li>最大值、最小值嚴格都在左側</li><li>最大值、最小值嚴格都在右側</li><li>最大值在左側、最小值在右側</li><li>最大值在右側、最小值在左側</li></ul><p>最後兩項會有交集部分，則扣除 在左側的最大最小值接等於右側的最大最小值。對於每一項回答，搭配單調運行的滑動窗口解決。</p><p>時間複雜度 <span>$\mathcal{O}(n \log n)$</span><!-- Has MathJax -->、空間複雜度 <span>$\mathcal{O}(n)$</span><!-- Has MathJax --> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// Algorithm Design and Analysis (NTU CSIE, Fall 2020)</span></div><div class="line"><span class="comment">// Problem 3. ADA Party</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int32_t</span> MIN = LONG_MIN;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int32_t</span> MAX = LONG_MAX;</div><div class="line"><span class="keyword">int32_t</span> a[MAXN];</div><div class="line"><span class="keyword">int32_t</span> lsum[MAXN], rsum[MAXN];</div><div class="line"><span class="keyword">int32_t</span> lmin[MAXN], lmax[MAXN];</div><div class="line"><span class="keyword">int32_t</span> rmin[MAXN], rmax[MAXN];</div><div class="line"></div><div class="line"><span class="keyword">int</span> cases = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> mark[MAXN];</div><div class="line"><span class="keyword">int</span> counter[MAXN];</div><div class="line"><span class="keyword">int</span> n, k;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int32_t</span> val)</span> </span>&#123;</div><div class="line">    val = (val%k+k)%k;</div><div class="line">    <span class="keyword">if</span> (mark[val] != cases)</div><div class="line">        mark[val] = cases, counter[val] = <span class="number">0</span>;</div><div class="line">    counter[val]++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int32_t</span> val)</span> </span>&#123;</div><div class="line">    val = (val%k+k)%k;</div><div class="line">    <span class="keyword">if</span> (mark[val] != cases)</div><div class="line">        mark[val] = cases, counter[val] = <span class="number">0</span>;</div><div class="line">    counter[val]--;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int32_t</span> val)</span> </span>&#123;</div><div class="line">    val = (val%k+k)%k;</div><div class="line">    <span class="keyword">if</span> (mark[val] != cases)</div><div class="line">        mark[val] = cases, counter[val] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> counter[val];</div><div class="line">&#125;</div><div class="line"><span class="keyword">int64_t</span> common(<span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r) &#123;</div><div class="line">    <span class="keyword">int64_t</span> ret = <span class="number">0</span>;</div><div class="line">    cases++;  <span class="comment">// max and min is same on both end</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j = m+<span class="number">1</span>, jl = m+<span class="number">1</span>; i &gt;= l; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (j &lt;= r &amp;&amp; (rmax[j] &lt;= lmax[i] &amp;&amp; rmin[j] &gt;= lmin[i])) &#123;</div><div class="line">            inc(rsum[j]-rmin[j]);</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (jl &lt; j &amp;&amp; (rmin[jl] &gt; lmin[i] || rmax[jl] &lt; lmax[i])) &#123;</div><div class="line">            dec(rsum[jl]-rmin[jl]);</div><div class="line">            jl++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (j &gt; m+<span class="number">1</span> &amp;&amp; lmin[i] == rmin[j<span class="number">-1</span>] &amp;&amp; lmax[i] == rmax[j<span class="number">-1</span>])</div><div class="line">            ret += get(k-(lsum[i]-lmax[i]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int64_t</span> divide(<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</div><div class="line">    <span class="keyword">if</span> (l &gt;= r)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">int32_t</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int32_t</span> mn = MAX, mx = MIN;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= l; i--) &#123;</div><div class="line">        sum += a[i], mn = min(mn, a[i]), mx = max(mx, a[i]);</div><div class="line">        <span class="keyword">if</span> (sum &gt;= k)sum %= k;</div><div class="line">        lsum[i] = sum, lmin[i] = mn, lmax[i] = mx;</div><div class="line">    &#125;</div><div class="line">    sum = <span class="number">0</span>, mn = MAX, mx = MIN;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m+<span class="number">1</span>; i &lt;= r; i++) &#123;</div><div class="line">        sum += a[i], mn = min(mn, a[i]), mx = max(mx, a[i]);</div><div class="line">        <span class="keyword">if</span> (sum &gt;= k)sum %= k;</div><div class="line">        rsum[i] = sum, rmin[i] = mn, rmax[i] = mx;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int64_t</span> c1 = <span class="number">0</span>, c2 = <span class="number">0</span>, c3 = <span class="number">0</span>, c4 = <span class="number">0</span>;</div><div class="line"></div><div class="line">    cases++; <span class="comment">// min max on the left</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j = m+<span class="number">1</span>; i &gt;= l; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (j &lt;= r &amp;&amp; lmin[i] &lt; a[j] &amp;&amp; a[j] &lt; lmax[i]) &#123;</div><div class="line">            inc(rsum[j]);</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; m)</div><div class="line">            c1 += get(k-(lsum[i]-lmin[i]-lmax[i]));</div><div class="line">    &#125;</div><div class="line">    cases++; <span class="comment">// min max on the right</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m+<span class="number">1</span>, j = m; i &lt;= r; i++) &#123;</div><div class="line">        <span class="keyword">while</span> (j &gt;= l &amp;&amp; rmin[i] &lt; a[j] &amp;&amp; a[j] &lt; rmax[i]) &#123;</div><div class="line">            inc(lsum[j]);</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &gt; m+<span class="number">1</span>)</div><div class="line">            c2 += get(k-(rsum[i]-rmin[i]-rmax[i]));</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    cases++;  <span class="comment">// min on the left, max on the right</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j = m+<span class="number">1</span>, jl = m+<span class="number">1</span>; i &gt;= l; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (j &lt;= r &amp;&amp; rmin[j] &gt;= lmin[i]) &#123;</div><div class="line">            inc(rsum[j]-rmax[j]);</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (jl &lt; j &amp;&amp; rmax[jl] &lt; lmax[i]) &#123;</div><div class="line">            dec(rsum[jl]-rmax[jl]);</div><div class="line">            jl++;</div><div class="line">        &#125;</div><div class="line">        c3 += get(k-(lsum[i]-lmin[i]));</div><div class="line">    &#125;</div><div class="line">    cases++; <span class="comment">// min on the right, max on the left</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m+<span class="number">1</span>, j = m, jl = m; i &lt;= r; i++) &#123;</div><div class="line">        <span class="keyword">while</span> (j &gt;= l &amp;&amp; lmin[j] &gt;= rmin[i]) &#123;</div><div class="line">            inc(lsum[j]-lmax[j]);</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (jl &gt; j &amp;&amp; lmax[jl] &lt; rmax[i]) &#123;</div><div class="line">            dec(lsum[jl]-lmax[jl]);</div><div class="line">            jl--;</div><div class="line">        &#125;</div><div class="line">        c4 += get(k-(rsum[i]-rmin[i]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int64_t</span> local = c1 + c2 + c3 + c4 - common(l, m, r);</div><div class="line">    <span class="keyword">return</span> local + divide(l, m) + divide(m+<span class="number">1</span>, r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k) == <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</div><div class="line">        <span class="built_in">memset</span>(counter, <span class="number">0</span>, <span class="keyword">sizeof</span>(counter[<span class="number">0</span>])*k);</div><div class="line">        <span class="keyword">int64_t</span> ret = divide(<span class="number">0</span>, n<span class="number">-1</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Algorithm Design and Analysis (NTU CSIE, Fall 2020)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="解題區" scheme="http://morris821028.github.io/categories/%E8%A7%A3%E9%A1%8C%E5%8D%80/"/>
    
      <category term="解題區 - 其他題目" scheme="http://morris821028.github.io/categories/%E8%A7%A3%E9%A1%8C%E5%8D%80/%E8%A7%A3%E9%A1%8C%E5%8D%80-%E5%85%B6%E4%BB%96%E9%A1%8C%E7%9B%AE/"/>
    
    
      <category term="分治" scheme="http://morris821028.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="排容" scheme="http://morris821028.github.io/tags/%E6%8E%92%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>ADA 2020 Fall P2. Bomb Game</title>
    <link href="http://morris821028.github.io/2020/10/31/lesson/ada-2020-hw1-p2/"/>
    <id>http://morris821028.github.io/2020/10/31/lesson/ada-2020-hw1-p2/</id>
    <published>2020-10-31T08:00:00.000Z</published>
    <updated>2020-11-01T05:25:06.880Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Algorithm Design and Analysis (NTU CSIE, Fall 2020)</p></blockquote><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>有數名玩家依序抵達遊戲，並且落在位置 <span>$c_i$</span><!-- Has MathJax -->，並且具有防禦力 <span>$d_i$</span><!-- Has MathJax -->，過程中會有炸彈發生於 <span>$[l_i, r_i]$</span><!-- Has MathJax -->，對防禦力小於等於 <span>$p_i$</span><!-- Has MathJax --> 造成 <span>$k_i$</span><!-- Has MathJax --> 點傷害。</p><p>回報遊戲最後每一名玩家所受的傷害總額。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">10 10</div><div class="line">P 3 5</div><div class="line">A 2 8 15 5</div><div class="line">P 7 10</div><div class="line">A 4 10 5 3</div><div class="line">A 1 9 10 7</div><div class="line">P 6 20</div><div class="line">P 5 1</div><div class="line">A 4 9 17 2</div><div class="line">A 1 2 20 4</div><div class="line">P 9 5</div></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">12</div><div class="line">9</div><div class="line">0</div><div class="line">2</div><div class="line">0</div></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><blockquote><p>由於沒辦法參與課程，就測測自己產的測試資料，正確性有待確認。</p></blockquote><p>如果這一題目強制在線對答，則需要一個樹套樹在 <span>$\mathcal{O}(\log^2 n)$</span><!-- Has MathJax --> 內回答每一個結果，需要一個動態開區間的實作方法。</p><p>如果採用離線處理，則可以透過逆序處理來回答，可以透過二維空間的 BIT 結構來完成，這時候空間上會是另一個問題，即使使用懶惰標記，預期可能會達到 <span>$\mathcal{O}(C \; D)$</span><!-- Has MathJax -->，通常是不允許的。</p><p>從分治算法切入，預想防禦能力高影響不受到攻擊力低的炸彈影響，無論時間與否都不受到影響。接下來，對防禦能力和攻擊力統稱力量。在分治的時候，對力量低的累計出答案，在合併階段受時間順序的影響才能回答。最後：</p><ol><li>對力量從小到大排序</li><li>分治算法<ol><li>對左區間和右區間按照時間由大到小排序</li><li>對於每一個左區間的詢問，插入所有滿足的右區間</li></ol></li></ol><p>時間複雜度 <span>$\mathcal{O}(n \log^2 n)$</span><!-- Has MathJax -->、空間複雜度 <span>$\mathcal{O}(n)$</span><!-- Has MathJax --> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// Algorithm Design and Analysis (NTU CSIE, Fall 2020)</span></div><div class="line"><span class="comment">// Problem 2. Bomb Game</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200005</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></div><div class="line">    <span class="keyword">int64_t</span> a[MAXN];</div><div class="line">    <span class="keyword">int</span> l[MAXN];</div><div class="line">    <span class="keyword">int</span> cases = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</div><div class="line">            <span class="keyword">if</span> (l[x] != cases)</div><div class="line">                l[x] = cases, a[x] = <span class="number">0</span>;</div><div class="line">            a[x] += val, x += x&amp;(-x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int64_t</span> sum(<span class="keyword">int</span> x) &#123;</div><div class="line">        <span class="keyword">int64_t</span> ret = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (x) &#123;</div><div class="line">            <span class="keyword">if</span> (l[x] != cases)</div><div class="line">                l[x] = cases, a[x] = <span class="number">0</span>;</div><div class="line">            ret += a[x], x -= x&amp;(-x);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        cases++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        add(l, k, n);</div><div class="line">        add(r+<span class="number">1</span>, -k, n);</div><div class="line">    &#125;</div><div class="line">&#125; bit;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PEvent</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> c, d, i;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AEvent</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> l, r, p, k;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Event</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> type; <span class="comment">// 'P' 0 or 'A' 1</span></div><div class="line">    <span class="keyword">int</span> time; <span class="comment">// input order</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        PEvent p;</div><div class="line">        AEvent a;</div><div class="line">    &#125; data;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> data.p.d;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> data.a.p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"P %d %d\n"</span>, data.p.c, data.p.d);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"A %d %d %d %d\n"</span>, data.a.l, data.a.r, data.a.p, data.a.k);</div><div class="line">    &#125;</div><div class="line">&#125; events[MAXN];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp_p</span><span class="params">(Event &amp;a, Event &amp;b)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> pa = a.power();</div><div class="line">    <span class="keyword">int</span> pb = b.power();</div><div class="line">    <span class="keyword">if</span> (pa != pb)</div><div class="line">        <span class="keyword">return</span> pa &lt; pb;</div><div class="line">    <span class="keyword">return</span> a.time &lt; b.time;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp_t</span><span class="params">(Event &amp;a, Event &amp;b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a.time &gt; b.time;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> ret[MAXN];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line">    sort(events+l, events+m+<span class="number">1</span>, <span class="keyword">cmp_t</span>);</div><div class="line">    sort(events+m+<span class="number">1</span>, events+r+<span class="number">1</span>, <span class="keyword">cmp_t</span>);</div><div class="line"></div><div class="line">    <span class="comment">//printf("resolve %d %d =========\n", l, r);</span></div><div class="line">    <span class="comment">//for (int i = l; i &lt;= m; i++)</span></div><div class="line">    <span class="comment">//events[i].println();</span></div><div class="line">    <span class="comment">//puts("---");</span></div><div class="line">    <span class="comment">//for (int i = m+1; i &lt;= r; i++)</span></div><div class="line">    <span class="comment">//events[i].println();</span></div><div class="line">    bit.reset(n);</div><div class="line">    <span class="keyword">int</span> j = m+<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= m; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (events[i].type)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">int</span> qtime = events[i].time;</div><div class="line">        <span class="keyword">while</span> (j &lt;= r &amp;&amp; events[j].time &gt; qtime) &#123;</div><div class="line">            <span class="keyword">if</span> (events[j].type) &#123;</div><div class="line">                bit.add(events[j].data.a.l,</div><div class="line">                        events[j].data.a.r,</div><div class="line">                        events[j].data.a.k,</div><div class="line">                        n);</div><div class="line">                <span class="comment">//printf("add %d %d %d %d\n", events[j].data.a.l,</span></div><div class="line">                <span class="comment">//events[j].data.a.r,</span></div><div class="line">                <span class="comment">//events[j].data.a.p,</span></div><div class="line">                <span class="comment">//events[j].data.a.k);</span></div><div class="line">            &#125;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//printf("%d --- %d\n", events[i].data.p.i, bit.sum(events[i].data.p.c));</span></div><div class="line">        ret[events[i].data.p.i] += bit.sum(events[i].data.p.c);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (l &gt;= r)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</div><div class="line">    divide(l, m);</div><div class="line">    divide(m+<span class="number">1</span>, r);</div><div class="line"></div><div class="line">    resolve(l, m, r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> m;</div><div class="line">    <span class="keyword">char</span> s[<span class="number">2</span>];</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</div><div class="line">        events[i].time = i;</div><div class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'P'</span>) &#123;</div><div class="line">            events[i].type = <span class="number">0</span>;</div><div class="line">            events[i].data.p.i = id++;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,</div><div class="line">                    &amp;events[i].data.p.c,</div><div class="line">                    &amp;events[i].data.p.d);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            events[i].type = <span class="number">1</span>;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,</div><div class="line">                    &amp;events[i].data.a.l, </div><div class="line">                    &amp;events[i].data.a.r,</div><div class="line">                    &amp;events[i].data.a.p,</div><div class="line">                    &amp;events[i].data.a.k);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sort(events, events+m, cmp_p);</div><div class="line">    divide(<span class="number">0</span>, m<span class="number">-1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id; i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret[i]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Algorithm Design and Analysis (NTU CSIE, Fall 2020)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="解題區" scheme="http://morris821028.github.io/categories/%E8%A7%A3%E9%A1%8C%E5%8D%80/"/>
    
      <category term="解題區 - 其他題目" scheme="http://morris821028.github.io/categories/%E8%A7%A3%E9%A1%8C%E5%8D%80/%E8%A7%A3%E9%A1%8C%E5%8D%80-%E5%85%B6%E4%BB%96%E9%A1%8C%E7%9B%AE/"/>
    
    
      <category term="分治" scheme="http://morris821028.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="整體二分" scheme="http://morris821028.github.io/tags/%E6%95%B4%E9%AB%94%E4%BA%8C%E5%88%86/"/>
    
      <category term="BIT" scheme="http://morris821028.github.io/tags/BIT/"/>
    
  </entry>
  
  <entry>
    <title>資訊科學的偏科生 面試者篇</title>
    <link href="http://morris821028.github.io/2020/10/25/diary-202010/"/>
    <id>http://morris821028.github.io/2020/10/25/diary-202010/</id>
    <published>2020-10-25T11:16:06.000Z</published>
    <updated>2020-10-25T12:52:01.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>從實習一年、正式工作三年，從一般的軟體工程職位軟體工程師 II (Software Enginner II) 開始爬，一年後升到資深工程師 (Senior Software Engineer)，第三年升到首席工程師 (Principal Software Engineer)，依照正常流程，這樣的躍遷是快的。</p><p>在薪水上可能會有點失望，必須了解到能力好與不好之間並沒有太大的差別，也就是說薪水不會有 30% 的差異，同時職位之間的差別也不到 20%。但工作量卻顯著地增加，這社會相當奇怪，這也難怪很多高科技的高手最後反而會想離開大公司的體制，自行創業或者轉行都是會發生的狀況。</p><p>從成功嶺出獄的第一天上班，頂著小平頭也參與面試流程，從那開始三年間面試了不少人，也與一些身歷百戰的朋友聊了一下狀況，而我卻沒站在白板上參與真的面試，大部分都是工作直接來找，看到需要繁瑣面試的公司都想直接忽略，畢竟身為一個偏科生，肯定是會被刷掉的，要找通才去找血統純正的學歷吧。</p><h2 id="面試狀況"><a href="#面試狀況" class="headerlink" title="面試狀況"></a>面試狀況</h2><h3 id="電話面試"><a href="#電話面試" class="headerlink" title="電話面試"></a>電話面試</h3><p>最近受到疫情影響，會盡量先以 <strong>電話面試</strong> 為第一關，通常會從簡單的問答看出端倪，如基礎的時間複雜度分析、程式架構、開發經歷上著手提問。有時會配上線上共享文件撰寫簡單的程式，這對刷 leetcode 準備面試的人都不算難。</p><p>通常用解說定義為主，或者可以分享一些使用經驗，對於模糊不清的項目直接表達說知道但是不熟悉，一旦描述錯誤或者是甚至在使用完全錯誤的方向，就會凸顯沒有仔細了解，在錯誤理解下又有大量的錯誤衍生，下場就會非常慘。</p><p>雷點如下：</p><ul><li>不知道二元樹的定義 (到底是怎麼碩班畢業的？)</li><li>不知道遞迴的實際流程 (到底是怎麼大學畢業的？)</li><li>要求指定語言的工作條件，卻不知物件導向 (可以不滿足所有應徵條件，但請理解每一項大概是什麼內容再來。)</li></ul><h3 id="自我介紹"><a href="#自我介紹" class="headerlink" title="自我介紹"></a>自我介紹</h3><p>通過第一階段後，很多人就會來到這個環節，通常要準備三十分鐘自我介紹，我比較喜歡稱作武力展示，但不是像相親那樣的自我介紹，如學歷、出生年月、興趣嗜好都不需要。如果早已遞交履歷，那些訊息不需要提第二次，這些口頭描述就像流水帳，聽起來也很無趣。</p><p>對於碩博剛畢業的人而言，大部分都直接拿論文出來講，對於程式能力比較吃重的職位，偏好程度很低，實在是不想當論文口委，畢竟研究領域差太遠，也不能驗證對錯與否。如果用口述方式表達，專有名詞與公式都也無法理解是否具有該實力。</p><p>從以前讀過碩班的經驗，很多碩士都是老師放水過關的，也有可能完全不需要寫程式的經驗也能畢業。對於那些跨科系的碩士及學碩學歷差異大的，都需配上其他的實務經驗，才能讓面試官比較有信心。</p><p>履歷部分請參考相關文章</p><ul><li><a href="https://blog.roga.tw/2009/11/2329" target="_blank" rel="external">《How the HR department and a programmer reads your resume?》 — roga’s blog</a></li><li><a href="https://kheresy.wordpress.com/2010/05/24/hr-%e5%92%8c%e7%a8%8b%e5%bc%8f%e8%a8%ad%e8%a8%88%e5%b8%ab%e6%80%8e%e9%ba%bc%e7%9c%8b%e4%bd%a0%e7%9a%84%e5%b1%a5%e6%ad%b7%ef%bc%9f/" target="_blank" rel="external">《HR 和程式設計師怎麼看你的履歷？》 — Heresy’s Space</a></li></ul><p>在過程中的確有幾個實際發生的項目</p><ol><li>博士學位的面試者容易遇到本公司可能無法讓你發展所才，請另尋他路的勸導<ul><li>原本想要的，但實在是太高學歷了。</li></ul></li><li>以 Microsoft Office Word/Excel 出現在技巧描述中<ul><li>因為大部分的工作工作都是之後再學，像這種被 GUI 固化的工具，很難拓展。</li></ul></li><li>只有在課堂上寫過程式，完全沒有課堂以外的程式項目或參與專案<ul><li>課堂以內是可接受的，但需要體現足夠自我挖掘與學習能力</li></ul></li><li>履歷上的縮排混雜著空白字元和跳脫字元<ul><li>若採用中文履歷，可參閱 <a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="external">github/中文文案排版指北</a></li><li>體現細心與自我要求的程度，通常會視為考量部分。</li></ul></li></ol><p>在其他未提及和重點項目，</p><ol><li>履歷鏈結中出現 <code>?fbclid=XXX</code>，作為一個從事資訊行業的人會直接出局。</li><li>強調的內容卻用淡色系的文字或其他方式呈現，脫離一般的思考模式。</li><li>個人網站<ul><li>能提高具有該實力的證明。</li><li>展示出資訊整合的高度能力就是寫作，也可以從中看出溝通能力。</li><li>因分享教學是最好的學習，請參閱「費曼學習法」。</li></ul></li><li>github/bitbucket 等代碼託管帳號<ul><li>自行開發的項目架構一覽無遺，直接進行武力展示。</li><li>參與的開放項目，展現其求知慾與發現問題並解決的能力。</li><li>參與的專案討論，展現其挖掘與辯論分析的能力。</li></ul></li></ol><p>在過程中可以透過白板直接介紹，也可以純口頭表達，亦可以採用簡報的方式，手法不受任何限制，但盡量貼合目標工作內容所需要的技能或是該公司缺少的項目為主軸。千萬別忘記體現自己所做過，拉回自己擅長的領域。</p><p>有時面試官突然問個太細節的問題，則需要準備概要和講給不同領域的人能理解的一句話，否則將容易錯失表現機會。畢竟那些項目細節上網搜尋即可，就像論文描述幾十頁，而摘要卻只有幾百個字一樣，唯有充分理解的人，才能做到的能力。千萬別花半個小時去描述需要解決的問題定義，適可而止！</p><h3 id="筆試"><a href="#筆試" class="headerlink" title="筆試"></a>筆試</h3><p>好的公司是不會有筆試的。若有，則筆試應該只是參考依據。對沒有推薦人或認識的狀況下，筆試都是從嚴審核。反之，就不會佔有太大的比重。</p><blockquote><p>不同類型的公司對筆試的考核方式皆不同。</p></blockquote><p>對於著重實作細節的公司，如指定語言下的語法考試，甚至有一些未定義行為 (undefined behavior) 的項目需要注意，有的還會考以前大學教科書上附錄不想見的問題。這類型因為工作環境和需求，可能會讓新人非常受挫，對於新人的要求會比較高，才剛畢業的人通常要具備在沒有搜尋資源下，也能略知一二的能力。</p><p>對於跨領域的公司，會有一些其他領域題型，具有博學能力的人就會特別被選拔出來。像我們 EDA 公司，就有機會看到電子電路的題目，實際上答不出來也很正常，不用太沮喪，導致下一個階段表現不好。</p><p>對於應用方面，題目描述的手法也不一定像學校所學的非一即二的要求。若看到含糊不清的描述，那表示接下來的工作環境就是那種含糊不清的需求，則在答題上要自己以自身經驗去約束和討論問題，才能符合需求，原則上是以申論題的模式作答。</p><p>雷點如下：</p><ul><li>沒有檢查輸入、輸出的定義<ul><li>那個不是已知的條件，不能假設，常理上是絕對不行的啦。</li></ul></li><li>不完整的程式片段<ul><li>到底要回傳什麼，記得寫。</li></ul></li><li>不完整的上下文描述</li><li>沒有計算過程的答案<ul><li>直接迸出一個數值。如果答錯，是完全沒有轉圜的餘地的。畢竟不知道你是不是費馬，還是把過程列出來吧。</li></ul></li><li>全然忘卻高中數學<ul><li>如為什麼 <span>$\sin \theta$</span><!-- Has MathJax --> 是 <span>$\frac{a}{c}$</span><!-- Has MathJax --></li></ul></li><li>相關題目的邏輯矛盾<ul><li>如在前一題答說 A 是缺點，卻在下一題答 A 是優點</li></ul></li><li>履歷中有提及此項目，卻無法以此作答<ul><li>履歷上的項目看起來只是掛名的對吧？像是上百人團隊的工作項目。</li></ul></li><li>論述內容呈現大學必修科目沒有學好<ul><li>如說雜湊的整體空間複雜度是 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --></li></ul></li><li>在行為準則考題中，連演都不演的真性格<ul><li>Q: 能不能與同事合作 A: 完全無法</li></ul></li></ul><p>同時，在撰寫的代碼中很容易展現出經驗差距，容易出錯的寫法雖然沒錯，卻間接告訴面試官有經驗不足的缺點。</p><h3 id="白板題"><a href="#白板題" class="headerlink" title="白板題"></a>白板題</h3><p>解決只刷 leetcode 的假工程師的回合 (與考驗同事的時候)。</p><p>每題作答 30 分鐘，採用白板討論構思方向與實作細節。通常考三題，答題過快會有第四個防破台題目出現，題目對於以前打比賽的都是水題，基本上都會在十分鐘內解決。</p><p>類型通常都是教科書上每一章節的經典算法，答不出來或者構思錯誤，多半都會被刷掉。即使答出來，討論實務經驗時，也會從中觀察出是否有足夠的學習基礎，以及對所學的概念應用的能力。那些培訓班出來的假高手通常會在變化題型受挫，分析相關問題時無法應答，及缺少實務相關經驗。</p><h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>不太選用從短程培訓班出來的，風險相當大，因為太多沒有實戰或者過時技術的老師在外頭開補習班。試想過，為什麼能力好卻不從事開發工作，卻跑來當老師的原因嗎？再者，程式補習班老師多半沒有學過教育學程，跟教授一樣不需要，那麼教學品質很難有所保證。</p><p>現在又有大學入學程式考試 APCS (Advanced Placement Computer Science)，自稱老師的越來越多，家長又瘋狂地看著老師的名號去選擇，而不知道科技業每一個職位與工作時間是有很大的差異，就像工作沒幾年就轉戰的 youtuber ，的確是高學歷也很聰明，但對於整體知識的養成與發展概念，通常都還沒沒達到融會貫通，只有問 A 答 B 的快速反應，缺少對 A 的定義及其他種非正規的可應用解的能力。</p><p>如何了解、觀察、解決、應用問題，適當地啟蒙學生才是老師要引導的。若像大學教授一樣教學生，九成的大學生畢業之後都不到八成內容。只是要知道問題的解決方法，可能還贏不了 Google，看看複製貼上的工程師就明白了。</p><p>有一些認識的學長，也開始從事家教和補習班老師，希望能遏止這種劣質的教學環境，就看看近期有沒有發展吧。</p><p>藉此，了解到不少學校的學生都找家教當槍手，學歷似乎也不能證明任何能力，家長資助和選對槍手才是當代的生存之道。面對欺瞞的文化，不行就說不行，請不要裝作很行，在面試過程中試出來，公司可是會記錄評價的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;從實習一年、正式工作三年，從一般的軟體工程職位軟體工程師 II (Software Enginner II) 開始爬，一年後升到資深工程師 
      
    
    </summary>
    
      <category term="手札日記" scheme="http://morris821028.github.io/categories/%E6%89%8B%E6%9C%AD%E6%97%A5%E8%A8%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Company Ghost Story 公司鬼故事 6</title>
    <link href="http://morris821028.github.io/2020/10/24/work/company-ghost-story-6/"/>
    <id>http://morris821028.github.io/2020/10/24/work/company-ghost-story-6/</id>
    <published>2020-10-24T10:00:00.000Z</published>
    <updated>2020-10-24T09:29:26.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Observer-vs-Inheritor"><a href="#Observer-vs-Inheritor" class="headerlink" title="Observer vs. Inheritor"></a>Observer vs. Inheritor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Tool tool = <span class="keyword">new</span> Tool() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fireSomething</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.fireSomething(t);</div><div class="line">        updateProcess(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateProcess</span><span class="params">(T t)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure><p>當觀察者模式 (observer pattern) 的介面應優先考量 attach/addListener，不應該以繼承的方式覆寫 update/fireListener/notify 等函數。</p><h3 id="WhatIf"><a href="#WhatIf" class="headerlink" title="WhatIf?"></a>WhatIf?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (isA()) &#123;</div><div class="line">    <span class="comment">// something</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isA() &amp;&amp; isB()) &#123;</div><div class="line">    <span class="comment">// dead code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二個 else-if 並不會執行到。</p><h3 id="Equals-vs"><a href="#Equals-vs" class="headerlink" title="Equals vs. =="></a>Equals vs. ==</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (a == b &amp;&amp; a.equals(b)) &#123;...&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (a == b || a.equals(b)) &#123;...&#125;</div></pre></td></tr></table></figure><p>對 Java 而言，有 <code>Objects.equals</code> 可以替代呼叫，又或者在 <code>boolean equals(Object)</code> 中包含 <code>==</code> 才對。</p><h3 id="String-format"><a href="#String-format" class="headerlink" title="String.format"></a>String.format</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String.format(<span class="string">"Move %s"</span>, fromObj, toObj);</div></pre></td></tr></table></figure><p>對上參數數量是很重要的。</p><h3 id="Mapper-Function"><a href="#Mapper-Function" class="headerlink" title="Mapper Function"></a>Mapper Function</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> T <span class="title">a2b</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">    Map&lt;String, T&gt; mapper = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    mapper.put(<span class="string">"..."</span>, ...);</div><div class="line">    mapper.put(<span class="string">"..."</span>, ...);</div><div class="line">    mapper.put(<span class="string">"..."</span>, ...);</div><div class="line">    mapper.put(<span class="string">"..."</span>, ...);</div><div class="line">    <span class="keyword">return</span> mapper.get(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>手動做 if-else 比較快的，建立 hash 可不是這麼簡單，記憶體宣告等因素需要考慮。而它也不屬於只宣告一次的靜態變數，因此並不適合這樣處理。</p><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] c = &#123;fa.compareTo(other.fa), fb.compareTo(other.fb) ...&#125;;</div><div class="line">    <span class="keyword">return</span> firstNotZero(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>if-else 不應該這樣被偷懶的，整個效能都爛了。</p><h3 id="Argument-vs-Method-Name"><a href="#Argument-vs-Method-Name" class="headerlink" title="Argument vs. Method Name"></a>Argument vs. Method Name</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doExpand</span><span class="params">(<span class="keyword">boolean</span> isExpand)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isExpand)</div><div class="line">        doCollapse();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好的命名決定品質。</p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enableAListener</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeAListener</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBListener</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stopBListener</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCListener</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">disableCListener</span><span class="params">()</span> </span>&#123;</div><div class="line">    sListeners.remove(sAListener);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有一種被玩弄的感覺 …</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;&lt;h3 id=&quot;Observer-vs-Inheritor&quot;&gt;&lt;a href=&quot;#Observer-vs-Inheritor&quot; c
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="鬼故事" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
    
      <category term="鬼故事" scheme="http://morris821028.github.io/tags/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Company Ghost Story 公司鬼故事 5</title>
    <link href="http://morris821028.github.io/2020/09/30/work/company-ghost-story-5/"/>
    <id>http://morris821028.github.io/2020/09/30/work/company-ghost-story-5/</id>
    <published>2020-09-30T12:00:00.000Z</published>
    <updated>2020-09-30T13:00:45.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Duplicate-Field"><a href="#Duplicate-Field" class="headerlink" title="Duplicate Field"></a>Duplicate Field</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> A a;</div><div class="line">    <span class="keyword">final</span> A b;</div><div class="line">    C(A a) &#123;</div><div class="line">        <span class="keyword">this</span>.a = a;</div><div class="line">        <span class="keyword">this</span>.b = a; <span class="comment">// why?</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>為什麼要做出兩個相同意義的欄位？</p><h3 id="Strange-Method-Name"><a href="#Strange-Method-Name" class="headerlink" title="Strange Method Name"></a>Strange Method Name</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisable</span><span class="params">(<span class="keyword">boolean</span> d)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisable</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisabled</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>英文不好的我，一度慘死。</p><h3 id="Strange-Method-Name-II"><a href="#Strange-Method-Name-II" class="headerlink" title="Strange Method Name II"></a>Strange Method Name II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> e)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getEnabled</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>拜託決定一種風格做一件事情。</p><h3 id="Inefficient-Listener"><a href="#Inefficient-Listener" class="headerlink" title="Inefficient Listener"></a>Inefficient Listener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Component c)</span> </span>&#123;</div><div class="line">    c.addFocusListener(...);</div><div class="line">    c.addChangeListener(...);</div><div class="line">    c.addSelectListener(...);</div><div class="line">    c.setSelect(...); <span class="comment">// trigger listener ...</span></div><div class="line">    c.setFocus(...); <span class="comment">// trigger listener ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>初始化的優先順序很重要，多次觸發有可能發生，造成重複處理。</p><h3 id="Override-Method"><a href="#Override-Method" class="headerlink" title="Override Method"></a>Override Method</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uninstall</span><span class="params">()</span> </span>&#123;</div><div class="line">    uninstallMe();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">uninstallMe</span><span class="params">()</span> </span>&#123; <span class="comment">// why not write into uninstall()?</span></div><div class="line">    <span class="comment">// something ...</span></div><div class="line">    <span class="keyword">super</span>.uninstall();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>函數這麼簡單，為什麼 <code>super.method</code> 寫在原本的函數外部。出現不同於 <code>@Override</code> 的函數中實在少見。</p><h3 id="Empty-Listener"><a href="#Empty-Listener" class="headerlink" title="Empty Listener"></a>Empty Listener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">c.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.windowClosed(e);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>不要註冊一堆空操作。</p><h3 id="Override-Empty"><a href="#Override-Empty" class="headerlink" title="Override Empty"></a>Override Empty</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// please add comment here if remove parent processing</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>這不知道在寫什麼，也沒叫 <code>super.install()</code>，該觸發事件的都沒觸發，真的沒事嗎？應該是寫錯了吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;&lt;h3 id=&quot;Duplicate-Field&quot;&gt;&lt;a href=&quot;#Duplicate-Field&quot; class=&quot;header
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="鬼故事" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
    
      <category term="鬼故事" scheme="http://morris821028.github.io/tags/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Company Ghost Story 公司鬼故事 4</title>
    <link href="http://morris821028.github.io/2020/09/26/work/company-ghost-story-4/"/>
    <id>http://morris821028.github.io/2020/09/26/work/company-ghost-story-4/</id>
    <published>2020-09-26T02:00:00.000Z</published>
    <updated>2020-09-26T01:42:06.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h2><h3 id="Commit-File"><a href="#Commit-File" class="headerlink" title="Commit File"></a>Commit File</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ svn status</div><div class="line">  .DS_Store</div><div class="line">  import.csv$</div><div class="line">  export.txt~</div><div class="line">  test_result.txt</div><div class="line">  golden.txt</div><div class="line">? test_result.log</div></pre></td></tr></table></figure><ul><li>別建立隱藏檔案格式，以小數點 <code>.</code> 開頭的在 Linux 可是隱藏檔案的意思</li><li>別上傳 <code>.DS_Store</code> 那個是 Mac 平台上的隱藏檔案，並不需要</li><li>別上傳 <code>xxx.csv$</code>那個是 Microsoft 平台上的 lock 檔案，並不需要</li><li>別上傳 <code>xxx.txt~</code> 那個是 emacs, nano, vim 等製造的備份檔案，並不需要</li><li>別上傳測試結果，如 <code>test_result.txt</code>，正常來講會覆寫，傳上去結果沒產生怎麼辦，比對還會過呢。</li><li>別上傳空資料夾</li></ul><h3 id="Commit-Log"><a href="#Commit-Log" class="headerlink" title="Commit Log"></a>Commit Log</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ svn <span class="built_in">log</span> golden.txt</div><div class="line">------------------------------------------------------------------------</div><div class="line">r32 | product_bot | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line</div><div class="line"></div><div class="line">Update golden</div></pre></td></tr></table></figure><p>拜託用自己的帳號上傳，不小心用到 <code>product_bot</code> 這種全自動的帳號，不曉得是誰修改的內容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SVN&quot;&gt;&lt;a href=&quot;#SVN&quot; class=&quot;headerlink&quot; title=&quot;SVN&quot;&gt;&lt;/a&gt;SVN&lt;/h2&gt;&lt;h3 id=&quot;Commit-File&quot;&gt;&lt;a href=&quot;#Commit-File&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="鬼故事" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
    
      <category term="鬼故事" scheme="http://morris821028.github.io/tags/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>為什麼不推薦用 Java Stream 改寫迴圈</title>
    <link href="http://morris821028.github.io/2020/09/20/java/java-stream/"/>
    <id>http://morris821028.github.io/2020/09/20/java/java-stream/</id>
    <published>2020-09-20T10:00:00.000Z</published>
    <updated>2020-09-20T11:16:55.446Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 開始推出了 stream 介面，搭配 lambda 可以達到函數式編程 (functional language) 的能力，但是也造成非常多的效能爆炸的憾事。尤其是在我們沒有深入了解官方實作的細節時，請別輕易地轉換到 stream 介面。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>在 <code>Stream</code> 出現之前，我們可以透過 <code>Iterator</code> 的實作來達到串流的概念，如 guava 庫所提供的 <code>FluentIterable</code> 就是一個替代方案。公司內部則是因為維護問題自己實作了一個自己的庫，因此沒辦法輕易地用 guava 的項目。但其中一點很明顯的不同在於 parallel 並行特性，即使是 <code>FluentIterable</code> 中，我也未見相關的平行操作。</p><p>在自己實作庫、人手不足的團隊配置下，直接吹捧去使用現有的函數庫，那麼問題就容易出現在於轉換上。必須考慮「何時我們該去使用」，決定好使用場景，再決定是否要改寫。公司已經升級到了 JDK 11 的，在銜接官方的 stream 實作時，依舊造成顯著的效能退化，甚至還有嚴重的運行問題，導致 dead lock 等問題。</p><h3 id="Static-Initialization-Block"><a href="#Static-Initialization-Block" class="headerlink" title="Static Initialization Block"></a>Static Initialization Block</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">classA</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        getXXX().parallelStream().forEach(e -&gt; doSomething(e));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 JDK 11 中，可能會無知地不小心在 static initialization block 中觸發 parallel 特性，此時會造成程式無法運行、卡住。這個問題在於 threading 之間調度時的鎖，另一部分則是 lambda 抓取變數造成的。目前在 bug <a href="https://bugs.openjdk.java.net/browse/JDK-8143380" target="_blank" rel="external">JDK-8143380</a> 回報系統上看出無意解決此問題，因為這是人為撰寫的問題。如果是呼叫大量的函數來初始化參數，很容易遇到不知道哪個函數區塊內偷偷開了平行計算。</p><p>像同事都把 <code>stream()</code> 都改寫成 <code>parallelStream()</code>，不管問題是大是小，這樣改寫有時候就造成莫名其妙的 Bug 發生，造成找了半天才發現問題。如果覺得著官方提供的項目都有公信力，而且不會做很蠢的事情，一直都可以很聰明地在平行與不平行取捨的話，那其實也不用設計 <code>parallelStream()</code> 給我們使用，統一一個 <code>stream()</code> 接口就好。</p><p>想到同事如此狂妄的想法「工程師不該考慮資源，從摩爾定律來看，硬體明年就會解決，我們要做出更好的 scalability 的寫法」，讓我整個火氣都上來，無法接受 <strong>用而不知</strong> 的習慣。在沒人力挺下，只能眼真真地看著代碼被改得亂七八糟。</p><h3 id="Stream-Cost"><a href="#Stream-Cost" class="headerlink" title="Stream Cost"></a>Stream Cost</h3><p>了解 <code>Stream</code> 基礎實作後，就會明白在沒有平行的狀況下，維護 stage 的狀態會是額外開銷，相較於手刻的 <code>Iterator</code>，很多沒有必要的狀態紀錄容易在非常簡單的迭代器中暴露。</p><h3 id="Stream-Concatentation"><a href="#Stream-Concatentation" class="headerlink" title="Stream Concatentation"></a>Stream Concatentation</h3><p>串流串接又是更可怕的實作技術，請參閱附錄文章 <a href="https://www.techempower.com/blog/2016/10/19/efficient-multiple-stream-concatenation-in-java/" target="_blank" rel="external">Efficient multiple-stream concatenation in Java</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">                                       concat(concat(concat(a, b), c), d)</div><div class="line">                                      /                                 \</div><div class="line">               concat(concat(a, b), c)                                   d</div><div class="line">              /                      \</div><div class="line">  concat(a, b)                        c</div><div class="line"> /           \</div><div class="line">a             b</div></pre></td></tr></table></figure><p>串接的實作像是二元樹。如果操作順序不當，馬上會產生一棵偏斜的二元樹，假設我們要取 <code>a</code> 裏頭的元素，則必須從根一路走到葉節點去。如果構造 $n$ 次操作，且每一個恰好為一個元素，蒐集所有的內容，時間複雜度為 $O(n^2)$。</p><p>因此，亂改寫遞迴構造器很容易出現問題，不如用原本的回傳值 <code>List/Collection</code> 把要的東西收集好，不支援惰性操作也好，舊的寫法依舊在 $O(n)$ 完成。若要支援惰性操作，使用 <code>StreamBuilder</code> 建立平衡的二元樹也能在 $O(n \log n)$ 最慘複雜度下完成迭代。</p><p>這個問題並不是開 <code>parallelStream()</code> 解決，必須從根本的複雜度去分析，</p><h3 id="Iterator-to-Stream"><a href="#Iterator-to-Stream" class="headerlink" title="Iterator to Stream"></a>Iterator to Stream</h3><p>從內建的 <code>Collection</code> 到 <code>Stream</code> 大部分都由官方做得很好，用不著花太多的心思去思考如何實作，直接呼叫相關函數即可。如果工作需要自己的 <code>Iterator</code> 變成 <code>Stream</code> 就沒有這麼好運。必須了解什麼是 <code>Spliterator</code>，而 <code>Spliterator</code> 是怎麼實作的，會有什麼樣的介面，而它是從何支援 <code>parallelStream</code> 這一項特性。</p><p>假設您已經詳讀 <code>Spliterators.java</code> 下的所有代碼，如自動建造函數 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Spliterator&lt;T&gt; <span class="title">spliteratorUnknownSize</span><span class="params">(Iterator&lt;? extends T&gt; iterator, <span class="keyword">int</span> characteristics)</span></span></div></pre></td></tr></table></figure><p>標示不確定迭代器實際運行的元素個數，好比在 stream 的 <code>flatMap()</code> 和 <code>filter()</code> 後，無法得知下一階段的元素多寡。在這些情況下只能透過這一類函數構造。然而官方預設的行為卻造成了嚴重的效能問題，它要求建造一個 <code>IteratorSpliterator</code>，而為了支援平行特性，平行通常需要透過高效的拆分陣列完成工作分配，因此會呼叫 <code>Spliterator::trySplit</code> 不斷地拆分，從源代碼中我們可以得知在未知大小的狀況下，則建立 <code>new Object[1024]</code> 預處理資料結構，即使在沒有開啟 <code>parallelStream</code>，依舊按照相同的運行流程。</p><p>有人說在 Java 開 <code>new Object[1024]</code> 很快，而最慘情況迭代器就只有一個元素，甚至沒有任何的狀況下，用最蠢的實作只消耗了一個迭代器的宣告開銷，而轉換串流卻消耗了整整數千個位元組，這是個效能損耗。就算 GC 很強，也不代表它能發現這麼複雜的操作，它整整跨足了超過一個函數區塊。</p><p>工作中因為繪製處理，需要運算數億次，若每一次都宣告這麼多餘的陣列，那麼莫虛有內存損耗高達幾十 GB，GC 若要運行 10 次，畫面繪製需要多一分鐘都是有可能的，將數秒不到的計算整整拖累下去。</p><h3 id="Lazy-Evaluation"><a href="#Lazy-Evaluation" class="headerlink" title="Lazy Evaluation"></a>Lazy Evaluation</h3><p>惰性計算是 stream 的主要特性之一，從另一個術語按需計算 (on-demand)。即使是官方提供的庫也有一些小 Bug 造成假的惰性計算。最常見的像是 <code>flatMap</code>、<code>map</code> 和 <code>filter</code> 混用的時候，最後使用 <code>findFirst</code> 操作。從代碼上，我們會預期差不多就是找到一個元素之前的所有計算，而從回報系統裡面下關鍵字去找，會發現不少多餘的計算發生。</p><p>同事老是說「我們自己的庫超慢的，用 stream 比較快。」</p><blockquote><p>言下之意，只是沒有遇到官方庫的 Bug，而你看到了庫的 Bug 卻從沒打算解決。</p></blockquote><p>最常見的迭代器實作，忘了 Lazy Evaluation 的寫法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!hasNext())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        T val = nextVal;</div><div class="line">        findNext(); <span class="comment">// on-demand ?</span></div><div class="line">        <span class="keyword">return</span> val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;...&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        ... <span class="comment">// time complexity ?</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>很明顯地，透過 <code>findNext()</code> 我們可能只拿了第一個元素，在不需要第二個元素的狀況下，卻耗費了線性時間。</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>還有一些問題，下一次再聊聊吧。</p><h2 id="Reading-List"><a href="#Reading-List" class="headerlink" title="Reading List"></a>Reading List</h2><ul><li><a href="https://blog.jooq.org/2015/12/08/3-reasons-why-you-shouldnt-replace-your-for-loops-by-stream-foreach/" target="_blank" rel="external">3 Reasons why You Shouldn’t Replace Your for-loops by Stream.forEach()</a></li><li><a href="https://www.techempower.com/blog/2016/10/19/efficient-multiple-stream-concatenation-in-java/" target="_blank" rel="external">Efficient multiple-stream concatenation in Java</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 8 開始推出了 stream 介面，搭配 lambda 可以達到函數式編程 (functional language) 的能力，但是也造成非常多的效能爆炸的憾事。尤其是在我們沒有深入了解官方實作的細節時，請別輕易地轉換到 stream 介面。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="Java" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/Java/"/>
    
    
      <category term="優化" scheme="http://morris821028.github.io/tags/%E5%84%AA%E5%8C%96/"/>
    
      <category term="Java" scheme="http://morris821028.github.io/tags/Java/"/>
    
      <category term="stream" scheme="http://morris821028.github.io/tags/stream/"/>
    
      <category term="lambda" scheme="http://morris821028.github.io/tags/lambda/"/>
    
      <category term="performance" scheme="http://morris821028.github.io/tags/performance/"/>
    
      <category term="效能" scheme="http://morris821028.github.io/tags/%E6%95%88%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Company Ghost Story 公司鬼故事 3</title>
    <link href="http://morris821028.github.io/2020/09/20/work/company-ghost-story-3/"/>
    <id>http://morris821028.github.io/2020/09/20/work/company-ghost-story-3/</id>
    <published>2020-09-20T06:00:00.000Z</published>
    <updated>2020-09-20T05:24:45.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Setter-Getter"><a href="#Setter-Getter" class="headerlink" title="Setter/Getter"></a>Setter/Getter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span> </span>&#123;</div><div class="line">    <span class="function">X <span class="title">getX</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">x</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">readX</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parseX</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">X</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Java 特性預設都是透過 setter/getter 的概念來完成成員變數的存取。為了擴充使用不建議直接存取變數。</p></blockquote><p>這毫無設計的函數是發生甚麼事情？名字這麼像是想害死誰啊，而且還都是不同邏輯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span> </span>&#123;</div><div class="line">    <span class="function">X <span class="title">eX</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">aX</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sX</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不是這樣子說完，就用奇怪的前綴解決。把整個動詞完整描述出來會讓你打字很痛苦嗎？</p><h3 id="Inner-Anonymous-Class"><a href="#Inner-Anonymous-Class" class="headerlink" title="Inner/Anonymous Class"></a>Inner/Anonymous Class</h3><p>現在我們用一個指令去搜尋建立的 class files。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ find ./bin -name <span class="string">"*\$[0-9]*.class"</span></div><div class="line">xxxx<span class="variable">$1</span><span class="variable">$1</span>.class</div><div class="line">xxxx<span class="variable">$64</span><span class="variable">$1</span>.class</div><div class="line">...</div><div class="line">xxxx<span class="variable">$64</span><span class="variable">$64</span>.class</div></pre></td></tr></table></figure><p>居然發現了非常非常多的匿名類別，而且還是爆炸性的嵌套。這意味者當改變一個 class 檔案時，編譯會一次可能產生上百個檔案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getToken</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Token &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"here we are"</span>; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>這也是常常在調適函數時，不知道為什麼會有 IDE 崩潰的情況發生。其實都是上述的寫法氾濫，連帶的內存洩漏問題也很嚴重。事實上，大部分的匿名類別都可以額外地用功能去描述類別，請重新宣告並且命名好。</p><h3 id="Long-Name-Method"><a href="#Long-Name-Method" class="headerlink" title="Long Name Method"></a>Long Name Method</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addXXXsToAdjacentYYYsSetSoItWillNotAAABBBWhereMMM</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setXInDatabaseAAABBBField</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><p>這種命名函數比惡名昭彰的匈牙利還兇殘，直接把文件描述寫在函數上，這時候又願意打字了。</p><p>請找個稍微中立一點描述方法，等到哪天換了連帶功能，所有相關函數都要重新做過。</p><h3 id="Create-Context"><a href="#Create-Context" class="headerlink" title="Create Context"></a>Create Context</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        readPartA();</div><div class="line">        externalCall();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        setCacheEnabled(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readPartA</span><span class="params">()</span> </span>&#123;</div><div class="line">    setCacheEnabled(<span class="keyword">false</span>); <span class="comment">// why not place it in read()?</span></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// in external.xxx</span></div><div class="line">java::setCacheEnabled(<span class="keyword">false</span>); <span class="comment">// what are you doing?</span></div><div class="line">...</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div></pre></td></tr></table></figure><p>建立 context 的習慣是要寫在同一個檔案中，而且盡可能寫在同一個函數內。</p><p>跳來跳去，有時候只有下文，有時候只有上文，不覺得很可怕嗎？萬一中間執行失敗，直接萬劫不復。</p><h3 id="Create-Context-II"><a href="#Create-Context-II" class="headerlink" title="Create Context II"></a>Create Context II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    db.setDbCheckEnabled(<span class="keyword">false</span>);</div><div class="line">    ...</div><div class="line">    <span class="comment">// where's your setDbCheckEnabled(true);, can I trust you more?</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>直接把所有重要檢查通通關閉，卻忘了開起來，直接出逃啦。</p><h3 id="Create-Context-III"><a href="#Create-Context-III" class="headerlink" title="Create Context III"></a>Create Context III</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        db.setDbCheckAEnabled(<span class="keyword">false</span>);</div><div class="line">        db.setDbCheckBEnabled(<span class="keyword">false</span>);</div><div class="line">        ...</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        db.setDbCheckAEnabled(<span class="keyword">true</span>); <span class="comment">// setDbCheckBEnabled() first, please</span></div><div class="line">        db.setDbCheckBEnabled(<span class="keyword">true</span>); <span class="comment">// setDbCheckAEnabled() last, please</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>大部分都不會錯，但建議採用堆疊的順序撰寫。因為有些保護機制會造成重複工作。</p><h3 id="Create-Context-IV"><a href="#Create-Context-IV" class="headerlink" title="Create Context IV"></a>Create Context IV</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        db.setDbCheckAEnabled(<span class="keyword">false</span>);</div><div class="line">        db.setDbCheckBEnabled(<span class="keyword">false</span>);</div><div class="line">        ...</div><div class="line">        db.setDbCheckBEnabled(<span class="keyword">true</span>); <span class="comment">// I don't know.jpg</span></div><div class="line">        ...</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        db.setDbCheckBEnabled(<span class="keyword">true</span>);</div><div class="line">        db.setDbCheckAEnabled(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我不知道.jpg。</p><h2 id="Regression-Test"><a href="#Regression-Test" class="headerlink" title="Regression Test"></a>Regression Test</h2><h3 id="Create-Test-Folder"><a href="#Create-Test-Folder" class="headerlink" title="Create Test Folder"></a>Create Test Folder</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ tree Regression/FunctionA</div><div class="line">├─testBBBB</div><div class="line">│  └─testCCCC</div><div class="line">│    └─testDDDD</div><div class="line">│      └─test.sh</div><div class="line">...</div></pre></td></tr></table></figure><p>為什麼需要前綴 test？請給我一個理由。</p><h3 id="Create-Test-Folder-II"><a href="#Create-Test-Folder-II" class="headerlink" title="Create Test Folder II"></a>Create Test Folder II</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tree Regression/FunctionA</div><div class="line">├─DoNotThrowNoSuchElementException</div><div class="line">│  └─test.sh</div><div class="line">...</div></pre></td></tr></table></figure><p>如果是預期丟出錯誤的測試就算了，但錯誤的實例也是會變動的，這樣的資料夾名字不具有太深遠的意義。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;&lt;h3 id=&quot;Setter-Getter&quot;&gt;&lt;a href=&quot;#Setter-Getter&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="鬼故事" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
    
      <category term="鬼故事" scheme="http://morris821028.github.io/tags/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Company Ghost Story 公司鬼故事 2</title>
    <link href="http://morris821028.github.io/2020/09/13/work/company-ghost-story-2/"/>
    <id>http://morris821028.github.io/2020/09/13/work/company-ghost-story-2/</id>
    <published>2020-09-13T06:00:00.000Z</published>
    <updated>2020-09-13T05:37:21.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><h3 id="Overprotection"><a href="#Overprotection" class="headerlink" title="Overprotection"></a>Overprotection</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_intersect</span><span class="params">(<span class="built_in">list</span>&lt;shape&gt; a, tree b, shape c)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (b == null)</div><div class="line">       b = <span class="keyword">new</span> tree(a);</div><div class="line">   <span class="keyword">return</span> b.find_intersect(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>過度保護，造成最後沒人知道 a 和 b 的關係。結果有時候 b 不是由 a 建立的，整串都不知道在做什麼。</p><h3 id="Evil-Comma"><a href="#Evil-Comma" class="headerlink" title="Evil Comma"></a>Evil Comma</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>);</div><div class="line">str = str.substr(<span class="number">1</span>);</div></pre></td></tr></table></figure><p>排版已經告訴你可能發生了問題，但看起來還是救不了下面那一行。似乎沒有發生意外，但是非常恐怖。</p><h3 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> x = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    x = x + pts[i].str();</div><div class="line"><span class="comment">//  x += pts[i].str();</span></div></pre></td></tr></table></figure><p>組成不是大問題，串起來就崩潰 $O(n^2)$。請善用 in-place 的串接。</p><h3 id="Test-Script"><a href="#Test-Script" class="headerlink" title="Test Script"></a>Test Script</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// testXXX.cpp</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    ... <span class="comment">// 100,000+ lines</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ testXXX.cpp -O3</div></pre></td></tr></table></figure><p>浪費生命從編譯時間著手，拜託開 <code>-O0</code> 就好，這樣就近乎線性時間的編譯速度。開到 <code>-O3</code> 會有平方層級的編譯時間，$(10^5)^2$ 雖然也不是很多，但突然從幾秒變成幾個小時是有可能的。</p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="List-vs-Hash"><a href="#List-vs-Hash" class="headerlink" title="List vs Hash"></a>List vs Hash</h3><blockquote><p>List 比 Hash 快，不用計算雜湊值，直接比對更快。</p></blockquote><p>數量一大是不是要平行去找了啊，小伙子。</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="Degree-vs-Radian"><a href="#Degree-vs-Radian" class="headerlink" title="Degree vs Radian"></a>Degree vs Radian</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">rotate90</span><span class="params">(<span class="keyword">double</span> deg)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Math.toRadian(deg + <span class="number">90</span>) % <span class="number">90</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不會弧度記算沒關係，晚點我們再檢查一下還有哪一段混著算吧。希望都沒事。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="linter"><a href="#linter" class="headerlink" title="linter"></a>linter</h3><blockquote><p>不要 format code，因為 <code>git blame</code> 不好看。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line"><span class="keyword">try</span> </div><div class="line">&#123;</div><div class="line">    Data rowData = data.getRow(i);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Exception e)</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>心靜自然涼，再多的 try-catch 我也可以接受。沒事，我不會受到傷害。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="Set-Env-Variable"><a href="#Set-Env-Variable" class="headerlink" title="Set Env Variable"></a>Set Env Variable</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 我的電腦 &gt; 內容 &gt; 進階內容設定 &gt; 環境變數</div><div class="line">2. 重新開機 // ?????</div></pre></td></tr></table></figure><p>在大部分情況是不用重新開機，重新開啟 shell 即可。</p><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="Build-Artifacts"><a href="#Build-Artifacts" class="headerlink" title="Build Artifacts"></a>Build Artifacts</h3><blockquote><p>每一次建置結果都保存下來，用定時刪除。</p></blockquote><p>大部分的建置結果只需要保留進 25 次就差不多，如果每一次建置就要耗掉 1 GB 的硬碟空間，那在一天內上傳了好幾次，就會看到 1 TB 硬碟直接死去。</p><p>請不要說買硬碟解決問題，這並沒有解決根本問題。</p><h3 id="Build-Pipeline"><a href="#Build-Pipeline" class="headerlink" title="Build Pipeline"></a>Build Pipeline</h3><blockquote><p>充分運用硬體資源，全部平行。</p></blockquote><p>有些工作是需要整台伺服器的計算資源，如果安排兩個以上的工作時，會造成另一個工作結果不穩定。而有些工作會需要大量的硬碟 IO，兩個以上甚至會造成卡死的狀態。</p><p>請不要說買更多的機器或 CPU 解決問題，這只要開一個有平行工作，另一個工作沒設計好就會自動失敗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-C&quot;&gt;&lt;a href=&quot;#C-C&quot; class=&quot;headerlink&quot; title=&quot;C/C++&quot;&gt;&lt;/a&gt;C/C++&lt;/h2&gt;&lt;h3 id=&quot;Overprotection&quot;&gt;&lt;a href=&quot;#Overprotection&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="鬼故事" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
    
      <category term="鬼故事" scheme="http://morris821028.github.io/tags/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Company Ghost Story 公司鬼故事 1</title>
    <link href="http://morris821028.github.io/2020/09/13/work/company-ghost-story-1/"/>
    <id>http://morris821028.github.io/2020/09/13/work/company-ghost-story-1/</id>
    <published>2020-09-13T05:00:00.000Z</published>
    <updated>2020-09-13T05:27:22.227Z</updated>
    
    <content type="html"><![CDATA[<p>以下出現的問題，都是在公司遇到的事件，以類比的方式來描述遇到的狀況。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Unique"><a href="#Unique" class="headerlink" title="Unique"></a>Unique</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbObj</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.compareTo((DbObj) obj) == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>對於唯一存在的物件，別用 <code>compareTo()</code> 來實作 <code>equals()</code>，它們可以直接用 <code>==</code> 判定。而且大部分的 <code>compareTo</code> 是比較慢的線性實作。如下述的物件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;...&#125;; <span class="comment">// possible O(n)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>結果就是變得超慢。</p><h3 id="toString-in-Comparison"><a href="#toString-in-Comparison" class="headerlink" title="toString in Comparison"></a><code>toString</code> in Comparison</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeClass</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">CompositeClass</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(CompositeClass other)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> toString().compareTo(other.toString()); <span class="comment">// ???????</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>千萬別這麼幹，當我們對類別增加成員時，同時修改 <code>toString()</code> 後，運行結果也不同。這也會帶來嚴重的效能問題，試想著排序的時候，產生一大堆的字串用於比較，那麼垃圾回收就會佔有大部分的時間。</p><h3 id="toString-in-Key"><a href="#toString-in-Key" class="headerlink" title="toString() in Key"></a><code>toString()</code> in Key</h3><p>當需要對 <code>enum</code> 或者其他相關物件進行反序列時，避開 <code>toString()</code>，因為這個函數很容易被其他人覆寫。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> SomeType &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"..."</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SomeType.valueOf(type.toString()); <span class="comment">// ?????</span></div></pre></td></tr></table></figure><p>有人會說這個函數不該被覆寫，但能操作就可能出事。</p><h3 id="It-is-not-in-C"><a href="#It-is-not-in-C" class="headerlink" title="It is not in C++"></a>It is not in C++</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">sameLocation</span><span class="params">(Point a, Point b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a == b; <span class="comment">// ?????, Objects.equals(a, b)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>抱歉，您使用的是 Java，並沒有 <code>operator==</code> 的語法，所有的 <code>==</code> 都是比較相同物件，並不會實作對應的 <code>equals()</code>。</p><h3 id="Numeric-Comparison"><a href="#Numeric-Comparison" class="headerlink" title="Numeric Comparison"></a>Numeric Comparison</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;Point&gt; compareX =</div><div class="line">    (a, b) -&gt; a.getX() - b.getX(); <span class="comment">// X, Long.compare(a.getX(), b.getX());</span></div></pre></td></tr></table></figure><p>這種容易發生 overflow/underflow 的寫法，並不建議模仿 C/C++ 的習慣，請多用內建的函數比較。</p><h3 id="this-in-Constructor"><a href="#this-in-Constructor" class="headerlink" title="this in Constructor"></a><code>this</code> in Constructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Point &#123;</div><div class="line">    Point(<span class="keyword">long</span> x, <span class="keyword">long</span> y) &#123;</div><div class="line">       mX = x;</div><div class="line">       mY = y;</div><div class="line">    &#125;</div><div class="line">    Point() &#123;</div><div class="line">       mX = <span class="number">0</span>; <span class="comment">// X, this(0, 0);</span></div><div class="line">       mY = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>請盡量使用建構子，各自獨立容易漏掉一些共同的檢查。</p><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">Point <span class="title">copy</span><span class="params">()</span> </span>&#123;</div><div class="line">    Point pt = <span class="keyword">new</span> Point();</div><div class="line">    pt.setX(getX());</div><div class="line">    pt.setY(getY());</div><div class="line">    <span class="keyword">return</span> pt; <span class="comment">// new Point(getX(), getY());</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>能使用建構子完成的事情就盡量使用，分次使用可能會造成過多額外的檢查或調整，效能就會往下掉。</p><h3 id="Find-the-Minimum-Maximum-Element"><a href="#Find-the-Minimum-Maximum-Element" class="headerlink" title="Find the Minimum/Maximum Element"></a>Find the Minimum/Maximum Element</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">Point <span class="title">getMax</span><span class="params">(List&lt;Point&gt; testList)</span> </span>&#123;</div><div class="line">    Collections.sort(testList);</div><div class="line">    <span class="keyword">return</span> testList.get(testList.size() - <span class="number">1</span>); <span class="comment">// Collections.max(testList);</span></div><div class="line">&#125;</div><div class="line"><span class="function">Point <span class="title">getMin</span><span class="params">(List&lt;Point&gt; testList)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> testList.stream().sorted().getFirst().orElse(<span class="keyword">null</span>);</div><div class="line">    <span class="comment">// testList.stream().min().orElse(null);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>排序很簡單，但也不能亂寫。</p><p>排序複雜度大部分為 $O(n \log n)$，事實上找最小值只需要 $O(n)$。當 <span>$n = 10^6$</span><!-- Has MathJax --> 時，效率就可能差到 20 倍。</p><h3 id="Computed-Getter"><a href="#Computed-Getter" class="headerlink" title="Computed Getter"></a>Computed Getter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;CPoint&gt; compateLocation = </div><div class="line"> (CPoint ca, CPoint cb) -&gt; &#123;</div><div class="line">     <span class="keyword">long</span> p0x = ca.getCPt().getX();</div><div class="line">     <span class="keyword">long</span> p1x = cb.getCPt().getX();</div><div class="line">     <span class="keyword">long</span> p0y = ca.getCPt().getY();</div><div class="line">     <span class="keyword">long</span> p1y = cb.getCPt().getY();</div><div class="line">     ... <span class="comment">// X, return ca.getCPt().compareTo(cb.getCPt());</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>請不要這麼寫，排版好看行數很多並不是好藉口，這呼叫了好幾次 <code>getCPt()</code>，如果牽涉到好幾步複雜運算，整個效率就慢上了好幾倍。</p><h3 id="Computed-If-Else"><a href="#Computed-If-Else" class="headerlink" title="Computed If-Else"></a>Computed If-Else</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (getA() != <span class="keyword">null</span> &amp;&amp;</div><div class="line">    getA().getB() != <span class="keyword">null</span> &amp;&amp;</div><div class="line">    getA().getB().getC() != <span class="keyword">null</span>) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>寫在同一個 if-statement 很方便，卻造成效能嚴重退化。不如蠢一點的寫法，或者透過 <code>Optional&lt;&gt;</code> 來描述回傳型態。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A a = getA();</div><div class="line"><span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</div><div class="line">    B b = a.getB();</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">getA().ifPresent(a -&gt; &#123;</div><div class="line">    a.getB().ifPresent(...)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="List-Getter"><a href="#List-Getter" class="headerlink" title="List Getter"></a>List Getter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LinkedList&lt;Long&gt; X;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(List&lt;Long&gt; X)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X.size(); i++) &#123;</div><div class="line">        <span class="keyword">long</span> x = X.get(i);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>別鬧了，這會出大事。效能殺手就是你。<code>LinkedList</code> 的 <code>get(index)</code> 可是 $O(n)$ 的。</p><h3 id="Immutable-Methods"><a href="#Immutable-Methods" class="headerlink" title="Immutable Methods"></a>Immutable Methods</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse</span><span class="params">(String elem)</span> </span>&#123;</div><div class="line">    elem.trim(); <span class="comment">// ??????, elem = elem.trim();</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>記得把回傳值接起來，請不要陡增效能問題。</p><h3 id="Method-Reference"><a href="#Method-Reference" class="headerlink" title="Method Reference"></a>Method Reference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Map&lt;Long, List&lt;Point&gt;&gt; map;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Point a)</span> </span>&#123;</div><div class="line">    List&lt;Point&gt; list =</div><div class="line">        map.computeIfAbsent(a.mX, key -&gt; <span class="keyword">new</span> LinkedList&lt;&gt;()); <span class="comment">// X, Point::prepare</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> List&lt;Point&gt; <span class="title">prepare</span><span class="params">(Long key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>盡量使用 method reference，防止 memory leak，也降低 lambda metafactory desugar 的花費。</p><h3 id="Boxing"><a href="#Boxing" class="headerlink" title="Boxing"></a>Boxing</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Double <span class="title">getRotate</span><span class="params">()</span> </span>&#123; <span class="comment">// X, double</span></div><div class="line">    <span class="keyword">double</span> r = ...;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getMirror</span><span class="params">()</span> </span>&#123;...&#125;;</div><div class="line">Boolean isMirror = getMirror(); <span class="comment">// X, boolean</span></div></pre></td></tr></table></figure><p>既然有預設值也確保不會發生 <code>null</code>，請不要過度包裝。拆拆裝裝的狀況會造成垃圾過多。</p><h3 id="Exception-is-NOT-a-Return-Value"><a href="#Exception-is-NOT-a-Return-Value" class="headerlink" title="Exception is NOT a Return Value"></a>Exception is NOT a Return Value</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFileExt</span><span class="params">(File f)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        String token = parseExt(f);</div><div class="line">        <span class="keyword">return</span> <span class="string">"."</span> + token;</div><div class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>請別接收這麼奇怪的 runtime exception。在 Java 中，exception 很昂貴的，造價就是整個 call stack。</p><p>也別這樣追蹤物件的建立，大量物件會造成內存不足。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Throwable trace = <span class="keyword">new</span> Throwable();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Lightweight-Exit"><a href="#Lightweight-Exit" class="headerlink" title="Lightweight Exit"></a>Lightweight Exit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Point p)</span> </span>&#123;</div><div class="line">   List&lt;Long&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10000</span>); <span class="comment">// ?????</span></div><div class="line">   <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>別急著建立一堆用不著垃圾，有可能在後續判斷中直接返回。盡量縮小變數的生命週期，快用到的時候再準備計算資源。</p><h3 id="If-Elif-Else"><a href="#If-Elif-Else" class="headerlink" title="If-Elif-Else"></a>If-Elif-Else</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (token.equals(<span class="string">"a"</span>))</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"b"</span>))</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (token.equals(<span class="string">"c"</span>))</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>別說排版不重要，那一定是沒看過有人不小心漏了什麼。在大部分情況不太會出事，只是多判斷了幾次造成效能退化。</p><h3 id="Dead-instanceof"><a href="#Dead-instanceof" class="headerlink" title="Dead instanceof"></a>Dead <code>instanceof</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poly</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Poly</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(Shape shape)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Poly) &#123;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Rect) &#123;</div><div class="line">      <span class="comment">// ?????, unsearchable</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>凡事有先後，請注意繼承關係。</p><h3 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;ObsListener&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="keyword">private</span> Set&lt;ObsListener&gt; list = <span class="keyword">new</span> HashSet&lt;&gt;();</div></pre></td></tr></table></figure><p>當訂閱者數量不少，且容易進進出出，請不要用線性的 <code>LinkedList</code>。當你需要嚴格地再現 BUG，就不要使用不穩定順序的 <code>HashSet</code>，請使用 <code>LinkedHashSet</code> 是一種保守的選擇。</p><h3 id="Remove-Observer"><a href="#Remove-Observer" class="headerlink" title="Remove Observer"></a>Remove Observer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUI</span> <span class="keyword">extends</span> <span class="title">Dialog</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateUI</span><span class="params">()</span> </span>&#123;</div><div class="line">        db.addListener(mChangeListener);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// where is your db.removeListener</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>別忘記移除掛載到資料庫的觀察者，這樣往往覆覆操作，越來越慢真的不能怪人。</p><h3 id="Opposite-Behavior"><a href="#Opposite-Behavior" class="headerlink" title="Opposite Behavior"></a>Opposite Behavior</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">assert</span> pathA.endsWith(pathB) == </div><div class="line">       pathB.isEndOf(pathA); <span class="comment">// fail ??????</span></div></pre></td></tr></table></figure><p>英文函數命名上，操作對稱就該對稱。英文不好要先說，邏輯不好也先說一聲，大家可以幫忙的。</p><h3 id="Global-Garbage"><a href="#Global-Garbage" class="headerlink" title="Global Garbage"></a>Global Garbage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> List&lt;DbObj&gt; tmp;</div><div class="line"></div><div class="line"><span class="function">List&lt;DbObj&gt; <span class="title">getXXX</span><span class="params">()</span> </span>&#123;</div><div class="line">   tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   parallel...</div><div class="line">   <span class="keyword">return</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>別擠壓到下一個人的生存空間，要是沒有使用 <code>getXXX</code>，會看到一堆資料庫物件被卡在全區變數裡頭。</p><h3 id="Useless-Argument"><a href="#Useless-Argument" class="headerlink" title="Useless Argument"></a>Useless Argument</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(Path p)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(Path p, Object a)</span></span>; <span class="comment">// new one</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>別因為不想改動原本的，建立一個一模一樣名字的函數，而且第二個參數並沒有使用到，overloading 不是這樣子設計的。</p><h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPointCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mPoints.parallelStream().count();</div><div class="line">    <span class="comment">// return mPoints.size();</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以覺得慢，但不要總是開平行解決事情。這種計數問題，通常都有相關的方法可以呼叫。如果沒有，請聯絡相關人士。</p><h3 id="Tooltip"><a href="#Tooltip" class="headerlink" title="Tooltip"></a>Tooltip</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String tooltip = <span class="string">""</span>; <span class="comment">// should StringBuilder</span></div><div class="line"><span class="keyword">for</span> (DbObj t : db.getObjects(XXX.class))</div><div class="line">    tooltip = tooltip + t.toString();</div></pre></td></tr></table></figure><p>沒人說這樣不好，除了串接消耗 $O(n^2)$，一般也不會把所有東西拉出來。</p><h3 id="Convert-Set-to-Array"><a href="#Convert-Set-to-Array" class="headerlink" title="Convert Set to Array"></a>Convert Set to Array</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;Point&gt; <span class="title">toArray</span><span class="params">(Set&lt;Point&gt; set)</span> </span>&#123;</div><div class="line">    List&lt;Point&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (Point e : set)</div><div class="line">        arr.add(e);</div><div class="line">    <span class="keyword">return</span> arr; <span class="comment">// return new ArrayList&lt;&gt;(set);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>建構子更方便，別這麼辛苦，效能至少慢了兩倍。</p><p>演算法還是有它的極限在的，常數的確不是很重要，但是數量一大的時候，均攤造成額外操作造成的垃圾，在 Java 中會變得相當明顯。</p><h3 id="Error-Message"><a href="#Error-Message" class="headerlink" title="Error Message"></a>Error Message</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Integer <span class="title">parseInteger</span><span class="params">(String x)</span> </span>&#123;</div><div class="line">    String errMsg = x + <span class="string">"is an invalid integer format..."</span>;</div><div class="line">    errMsg = attachCurrentLineMessage(errMsg);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">       Integer n = Integer.parseInt(x);</div><div class="line">       <span class="keyword">return</span> n;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       System.err.println(errMsg);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>人家還沒出錯，先別急著準備錯誤訊息。提前準備的字串複雜度比處理的複雜度還高，這絕不允許。</p><h3 id="New-Option"><a href="#New-Option" class="headerlink" title="New Option"></a>New Option</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">import</span><span class="params">(<span class="keyword">boolean</span> a)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">import</span><span class="params">(<span class="keyword">boolean</span> a, <span class="keyword">boolean</span> b)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">import</span><span class="params">(<span class="keyword">boolean</span> a, <span class="keyword">boolean</span> b, <span class="keyword">int</span> c)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">import</span><span class="params">(<span class="keyword">boolean</span> a, <span class="keyword">boolean</span> b, <span class="keyword">int</span> c, String d)</span></span>;</div><div class="line">...</div></pre></td></tr></table></figure><p>別再為了新參數往上疊，請用更容易看出參數意義的 builder 的寫法。</p><p>越來越多的參數，造成容易寫錯傳參的順序的悲劇，這時候 BUG</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下出現的問題，都是在公司遇到的事件，以類比的方式來描述遇到的狀況。&lt;/p&gt;
&lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;&lt;h3 id=&quot;Unique&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="鬼故事" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
    
      <category term="鬼故事" scheme="http://morris821028.github.io/tags/%E9%AC%BC%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>研替三年</title>
    <link href="http://morris821028.github.io/2020/08/16/diary-202008/"/>
    <id>http://morris821028.github.io/2020/08/16/diary-202008/</id>
    <published>2020-08-16T11:16:06.000Z</published>
    <updated>2020-08-17T00:02:43.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="舊金山"><a href="#舊金山" class="headerlink" title="舊金山"></a>舊金山</h2><p>即將過年時，才知道二月底完要去趟美國舊金山開會，那時美國疫情還沒有大爆發。面對跟著主管一起出國的情況，緊張的心境已經釋懷，那時還不知有多少人會跟著去，只想著這次順便去看組織改組的同事有哪些人，並沒打算規劃順便玩什麼行程。</p><p>由於時間有點趕，只有兩周的時間準備，也不知道去的實際目的，要準備的相關報告內容，連剛進來兩個月的菜鳥也跟著去，由於不是每個人都有去，能倚靠的人不多，另一個進來快一年的學弟被邀請去，這多少有點不妙的預感。</p><p>從早開到晚為期一周的密集會議，並沒有像波士頓有個悠哉的下午。顯然地，在充滿華人組織的西岸和洋人的東岸風格不同，汲汲營營的華人文化，每一刻都相當地重要。工作起來相當辛苦，也嚴謹很多。</p><p>在聖荷西的分公司，擁有數千人的團隊，還有正統的公司餐廳？而我們人數只有個位數，開會起來明顯沒什麼說服力，高階主管們說什麼是什麼。產品大部分小功能也都幾千行，對於 EDA 的貢獻也只在規劃工具，而不是負責最實際的實作工具，說話力道與市場規模實在不大。</p><p>唯一的優勢就是近期的 3D IC 封裝，開始走向一次構築整個版子。雖然沒辦法像實作工具規劃走線細節，作為一個高層級的規劃工具可以一次展現百億個物件分布與管理，只是比 Excel 好用一些吧。</p><p>一連串開會下來，大概明白自己在組織裡面排在哪個位階，也能從一些會議主持上看出各部門的信賴、依賴圖。不得不說，公司還真的很接近三個人種分部門，分別是亞洲、印度及歐美，分別主導不同層級的產品。想必在相同母語與文化上，這樣開發才是最容易的組織發展，怪不得這次改組將大部分的人都塞進這個亞洲圈。</p><p>途中若都是亞洲人的會議，用中文開會，途中若出現外國人，就下一秒切成英文會議，在一旁觀看略有風趣，龐大的專有名詞庫，最後也搞不清楚到底是在講中文還是英文。那被抓去的另一個目的是什麼呢？應該是主管報告產品功能時，緊急救火隊在一旁修 BUG 和評估是否能支援突然拋出的問題。</p><p><img src="https://i.imgur.com/JDAY7Sc.jpg" alt="「現在我有種被狠狠背叛的感覺」－《輝夜姬想讓人告白》"></p><p>接下來的事就不有趣，菜鳥是個雷隊友的事實逐漸明瞭。回想在搭飛機前說了要留著餘額刷旅館信用卡，千萬別玩手遊刷爆，結果當晚入住時還是刷不過，原來是出發前刷了一台手機。這也許還不打緊，回旅館打算去隔壁的購物中心，幫公司同事買台 switch 回台灣，沒想到菜鳥卻回說「回房間玩手遊」正準備在大廳做簡報的主管在一旁聽到，說道「不一起去嗎？」。我想徹底的社畜就是下班不認識吧，最後一個人摸黑走去購物中心買。也許是中國疫情爆發，店員看到這一臉黃種人也沒問太多，比起害怕說英文的我，那種中國式恐懼無法比擬。</p><p>令我感到最微妙的是，開會一直補零食咖啡，看到主管們正在報告的當下，菜鳥卻三番兩次地繞到後頭拿零食回來吃，也許是不同成長背景下的關係，看起來非常低水準的行為，讓我都不好意思坐在一旁聽講。這讓我想起，在剛進來的幾個月時，主管曾說我們家教都還不錯，在這些小動作中，就能略知一二吧。</p><h2 id="在家工作"><a href="#在家工作" class="headerlink" title="在家工作"></a>在家工作</h2><p>回國時已三月初，疫情開始大爆發，之後便開始在家工作。決議內容其實多到不太可能在短時間內規劃得好，在屈指可數的開發人力下，不讓產品崩盤就很不錯，交代下來的事情，從回程飛機的等待時間，跟主管談論這次的各方面狀況，也談到為何讓菜鳥也跟著來，一次要出個十幾萬讓幾個人飛過去開會，這對公司也不容易。談論內容就留著大家自行想像。</p><p>在家工作並沒有想像中得好，完全看各位的自制力。然而，公司 IT 部門開始封鎖了許多網站，如 Youtube, Netflix … 等，發現 VPN 承受不住大量的居家工作者，可見有多少人平時上班會佔據這麼多的網路資源。由於在家工作，各種事情討論都在線上會議中。同時，由於部門改組，每周、每雙周、每月開始有固定會議，不健康的社畜生活就此展開。</p><p>越來越少去公司，忙得事情卻越來越多，周一催計畫 A、周二催計畫 B、周三開個會、周四解決緊急需求、周五做計劃。這些堪比大學修課，每天都在準備隔天的課程作業似的，單純做報告也許還好，老實說開發一個大功能並不太合適，實驗都還沒跑完整，隨口說出來也是浪費大家時間，畢竟誰也不會插手幫忙誰的，並沒有實際討論的價值，頂多出事知道要找誰。</p><p>看著每周報告的計畫項目中，開始出現了負責人指向自己，壓力大了不少。更煩躁的是，有好幾個項目旁邊都有著自己的名字。人力不足，卻必須這樣搞的話，心境相當崩潰。對於系統功能而言，也與一次負責好幾項很正常，但每周都得對項目報告進度，這個就有點分身乏術。變相結果，在每天稍微撥點時間每個都推一點進度，開始進入分時工作。有些同事並不會這樣子，負責一項慢慢推就好，怎麼說都心理不平衡。</p><h2 id="開發"><a href="#開發" class="headerlink" title="開發"></a>開發</h2><p>新功能要做，舊功能要顧、還要寫教學文件給未來菜鳥使用，不時還會因為同事寫出糟糕代碼而氣憤。每次做簡報分析要怎麼寫，看來都做了白工。在某一日，直接開幹，不得不在線上會議直接說出來，我所說的話，又有多少可信度呢？的確，我也會犯自己說過的錯誤，做了全自動的反饋系統後，照理來講定時要去修正那些潛在錯誤。然而，對於某些人而言，潛在錯誤不算錯誤，只要還沒有錯，那就是對的。</p><p>由於人力不足，工作分配上有明顯地不妥當，即便希望學著做，有不懂事情就問，但結果並非理想中的發展。不如預期就先看源代碼，自行谷歌可能得到的問題，第一個搜尋結果就是答案的蠢事不斷上演，如何編譯一個簡單的 Java 程式、如何使用 Git 分支、如何快速設定環境變數，這些瑣事拿到關鍵字先上網學習，與其不同的地方再拿出來討論。看到同事以如此沒效率的方式在工作，從繁重的工作中脫身，幫忙處理這些小事，直接氣炸了鍋。</p><p>逐漸地，發現測試時間越來越不穩定，log 輸出裡面還吐了不少問題，撰寫的教學文件的錯誤範本一度上演。大多數的問題都是基礎功，基本的語言特性、作業系統的架構、工作的運行流程等，用腦內模擬就知道有各種組合切入點。要怎麼讓大家一起提升素質呢？並沒有辦法。大部分說「我先寫，效能問題你來修。」的狀況，還會很自豪地說「這樣的合作不錯吧？」，在大家都在的場合下能講出這些話，信心十足。寫完之後我砍掉，這到底哪門子的合作方法。</p><p>為了壓制不穩定的要素，按照反饋系統的指導逐一修正，再根據歷史教訓不斷地增加測試案例來防堵再次發生，來到了 11% 代碼覆蓋率，相較於半年前提升了一倍之多。在伺服器平行測試從半小時再壓回 20 分鐘，在單機運行就得花上數個小時。平行內的平行資源管理，不要總是資源耗盡，造成誤判逾時，測試不過就跑第二次到底是什麼觀念？怎麼會把這些事情習以為常，要與幾千人的產品整合，那一點穩定度都辦不到，每次都不敢說這產品還能活多久，要是我沒去注意，沒有去做一些髒活，這早就該瓦解了。</p><p>產品整合上，外觀圖樣、操作快捷、文字顯示等等都要配合，這對於沒有產品驗證的團隊而言，整個工作落在我的身上，一一對應圖標顯示，還要保留先前的 UI 主題，又要處理跨平台的操作環境，有時還要自己開美工軟體去修圖擺放，怎麼想都不太妙，連 UI 動畫都有一些基礎需求，邊邊角角的幾個像素都要求到位，寫程式的涵蓋範圍可大呢。</p><p>因為要處理百億數量級的顯示與檢索更新，得放下新功能開發，回過頭去把問題抓回來解決，測試與分析並不是那一種試誤流程，覺得快不是總是快，當下快不代表以後快，長久的發展沒有人去支持，得花上好幾天驗證的工作，在每周開會的壓榨中，無法靜下來去思考問題。</p><h2 id="後談"><a href="#後談" class="headerlink" title="後談"></a>後談</h2><p><img src="https://i.imgur.com/rdDCpQp.jpg" alt="「啊，我已經到了極限了」－《輝夜姬想讓人告白》"></p><p>由於開發的緊迫，心情盪到谷底，想要去找找看新工作，卻被每周開會壓迫，緊急事件不斷，潛在問題不斷暴露需要調查。不幸地在七月初，摔傷了右手臂和腳，包著紗布也趕工。</p><p>八月中，受不了自己在忙什麼，找了主管談了一下發展，我再也沒辦法繼續了。家裡嫌賺得少，也沒什麼成就，連個女朋友都沒交過，每天就在那邊工作。在工作中什麼都沒有發展，依舊是那三年前的我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;舊金山&quot;&gt;&lt;a href=&quot;#舊金山&quot; class=&quot;headerlink&quot; title=&quot;舊金山&quot;&gt;&lt;/a&gt;舊金山&lt;/h2&gt;&lt;p&gt;即將過年時，才知道二月底完要去趟美國舊金山開會，那時美國疫情還沒有大爆發。面對跟著主管一起出國的情況，緊張的心境已經釋懷，那時還不知
      
    
    </summary>
    
      <category term="手札日記" scheme="http://morris821028.github.io/categories/%E6%89%8B%E6%9C%AD%E6%97%A5%E8%A8%98/"/>
    
    
  </entry>
  
  <entry>
    <title>糾纏與糾結</title>
    <link href="http://morris821028.github.io/2020/01/06/diary-202001/"/>
    <id>http://morris821028.github.io/2020/01/06/diary-202001/</id>
    <published>2020-01-06T07:23:53.000Z</published>
    <updated>2020-01-06T12:16:33.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>距離上一次編寫日記到現在已過五個月，累積著不同的經歷與感受，才能寫出一篇有所不同的日記。然而，工作後每天回寢室不是睡覺就是打個遊戲，周末也沒特別想做什麼，完全地放空就是最好的休閒，這使得寫一篇文章又變得更加困難。一成不變的煩惱，到底能寫些什麼。</p><h3 id="單元測試"><a href="#單元測試" class="headerlink" title="單元測試"></a>單元測試</h3><p>這幾個月來，總算把單元測試拉了起來，從原本代碼覆蓋率 1% 拉到 6%，測試數量十幾拉到四百多個，這過程最痛苦的就是慢慢將所有代碼重新審視，就會開始發現一堆函數不同名稱卻功能相似，甚至是子集合的概念。有人會說「至少沒錯啊，你改那個做什麼」。的確，只是重複的代碼多了一點，但後續的維護就非常痛苦，一旦這重複的代碼中出了 BUG，我們花了九牛二虎之力修了它，卻發現到處都有，這時候心裡不鬱悶嗎？</p><p><img src="https://i.imgur.com/MNJEmSE.jpg" alt="「感覺超沮喪的」－《這個勇者明明超TUEEE卻過度謹慎》"></p><p>程式碼多寡會影響效能嗎？大部分的情況並不會，但是對於 Java 的 JIT 而言，跑越多次的代碼它就會更進一步地優化，把沒有用處的代碼移除，做到跟 GCC O2 的效果類似。這其中最困難的處理操作為另一個函數的子集，大部分的情況下，直接導向到另一個函數是沒有問題的，例外是時間複雜度增加與例外處理的不同，為了處理更複雜的情況，功能越強的函數通常都會有一些額外的邊際效應 (side effect)，這時候就要非常小心。</p><p>於是每天就是把上千行代碼、數百條函數裝進腦子裡，然後攪一攪把相同功能的代碼移除。好比，判斷一個圖是否同構，這基本上已經接近 NP-Complete 問題，一下子腦子運轉就會過熱，無法去思考其他的項目。有些人的腦子的確可以完全阻隔思考吧，但是對我來說，潛意識帶動的壓迫卻是無盡的痛苦。</p><p><img src="https://i.imgur.com/4U63dKp.jpg" alt="《這個勇者明明超TUEEE卻過度謹慎》"></p><p>做這一些很無趣，出於使命必須審視它，不然每次呼叫函數都不確定自己在處理什麼，甚至傳錯了組態也不會噴任何錯誤。於是開始加起了無數的防火牆，各種防禦性編程的代碼。果真還有不少代碼使用錯了，造成永遠拿到錯誤的結果，那問題就擴散出去，於是又針對相關函數進行修改，連帶回歸測試都要更新，工程浩大卻沒有產出。</p><p><img src="https://i.imgur.com/2mHyJfe.jpg" alt="《這個勇者明明超TUEEE卻過度謹慎》"></p><p>這過程發現一些無理的要求，發現自己努力了好幾個月，依然會有人亂加函數，要解決問題，果然還是要拔除源頭。傳了個完全不到的參數，還特地做了重載 (overloading)，此時心裡就納悶了，這傢伙到底是怎麼想的？「因為原先的代碼我不敢改，但是為了效能我複製了一份，又怕自己忘記於是弄了相同的函數名稱 …」這樣子我有點明白了，永遠不該去用常理去看待問題，問題就是那些思維上的漏洞。</p><p>架設了 SonarQube 這一類的代碼品質監控後，上千個 bug、vulnerability 和數萬的 code smell，這幾個月終於把前者壓到三位數，目標是控制在一百內。在這五十萬行的裡，多半程式根本不會用到，也不會讓使用者觸及到。那修到底有什麼動力嗎？只有一個，因為初學者會複製類似的行為，做出一樣的蠢事。</p><p>公司在美國那裡的新成員，開始寫的時候總會搞不清楚 Java 的特性，就像從 C++ 跳過來的孩子，常常會忘東忘西地，不斷地複製類似的代碼片段來做事，就像字串常量常常會到處冒出來，實際上這些常量如果會一起變動，就應該用一個變數去取代之，這也方便我們去追蹤使用情況。實際的結果不是，造成了無數問題，升級版本的時候，常量到處找，耗費工時又一堆 bug 有待追蹤。</p><h3 id="資料庫"><a href="#資料庫" class="headerlink" title="資料庫"></a>資料庫</h3><p>因為製程的進展，大廠開始要求效能，來解決上億物件的資料庫問題，物件存取速度要快，開檔存檔都要更進一步加速。於是又開始放下那些代碼的修正，跑回去研讀資料庫相關的處理，由於 EDA 工具總是自己刻一個資料庫，方便規則的變化以及升降版本之間的問題，更提供鬆散的客製化需求，相當於要求自己刻一個嚴謹的資料庫介面。</p><p>除了資料庫的基本理論，還有牽涉到開檔讀檔這種小眾知識，解壓縮與壓縮的效能，在每一個階段的每一種算法中追求內存用量最少，額外宣告變數量最少，盡可能使用位址定位等等，每一步都要精準到位，當處理數量破億時，問題就會放大得相當嚴重。就像原本內存 50 GB 可以開起來，修改完卻變成 100 GB 才能使用，這種算法常數的影響就很嚴重，這些問題甚至不是整體的結果，而是處理的過程。也就是說，甚至要最小化中間過程，否則造成某個時間點是達不到運行需求。最後，記憶體用量少一半，存取速度快兩倍之多。</p><p>在這過程中，見識到了各種邪門歪道的升降版本的修正技術，這也造成了無數相依性問題。例如在這個時間點，你所請求的物件並未存在，實際上這段代碼毫無作用，卻也活了無數年，沒有人測試過它，看起來又相當合理。陸陸續續地將這些問題分析與移除，有時不小心修正了，激活了無數功能，卻要花時間更新好幾條的回歸測試。</p><p>資料庫接口的重要性影響著整個軟體的效能與穩定性，有時會有人受不了效能而開啟平行計算，那首先的問題是「<strong>為什麼會慢？</strong>」，並不是單純地「因為慢，所以開平行。」一旦開平行下去，有些問題可能不是真的問題，因為 GC 在平行情況下，遮掩著你對剖析器 (profiler) 的觀感，因為整個停頓點如果偏移一點，就會造成優化的方向都不對。</p><p>這麼說也許是理論派吧，信者恆信。因為能解決問題的方法，總是把原先的解法全部砍掉重做，要拿這些說服別人的確是難上加難，這裡也許該相信未來會解決吧，總有一個人會跳出來滅了這個火，也許是像神一般的編譯器、或者是 AI 可以幫你除錯並修改，就不再提及了這些公司鬼故事。</p><p><img src="https://i.imgur.com/90JSK2I.jpg" alt="「我已經沒有什麼可以失去的」－《BEASTARS》]"></p><h2 id="周末"><a href="#周末" class="headerlink" title="周末"></a>周末</h2><p>其實已經沒小夥伴在玩楓之谷，身邊認識的人也不會玩這種遊戲，大多都是課金到滿的手機遊戲或者單機遊戲。逐漸地，也不是很想玩遊戲，王沒課金也打不贏，花時間也無法達到那個境界，跟團又要看別人臉色和時間。玩遊戲各路牛馬鬼神的人都有，跟不同文化背景的人打交道相當不容易。</p><p>最後，我仍選擇了淡出，周末坐在電腦桌前，開著麥克風，要講著自己不太喜歡的詞，看著那無法理解的笑點，時間久了喉嚨不好受。每天上線，還會有一些不雅遊戲暱稱的人騷擾，不知道是吃飽閒著還怎麼的，難道就這麼有趣嗎？即使封鎖拉黑都沒有，這樣的情況持續一個多月，嘗試去找兇手，卻總是沒有任何音訊。</p><p>奇怪的是，總能挑到上線的時候發出訊息，非常高的機率是相關人士。後來有一天，群組還是透露了他們其實都知道是誰搞得，還給出了一堆提示後，仍然不願意告訴我那個混蛋是誰。這樣的狀況仍持續了幾周，依舊只說了「如果要答案的話，下一次線下聚會就跟你說。」，這種說詞，徹底讓我貫穿了所有雲雨。</p><p>明知答案為何，卻老是不願意透露。這讓我想到寫了幾千題的過程中，遇過一些人也採用類似的策略，終究也沒辦法從之獲得什麼，那一種糾結始終在我心裡迴盪。有一天，我突然想到自己那種快樂遊玩的感覺沒了，都是在過程中想辦法找到玩下去的理由，開始剝離原先的群組，也不需要什麼理由，我累了，在尋找那簡單快樂的旅途中累了。</p><p><img src="https://i.imgur.com/YwRTjUM.jpg" alt="「我果然是累了吧」－《這個勇者明明超TUEEE卻過度謹慎》"></p><p>接下來的幾周，逐漸地縮短遊戲時間，開始想了當初一些還沒做好的事情，整理一些瑣事，跑了一些實驗驗證算法。在房裡發呆也好，不跟人說話也罷，那一種重新探求的感覺，心想還可以持續多久？</p><p>年底的最後幾周，拾起了論文，開著 sci-hub 下載論文來看，嘗試解決當年規劃的藍圖，藍圖都還沒做好，卻發現了工作上更多的問題，甚至還找到了原生 JDK bug，這也解釋了為什麼老是愛開平行解決事情，這都還只是附加產物。印出了一疊論文在公司裡放著，稍微有空閒的時候看。</p><p>如果能解決根本問題，不需要研究論文的話，其實也不用這麼痛苦地看論文。若在公司要分享論文知識，或者請求別人一起努力什麼的，這是不太可能的。曾經與同事這麼說道「這個問題很難，總是要有人去犧牲、去解決的，看論文也是這個原因」，得到的回應卻是「那你去犧牲吧」。也許，不經意的一句話才是現實的<strong>真相</strong>。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p><img src="https://i.imgur.com/jNnKsyt.jpg" alt="「不過我的生活方式」－《BEASTARS》"></p><p>沒有。</p><p>這些日子研究了一些持久化結構，但我的生活卻不會這麼地持久。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h2&gt;&lt;p&gt;距離上一次編寫日記到現在已過五個月，累積著不同的經歷與感受，才能寫出一篇有所不同的日記。然而，工作後每天回寢室不是睡覺就是打個遊戲，周末也沒
      
    
    </summary>
    
      <category term="手札日記" scheme="http://morris821028.github.io/categories/%E6%89%8B%E6%9C%AD%E6%97%A5%E8%A8%98/"/>
    
    
  </entry>
  
  <entry>
    <title>可持久化陣列 Persistent Array 始</title>
    <link href="http://morris821028.github.io/2020/01/06/mproblem-persistent-array/"/>
    <id>http://morris821028.github.io/2020/01/06/mproblem-persistent-array/</id>
    <published>2020-01-05T23:26:10.000Z</published>
    <updated>2020-01-06T02:30:30.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顧"><a href="#回顧" class="headerlink" title="回顧"></a>回顧</h2><p>幾年前，跟 liouzhou101 一起搞了很多記憶中系列題目，有一題與陣列很相似，但操作更複雜一些。陣列的操作只有下列幾種</p><ul><li><code>get(index)</code>: 回傳索引為 index 的元素，其中 <span>$\text{index} \in \left [0, n-1 \right ]$</span><!-- Has MathJax --></li><li><code>set(index, value)</code>: 修改 index 上的元素</li><li><code>pushBack(value)</code>: 陣列尾端後接一個新的元素</li><li><code>popBack()</code>: 移除陣列尾端的最後一個元素</li></ul><p>從演算法課程中，我們學到 C++ 中的 <code>std::vector</code> 可以做到均攤 <span>$\mathcal{O}(1)$</span><!-- Has MathJax -->，其大致的做法為陣列快填滿容量時，倍增其大小後轉移原先的所有元素到新的容器上，均攤計算為每次增加的元素都需要預先支付未來轉移自己、轉移對應的另一個元素、移除自己、移除對應的另一個元素的花費，因此均攤花費為常數。</p><p>而這樣子的均攤操作在可持久化卻是不利的，因為單一操作的最慘複雜度為 <span>$\mathcal{O}(n)$</span><!-- Has MathJax -->，意味著可能在同一個操作上，使用 <span>$m$</span><!-- Has MathJax --> 次持久化會造成時間複雜度退化成 <span>$\mathcal{O}(mn)$</span><!-- Has MathJax -->。因此，我們需要最小化最慘時間複雜度的結構。</p><p>當年初學者的我，切入觀點有二元樹 (binary tree)、塊狀表 (unrolled linked list)，前者讓操作必為 <span>$\mathcal{\Theta}(\log n)$</span><!-- Has MathJax -->、後者為 <span>$\mathcal{\Theta}(\sqrt{n})$</span><!-- Has MathJax -->，從理論分析上一定優先選擇前者實作，但如果操作有特別的比例問題，如 <code>get(index)</code>、<code>pushBack()</code> … 等，這時候快取能力好的塊狀表反而有優勢，二元樹因指標的使用導致整體的內存使用率不高，透過 2-3 tree 那一種將節點儲存多個元素的設計，就相當於把塊狀表拉成樹狀，其效果也不錯，但在計算上會更需要耗費工夫。</p><h2 id="塊狀表-Unrolled-Linked-List"><a href="#塊狀表-Unrolled-Linked-List" class="headerlink" title="塊狀表 (Unrolled Linked List)"></a>塊狀表 (Unrolled Linked List)</h2><p>任何操作皆為 <span>$\mathcal{\Theta}(\sqrt{n})$</span><!-- Has MathJax -->，修改操作皆需要複製整個節點。在可持久化情況時，預先每一個塊的大小較為不可行，故做不到動態調整塊狀大小。</p><h2 id="二元樹-Binary-Tree"><a href="#二元樹-Binary-Tree" class="headerlink" title="二元樹 (Binary Tree)"></a>二元樹 (Binary Tree)</h2><p>利用二元樹建立可持久化的情況有很多種編碼，以及紀錄節點的優化方式，這將會影響到我們的效率。盡可能地不在節點中儲存欄位 <code>size</code> 即可達到索引。若二元樹節點定義為</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    Node *lson;</div><div class="line">    Node *rson;</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line">    T value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>葉與內部節點皆帶有元素值，那麼在陣列的新增刪除尾端的操作，我們可以透過類似 heap 的方式，將其設計成不用旋轉操作、不用紀錄樹大小的編碼。當節點編碼為 <span>$k$</span><!-- Has MathJax -->，則兩個子節點 <span>$2k$</span><!-- Has MathJax --> 和 <span>$2k+1$</span><!-- Has MathJax -->，實作時只需要紀錄整體大小，接著在走訪過程中，採用位元運算得到其子樹大小作為操作依據。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      1</div><div class="line">     / \</div><div class="line">    2   3</div><div class="line">   / \ / \</div><div class="line">  4  5 6 7</div><div class="line"> /</div><div class="line">8</div></pre></td></tr></table></figure><p>這樣的編碼問題，對於陣列實作時，發現 <code>push/set(index, value)</code> 時，時間複雜度為 <span>$\mathcal{\Theta}(\log \text{index})$</span><!-- Has MathJax -->，那動態將 <span>$n$</span><!-- Has MathJax --> 個元素推入的時間必為 <span>$\mathcal{\Theta}(n \log n)$</span><!-- Has MathJax -->，靜態建造則為 <span>$\mathcal{\Theta}(n)$</span><!-- Has MathJax -->。索引值越大的元素，其操作花費越高。</p><p>設計函數庫時，我們通常希望盡可能地讓複雜度對稱，也就是兩端的索引速度不會差太多，即使是亂數也好，因為演算法設計、真實生活中的應用大多都會偏向一方，很可能總是觸發最慘情況。</p><h3 id="Braun-Tree"><a href="#Braun-Tree" class="headerlink" title="Braun Tree"></a>Braun Tree</h3><p>另一種編碼設計，對於每一個節點皆滿足右子樹大小最多比左子樹大小多一個，由於每一個節點都滿足，按照插入順序，可以得到下圖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          1</div><div class="line">     2         3</div><div class="line"> 4     6    5     7</div><div class="line">8 10 12 14 9 11 13 15</div></pre></td></tr></table></figure><p>明顯地，如同霍夫曼編碼一樣，這一個 1-indexed 的情況，最低位 0 則往左子樹、反之為右子樹。每一個操作皆為對稱的，但複雜度如同一般的二元搜尋樹，作為陣列操作也不滿足期待。</p><p>若用於可持久化陣列的基底，代碼量非常少，遞迴定義使得操作簡單，我們甚至可以連整體大小都不用儲存，透過其遞迴定義可在 <span>$\mathcal{O}(\log^2 n)$</span><!-- Has MathJax --> 得到，但大部分陣列使用都是會希望 <code>A.size()</code> 是可以在 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 完成的。這樣的設計在優先隊列 (priority queue) 更友善，因為鮮少需要去拿到 <code>size</code>，只需要回傳這個優先隊列是否為空。</p><p>同樣地，這依舊不是實作可持久化陣列的首選。</p><h2 id="線段樹-Segment-Tree"><a href="#線段樹-Segment-Tree" class="headerlink" title="線段樹 (Segment Tree)"></a>線段樹 (Segment Tree)</h2><p>線段樹的設計有一個缺點，大部分的情況總是預先知道大小，然後再代入修改操作。</p><p>如果要做到動態的增加大小，則採用 top-down 的展開節點方法。如根節點一開始設計範圍為 <span>$\left [0, 2^{32} \right ]$</span><!-- Has MathJax -->，當我們 push 一個新的元素至尾端時，相當於開出一個葉節點為 <code>index = size</code>，同理 pop 操作。一開始預設最大上限 <span>$M$</span><!-- Has MathJax -->，單一操作的時間複雜度必為 <span>$\mathcal{\Theta}(\log M)$</span><!-- Has MathJax -->。</p><p>以上述的狀況，每一次操作複雜度必為 <span>$32$</span><!-- Has MathJax -->，作為函數庫的設計而言，這樣的寫法沒有彈性，而且要是未來超出指定大小，修改就非常的緩慢，更因為在持久化的環境下，不可能在對數時間內轉移其架構。</p><h2 id="Leftist-Leaf-Tree"><a href="#Leftist-Leaf-Tree" class="headerlink" title="Leftist Leaf Tree"></a>Leftist Leaf Tree</h2><p>其概念類似二項堆積 (binomial heap)，我們將使用 <span>$\log n$</span><!-- Has MathJax --> 棵樹表示整個序列。將內容放置於葉節點上，並且每一個樹皆為完美樹，無須額外紀錄子樹大小。</p><p>例如：當 <code>n = dec(11) = bin(1011)</code> 時，用三棵大小分別為 8, 2, 1 的樹表示之。當 push 一個新的元素至尾端時，與最右邊的子樹 1 合併成大小為 2 的樹，再與左邊的子樹合併成大小為 4 的子樹，最後成為 <code>n&#39; = dec(12) = bin(1100)</code>，用兩棵子樹表示之。同理 pop 操作，模擬二進制的退位。</p><p>每一個操作皆為 <span>$\mathcal{O}(\log n)$</span><!-- Has MathJax -->，且分布較為一般的二元樹均勻。並解決一開始我們在二元樹上遇到的問題，<strong>動態將 <span>$n$</span><!-- Has MathJax --> 個元素推入的時間</strong>，整體複雜度為 <span>$\mathcal{\Theta}(n)$</span><!-- Has MathJax -->。因此，這是目前實作可持久化隊列的首選。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>函數式理論複雜度最好的結構為 finger tree，實作複雜度相當高，卻具備了合併兩個陣列的特殊操作，這是以上結構皆不具有操作。實際的效能無法預測，通常常數過大而無法使用。有朝一日，我們再來挑戰這偉大的結構吧。</p><h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回顧&quot;&gt;&lt;a href=&quot;#回顧&quot; class=&quot;headerlink&quot; title=&quot;回顧&quot;&gt;&lt;/a&gt;回顧&lt;/h2&gt;&lt;p&gt;幾年前，跟 liouzhou101 一起搞了很多記憶中系列題目，有一題與陣列很相似，但操作更複雜一些。陣列的操作只有下列幾種&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="可持久化" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
      <category term="可持久化" scheme="http://morris821028.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="陣列" scheme="http://morris821028.github.io/tags/%E9%99%A3%E5%88%97/"/>
    
      <category term="array" scheme="http://morris821028.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>可持久化應用雜談</title>
    <link href="http://morris821028.github.io/2020/01/05/work/persistent-motivation/"/>
    <id>http://morris821028.github.io/2020/01/05/work/persistent-motivation/</id>
    <published>2020-01-05T12:00:00.000Z</published>
    <updated>2020-09-13T05:27:20.670Z</updated>
    
    <content type="html"><![CDATA[<p>可持久化的實際用途到底有哪些？這麼複雜的概念大部分場景都用不上？</p><h2 id="函數式編程"><a href="#函數式編程" class="headerlink" title="函數式編程"></a>函數式編程</h2><p>其不可變的需求，造就了持久化的使用。如果是可變的特性，函數式展開的一對多操作時，就會造成操作失效，除蟲大概是一輩子的痛。以 Java 的 Stream 為例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">paths.stream()</div><div class="line">     .flatMap(path -&gt; &#123;</div><div class="line">         <span class="keyword">return</span> Stream.of(path.add(a), path.add(b));</div><div class="line">      &#125;);</div></pre></td></tr></table></figure><p>這樣的函數還算清晰好懂，一旦包了好幾層函數下去，就不曉得 path 到底是能不能被修改。如果不可被修改，意味著每一次都要回傳一個實例，那麼可想而知效能一定不會太高 (大部分的代碼都是整個數據複製)。別去想什麼黑魔法可以在常數時間解決、相信未來人可以穿越時空幫你完成即時計算。請面對現實，計算機終究還是一行一行去執行的。</p><p>在編程概念的分支中，函數式編程本身需要這一種技術，達到其函數定義的規範。這一種寫法的效能不好，能理解的人也不多，其一原因學校沒有強制要求去學，一開始都是從程序式、命令式、物件導向式著手居多，所以到工作階段也不太可能遇到大型程式的需求，不過一旦遇到就無可取代。</p><h2 id="離線算法"><a href="#離線算法" class="headerlink" title="離線算法"></a>離線算法</h2><p>將離線版本切換成強制在線，不用特別去構造一個全新的資料結構來解決問題，只需要預處理一部份的資料，並犧牲更多的記憶體空間來完成。</p><h3 id="幾何計算"><a href="#幾何計算" class="headerlink" title="幾何計算"></a>幾何計算</h3><p>在幾何計算中，有很多離線算法很容易被找到，一個掃描線掃過去回答所有問題，在時間複雜度分析上總是相當優異的。那如何強迫在線的情況下，每一次都掃描一次，詢問操作的時間複雜度就從對數時間降成線性。為了解決這一種情況，持久化技術給了另一種思維，我們將掃描線的時間軸作為一個變動依據，持久化相關的結構，只要我們能將詢問在對數時間內穿梭於這個時間軸，必能動態解決先前的問題。</p><ul><li>參考資料 <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2005/lecture-notes/persistent.pdf" target="_blank" rel="external">MIT 6.854  Advanced  Algorithms - Persistent Data Structures Notes</a></li></ul><h2 id="統計方法"><a href="#統計方法" class="headerlink" title="統計方法"></a>統計方法</h2><p>在 OI 界的經典問題，區間 K 大、攤平成一維陣列的相關計算，問題本身不帶修改操作，只詢問統計於此的統計操作。通常可以透過持久化結構來完成，區間就相當於時間軸，我們能針對兩個時間戳記之間的差異變化來完成統計。</p><h2 id="字串處理"><a href="#字串處理" class="headerlink" title="字串處理"></a>字串處理</h2><p>為了達到非常高效率的合併操作，防止大量重複性字串的生成伴隨的效能退化，使得各方面的操作都能遠低於線性操作。如 C++ rope 就是一個持久化的資料結構，</p><p>不只是字串操作，若處理類型有大量重複的情況，持久化的概念便能派上用場。</p><h2 id="版本回溯"><a href="#版本回溯" class="headerlink" title="版本回溯"></a>版本回溯</h2><p>實際上就是對應大部分的應用軟體中的 redo/undo。如果資料庫/操作變動為了高效率操作而會配上複雜的結構 (並不像 hash, set 反轉操作只需要常數或對數時間)，那麼為了快速回推變動結果，持久化結構就是要減少 redo/undo 的花費。</p><p>根據工作上遇到的經驗，資料庫本身可以常數回推，紀錄變動的部分情況即可。而應用層的計算，大部分實作都是砍掉快取，並且重新計算出一份新的結構，有時候回推的變動大小為 m，為了重新計算結構而消耗了 n+m，如果 n 和 m 的差距非常大，那連續回推的體感就很糟糕。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>更強硬一點的叫做 Confluent Persistence，可以讓兩個不同的版本合併一個版本，感覺起來就相當於兩個平行宇宙要合併，實際的應用更少一些，大部分應該是在兩個資料結構的合併，如兩個堆如何合併，兩棵伸展樹的合併 … 等的底層定義所需。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可持久化的實際用途到底有哪些？這麼複雜的概念大部分場景都用不上？&lt;/p&gt;
&lt;h2 id=&quot;函數式編程&quot;&gt;&lt;a href=&quot;#函數式編程&quot; class=&quot;headerlink&quot; title=&quot;函數式編程&quot;&gt;&lt;/a&gt;函數式編程&lt;/h2&gt;&lt;p&gt;其不可變的需求，造就了持久化的使用。
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="可持久化" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
      <category term="可持久化" scheme="http://morris821028.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>可持久化雙向隊列 Persistent Deque 續</title>
    <link href="http://morris821028.github.io/2020/01/05/mproblem-persistent-deque-pre-evaluation/"/>
    <id>http://morris821028.github.io/2020/01/05/mproblem-persistent-deque-pre-evaluation/</id>
    <published>2020-01-05T11:04:31.000Z</published>
    <updated>2020-01-05T12:01:41.936Z</updated>
    
    <content type="html"><![CDATA[<p>接續前一篇 《可持久化雙向隊列 Persistent Deque 序》，同樣的概念，Okasaki 用了他那精妙的公式描述了前一篇採用的策略只不過是常數 <span>$c = 3$</span><!-- Has MathJax --> 的情況，實際上可以根據需求去改變常數 <span>$c$</span><!-- Has MathJax -->，先決條件 <span>$c \ge 2$</span><!-- Has MathJax -->。</p><h2 id="預先評估雙向隊列-Pre-Evaluation"><a href="#預先評估雙向隊列-Pre-Evaluation" class="headerlink" title="預先評估雙向隊列 (Pre-Evaluation)"></a>預先評估雙向隊列 (Pre-Evaluation)</h2><ul><li>SIMPLE AND EFFICIENT PURELY FUNCTIONAL QUEUES AND DEQUES, Chris Okasaki, 1995</li></ul><p>同樣地，雙向隊列為兩個堆疊表示，並限制其中一個大小不能大於另一個的 <span>$c$</span><!-- Has MathJax --> 倍，如果發生了用另一種方式表示部分翻轉的結果。</p><h3 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h3><span>$$\begin{aligned}&amp; |L| \le c |R| + 1 \; \wedge \; |R| \le c |L| + 1\\&amp; |\hat{L}| \le \max(2j+2-k, 0) \; \wedge \; |\hat{R}| \le \max(2j+2-k, 0) &amp;\\&amp; \text{where} \; j = \min(|L|, |R|) \; \wedge \; k = \max(|L|, |R|)\end{aligned}$$</span><!-- Has MathJax --><h3 id="Functional-Definition"><a href="#Functional-Definition" class="headerlink" title="Functional Definition"></a>Functional Definition</h3><span>$$\begin{align}\left [ \; \right ]_{d} &amp;= \left \langle \left [ \; \right ], \left [ \; \right ], \left [ \; \right ], \left [ \; \right ] \right \rangle \\|\left \langle L, R, \hat{L}, \hat{R}\right \rangle| &amp;= |L| + |R| \\\textit{insert}L(e, \left \langle L, R, \hat{L}, \hat{R}\right \rangle) &amp;= \textit{makedq}\left \langle e:L, R, \textit{tl}\; \hat{L}, \textit{tl}\; \hat{R}\right \rangle \\\textit{insert}R(e, \left \langle L, R, \hat{L}, \hat{R}\right \rangle) &amp;= \textit{makedq}\left \langle L, e:R, \textit{tl}\; \hat{L}, \textit{tl}\; \hat{R}\right \rangle \\\textit{remove}L\left \langle L, R, \hat{L}, \hat{R}\right \rangle &amp;= \left \langle \textit{hd}\; R, \left [ \; \right ]_d \right \rangle &amp; \left \{ |L| = 0 \right \}\\&amp;= \left \langle \textit{hd}\; L, \textit{makedq} \left \langle \textit{tl} \; L, R, \textit{tl} \; (\textit{tl} \hat{L}), \textit{tl} \; (\textit{tl} \hat{R}) \right \rangle \right \rangle &amp; \left \{ |L|&gt; 0 \right \}\\\textit{remove}R\left \langle L, R, \hat{L}, \hat{R}\right \rangle &amp;= \left \langle \textit{hd}\; L, \left [ \; \right ]_d \right \rangle &amp; \left \{ |R| = 0 \right \}\\&amp;= \left \langle \textit{hd}\; R, \textit{makedq} \left \langle L, \textit{tl} \; R, \textit{tl} \; (\textit{tl} \hat{L}), \textit{tl} \; (\textit{tl} \hat{R}) \right \rangle \right \rangle &amp; \left \{ |R|&gt; 0 \right \}\\\textit{makedq}\left \langle L, R, \hat{L}, \hat{R}\right \rangle &amp;= \left \langle \hat{L}, \hat{R}, \hat{L}, \hat{R} \right \rangle, \; \begin{aligned}\text{let} \; n &amp;= \left \lfloor (|L| + |R|)/2 \right \rfloor \\L&apos; &amp;= \textit{take}(n, L) \\R&apos; &amp;= \textit{rot1}(n, R, L) \end{aligned} &amp; \left \{ |L| &gt; c |R| + 1 \right \} \\&amp;= \left \langle \hat{L}, \hat{R}, \hat{L}, \hat{R} \right \rangle, \; \begin{aligned}\text{let} \; n &amp;= \left \lfloor (|L| + |R|)/2 \right \rfloor \\L&apos; &amp;= \textit{rot1}(n, L, R) \\R&apos; &amp;= \textit{take}(n, R) \end{aligned} &amp; \left \{ |R| &gt; c |L| + 1 \right \} \\&amp;= \left \langle L, R, \hat{L}, \hat{R} \right \rangle &amp; \left \{ \text{otherwise} \right \} \\\textit{rot1}(n, L, R) &amp;= \textit{hd} \; L : \; \textit{rot1}(n-c, \textit{tl}\; L, \textit{drop}(c, R)) &amp; \left \{ n \ge c \right \} \\&amp;= \textit{rot2}(L, \textit{drop}(n, R), \left [ \; \right ]) &amp; \left \{ n &lt; c \right \} \\\textit{rot2}(L, R, A) &amp;= \textit{hd}\; L : \; \textit{rot2}(\textit{tl}\; L, \textit{drop}(c, R), \textit{rev}(\textit{take}(c, R)) + A) &amp; \left \{ |L| &gt; 0 \wedge |R| \ge c \right \}  \\&amp;= L + \textit{rev}R + A &amp; \left \{ |L| = 0 \vee |R| &lt; c \right \} \end{align}$$</span><!-- Has MathJax --><p>放眼望去共計 15 條式子，而一半都是對稱操作。唯獨在式 12 到 式 15 較為特別，相當於前一篇的反轉操作，只是我們透過額外的定義來描述它，實作時相當多一個類別。不管是記憶體分析、還是時間複雜度分析，原則上與前一篇是相同的。</p><p>公式裡描述了一堆的 <span>$\hat{L}, \; \hat{R}$</span><!-- Has MathJax -->，我們卻沒有在任何的條件式中使用，只作為我們去理解操作的含意。因此，實作時只在 <span>$makedq$</span><!-- Has MathJax --> 區域變數中作用，並不會成為一個必要紀錄的值。</p><p>特別注意到建構子中，令 <span>$R&apos; = \textit{rot1}(n, R, L)$</span><!-- Has MathJax -->，這個操作可能直接成為 <span>$\textit{rot2}(L, \textit{drop}(n, R), \left [ \; \right ])$</span><!-- Has MathJax -->，思維必須往前看一步去轉化所有實際的類別，否則很容易在相關操作退化。因為 <span>$L, \; R$</span><!-- Has MathJax --> 都是作為 rot1 或者是 rot2 後的產物，盡可能地使之成為最簡單的表達式。</p><h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接續前一篇 《可持久化雙向隊列 Persistent Deque 序》，同樣的概念，Okasaki 用了他那精妙的公式描述了前一篇採用的策略只不過是常數 &lt;span&gt;$c = 3$&lt;/span&gt;&lt;!-- Has MathJax --&gt; 的情況，實際上可以根據需求去改變常數 
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="可持久化" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
      <category term="可持久化" scheme="http://morris821028.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="deque" scheme="http://morris821028.github.io/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>可持久化雙向隊列 Persistent Deque 序</title>
    <link href="http://morris821028.github.io/2020/01/01/mproblem-persistent-deque/"/>
    <id>http://morris821028.github.io/2020/01/01/mproblem-persistent-deque/</id>
    <published>2020-01-01T11:59:02.000Z</published>
    <updated>2020-01-01T13:47:11.801Z</updated>
    
    <content type="html"><![CDATA[<p>完成了一般隊列，接下來就是雙向隊列，這個時候操作就沒有強烈的單調方向性質，需要同時維護兩種入隊、出隊的情況。</p><p>沿用可持久化隊列的思路。在隊列時，我們評估情況為前後各一半，預估反轉的結果，均攤每一個操作費用，一旦前半部為空，立即使用反轉完的結果。而雙向的情況更為複雜，我們若按照隊列的方式，那麼在 pop-back 的時候，預估的結果反而成為了阻礙，因為要再反轉一次回來。為此調整鬆弛反轉的限制。</p><h2 id="即時雙向隊列-Realtime"><a href="#即時雙向隊列-Realtime" class="headerlink" title="即時雙向隊列 (Realtime)"></a>即時雙向隊列 (Realtime)</h2><ul><li>REAL-TIME DEQUES, MULTIHEAD TURING MACHINES and PURELY FUNCTIONAL PROGRAMMING, Tyng-Runey Chuang and Benjamin Goldberg, 1993</li></ul><h3 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h3><p>定義雙向隊列為 <span>$Q = \left \langle L, \; R \right \rangle$</span><!-- Has MathJax --></p><p>在操作過程中，可以鏡像狀態，令較大的那一個為 <span>$B$</span><!-- Has MathJax -->，較小的為 <span>$S$</span><!-- Has MathJax -->，意即 <span>$\left \langle B, \; S \right \rangle = \left \langle L, \; R \right \rangle$</span><!-- Has MathJax --> 或者 <span>$\left \langle B, \; S \right \rangle = \left \langle R, \; L \right \rangle$</span><!-- Has MathJax -->。需滿足</p><span>$$\begin{aligned}|B| \ge |S| \ge 1, \; \text{and} \; 3|S| \ge |B|\end{aligned}$$</span><!-- Has MathJax --><p>若違反上述條件，立即進入 <strong>轉移狀態</strong>，將三分之一的 <span>$B$</span><!-- Has MathJax --> 搬入 <span>$S$</span><!-- Has MathJax -->，此時兩者具有近似的大小。在轉移中，我們可能在過程中將其中一方增減，完成轉移後必要滿足條件式。</p><h3 id="轉移狀態"><a href="#轉移狀態" class="headerlink" title="轉移狀態"></a>轉移狀態</h3><p>令起始轉移狀態為 <span>$\left \langle S, \; B \right \rangle$</span><!-- Has MathJax -->，其中</p><ul><li><span>$S = (p_1, p_2, \cdots, p_m)^\triangleleft$</span><!-- Has MathJax --></li><li><span>$B = (q_1, q_2, \cdots, q_{3m+k})^\triangleright$</span><!-- Has MathJax --></li><li><span>$k \in \left \{ 1, 2, 3\right \}$</span><!-- Has MathJax --></li></ul><p>目標狀態 <span>$\left \langle \textit{new}S, \; \textit{new}B \right \rangle$</span><!-- Has MathJax --></p><ul><li><span>$\textit{new}S = (p_1, p_2, \cdots, p_m, q_1, q_2, \cdots, q_{m+1})^\triangleleft$</span><!-- Has MathJax --></li><li><span>$\textit{new}B = (q_{m+2}, q_{m+3}, \cdots, q_{3m+k})^\triangleright$</span><!-- Has MathJax --></li></ul><p>必須均攤在 <span>$m$</span><!-- Has MathJax --> 次操作內完成，而舊有的 <span>$S$</span><!-- Has MathJax --> 可能在轉移中被 pop 到空集合，需要標記複製成功的次數，直到 <span>$\textit{new}S$</span><!-- Has MathJax --> 已經匹配了前半部的 <span>$S$</span><!-- Has MathJax -->。</p><ol><li><span>$B = (q_1, q_2, \cdots, q_{3m+k})^\triangleright$</span><!-- Has MathJax --> 拆分成<br> <span>$B = (q_1, q_2, \cdots, q_{m+1})^\triangleright$</span><!-- Has MathJax --> 和 <span>$\textit{aux}B = (q_{m+2}, q_{m+2}, \cdots, q_{3m+k})^\triangleleft$</span><!-- Has MathJax --></li><li><span>$\textit{new}S = (p_1, p_2, \cdots, p_m)^\triangleleft$</span><!-- Has MathJax --> 反轉成<br> <span>$S = ()^\triangleleft$</span><!-- Has MathJax --> 和 <span>$\textit{aux}S = (p_1, p_2, \cdots, p_m)^\triangleright$</span><!-- Has MathJax --></li><li><span>$\textit{aux}B = (q_{m+2}, q_{m+2}, \cdots, q_{3m+k})^\triangleleft$</span><!-- Has MathJax --> 反轉成<br> <span>$\textit{aux}B = ()^\triangleleft$</span><!-- Has MathJax --> 和 <span>$\textit{new}B = (q_{m+2}, q_{m+2}, \cdots, q_{3m+k})^\triangleright$</span><!-- Has MathJax --></li><li><span>$B = (q_1, q_2, \cdots, q_{m+1})^\triangleright$</span><!-- Has MathJax --> 放入為<br> <span>$\textit{new}S = (q_1, q_2, \cdots, q_{m+1})^\triangleleft$</span><!-- Has MathJax --> 和 <span>$B = ()^\triangleright$</span><!-- Has MathJax --></li><li><span>$\textit{aux}S = (p_1, p_2, \cdots, p_m)^\triangleright$</span><!-- Has MathJax --> 也放入為<br> <span>$\textit{new}S = (p_1, p_2, \cdots, p_m, q_1, q_2, \cdots, q_{m+1})^\triangleleft$</span><!-- Has MathJax --> 和 <span>$\textit{aux}S = ()^\triangleright$</span><!-- Has MathJax --></li></ol><p>步驟 1 和 2 同時操作，總數至多為 <span>$2m+3$</span><!-- Has MathJax -->。步驟 3 可以和 4 或 5 其中一種同時操作，總數至多為 <span>$2m+3$</span><!-- Has MathJax -->，因此操作數為 <span>$4m+6$</span><!-- Has MathJax -->。均攤在 <span>$m$</span><!-- Has MathJax --> 次操作內，得到常數因子為 4。</p><h3 id="隊列操作說明"><a href="#隊列操作說明" class="headerlink" title="隊列操作說明"></a>隊列操作說明</h3><p>即使說明了轉移方程，主要的問題還是卡在做到 push/pop</p><ul><li><code>pushFront</code>/<code>pushBack</code> 若<strong>計算完的雙向隊列大小</strong>小於等於 4 時，採用攤平的方式操作，強制不進入上述轉移條件。反之，直接在相應的堆疊上操作。</li><li><code>popFront</code>/<code>popBack</code> 若<strong>計算完的雙向隊列大小</strong>小於 4 時，採用攤平的方式操作，強制不進入上述轉移條件。反之，直接在相應的堆疊上操作。</li></ul><p>額外維護的指針告訴我們複製的 <span>$S$</span><!-- Has MathJax --> 狀態，而 <span>$B$</span><!-- Has MathJax --> 也會在過程中被 pop 出去，因此 <span>$\textit{new}B$</span><!-- Has MathJax --> 有時會需要代入 <span>$\text{Take}$</span><!-- Has MathJax --> 操作。</p><h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;完成了一般隊列，接下來就是雙向隊列，這個時候操作就沒有強烈的單調方向性質，需要同時維護兩種入隊、出隊的情況。&lt;/p&gt;
&lt;p&gt;沿用可持久化隊列的思路。在隊列時，我們評估情況為前後各一半，預估反轉的結果，均攤每一個操作費用，一旦前半部為空，立即使用反轉完的結果。而雙向的情況更為
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="可持久化" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
      <category term="可持久化" scheme="http://morris821028.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="deque" scheme="http://morris821028.github.io/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>可持久化隊列 Persistent Queue 續</title>
    <link href="http://morris821028.github.io/2019/12/25/mproblem-persistent-queue-pre-evaluation/"/>
    <id>http://morris821028.github.io/2019/12/25/mproblem-persistent-queue-pre-evaluation/</id>
    <published>2019-12-24T22:20:06.000Z</published>
    <updated>2020-01-01T11:40:41.676Z</updated>
    
    <content type="html"><![CDATA[<p>接續前一篇 《可持久化隊列 Persistent Queue 序》，開始搬運論文的內容，就當作個翻譯吧</p><h2 id="預先評估隊列-Pre-Evaluation"><a href="#預先評估隊列-Pre-Evaluation" class="headerlink" title="預先評估隊列 (Pre-Evaluation)"></a>預先評估隊列 (Pre-Evaluation)</h2><ul><li>SIMPLE AND EFFICIENT PURELY FUNCTIONAL QUEUES AND DEQUES, Chris Okasaki, 1995</li></ul><h3 id="初階定義"><a href="#初階定義" class="headerlink" title="初階定義"></a>初階定義</h3><p>定義：隊列 <span>$Q = \left \langle L, \; R \right \rangle$</span><!-- Has MathJax --> 且滿足 <span>$|R| \le |L|$</span><!-- Has MathJax --></p><span>$$\begin{aligned}\left [ \; \right ]_{q} &amp;= \left \langle \left [ \; \right ], \left [ \; \right ] \right \rangle\\\\|\left \langle L, \; R \right \rangle | &amp;= |L| + |R|\\\\\textit{insert} \; (e, \left \langle L, \; R \right \rangle) &amp;= \textit{makeq} \; (L, \; e : R)\\\\\textit{remove} \left \langle L, \; R \right \rangle &amp;= \left \langle \text{hd} \; L, \textit{makeq} \; (\text{tl} \; L, \; R) \right \rangle\\\\\textit{makeq}  \left \langle L, \; R \right \rangle &amp;=  \left \langle L, \; R \right \rangle &amp;\{ |R| \le |L|\} \\&amp;= \left \langle \textit{rot}(L, R, \left [ \; \right ]), \left [ \; \right ] \right \rangle &amp;\{ |R| = |L| + 1\}\\\\\textit{rot}(L, R, A) &amp;= \text{hd} \; R : A &amp; \{ |L| = 0 \} \\                      &amp;= \text{hd} \; L : \textit{rot}(\text{tl} \; L, \text{tl} \; R, \text{hd} \; R : A) &amp; \{ |L| &gt; 0 \}\end{aligned}$$</span><!-- Has MathJax --><p>看到這一大串的語法樹，就要開始構思曾經在編譯器學到的 LL Parser，操作完之後仍然是一個隊列，為了找到隊列的頭，我們要去完成 LL(1) 的計算，使用向前探查 (lookahead) 問第一個元素為何。</p><p>不幸地，上述語法的 <span>$\textit{remove}$</span><!-- Has MathJax --> 為 <span>$\mathcal{O}(\log n)$</span><!-- Has MathJax -->，其他操作為 <span>$\mathcal{O}(1)$</span><!-- Has MathJax -->。原因很簡單，當我們不斷地 <span>$\textit{insert}$</span><!-- Has MathJax --> 進去時，根據語法樹會不斷地構造長度為 <span>$1,\; 2,\; 4, \cdots, 2^n$</span><!-- Has MathJax --> 長度的 <span>$\textit{rot}$</span><!-- Has MathJax --> 堆疊，這時候若要看第一個元素為何，運算量就等同於遞迴深度。</p><p>縱使我們在每個堆疊建構時，預先計算出 <code>front()</code> 的結果，那麼在 <code>pop()</code> 回傳的時候，仍需要付出代價，而我們更不能在建構子中預先計算出 <code>pop()</code> ，這違反遞迴定義，更會落入退化成線性操作，而不是想要的惰性操作。當瞭解上述的問題後，接下來要想辦法把 <span>$\textit{remove}$</span><!-- Has MathJax --> 變成 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 操作。</p><h2 id="進階定義"><a href="#進階定義" class="headerlink" title="進階定義"></a>進階定義</h2><p>定義：隊列 <span>$Q = \left \langle L, \; R, \; \hat{L} \right \rangle$</span><!-- Has MathJax --> 且滿足 <span>$|R| \le |L| \wedge |\hat{L}| = |L| - |R|$</span><!-- Has MathJax --></p><span>$$\begin{aligned}\left [ \; \right ]_{q} &amp;= \left \langle \left [ \; \right ], \left [ \; \right ], \left [ \; \right ] \right \rangle\\\\|\left \langle L, \; R, \; \hat{L} \right \rangle | &amp;= |L| + |R|\\\\\textit{insert} \; (e, \left \langle L, \; R, \; \hat{L} \right \rangle) &amp;= \textit{makeq} \; (L, \; e : R, \hat{L})\\\\\textit{remove} \left \langle L, \; R, \; \hat{L} \right \rangle &amp;= \left \langle \text{hd} \; L, \textit{makeq} \; (\text{tl} \; L, \; R, \hat{L}) \right \rangle\\\\\textit{makeq}  \left \langle L, \; R, \; \hat{L} \right \rangle &amp;=  \left \langle L, \; R, \;  \text{tl} \; \hat{L} \right \rangle &amp;\{ |\hat{L}| &gt; 0\} \\&amp;= \left \langle L&apos;, \left [ \; \right ], L&apos; \right \rangle, \; \text{let} \; L&apos; = \textit{rot}(L, R, \left [ \; \right]) &amp;\{ |\hat{L}| = 0\}\\\\\textit{rot}(L, R, A) &amp;= \text{hd} \; R : A &amp; \{ |L| = 0 \} \\                      &amp;= \text{hd} \; L : \textit{rot}(\text{tl} \; L, \text{tl} \; R, \text{hd} \; R : A) &amp; \{ |L| &gt; 0 \}\end{aligned}$$</span><!-- Has MathJax --><p>透過額外的 <span>$\hat{L}$</span><!-- Has MathJax -->，避開了 LL Parser 和 lookahead 造成的遞迴定義，如此一來每一個操作複雜度皆為 <span>$\mathcal{O}(1)$</span><!-- Has MathJax -->。其概念也很簡單，為了維持條件 <span>$|R| \le |L|$</span><!-- Has MathJax -->，我們將 <span>$\hat{L}$</span><!-- Has MathJax --> 定義為其差值，為即將地部分 <span>$R$</span><!-- Has MathJax --> 反轉到變成 <span>$L$</span><!-- Has MathJax --> 計數做準備。</p><p>特別注意到，在 <span>$\text{makeq}$</span><!-- Has MathJax --> 的時候，同步移除掉了一部分的 <span>$\hat{L}$</span><!-- Has MathJax -->，而在長度 <span>$|\hat{L}| = 0$</span><!-- Has MathJax --> 觸發反轉。實作上，可以當作一個長度數值去看待，而在可持久化概念上，它們實際上共享同一塊內存，所以也就沒有太大的差別。</p><p>概念與前一篇的 Realtime Queue 構造方式類同。只不過，我們預先將答案放置於 <span>$\textit{rot}$</span><!-- Has MathJax --> 堆疊定義中的 <span>$A$</span><!-- Has MathJax --> 中，而重複使用了 <span>$\hat{L}$</span><!-- Has MathJax --> 找到完成時刻。</p><h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接續前一篇 《可持久化隊列 Persistent Queue 序》，開始搬運論文的內容，就當作個翻譯吧&lt;/p&gt;
&lt;h2 id=&quot;預先評估隊列-Pre-Evaluation&quot;&gt;&lt;a href=&quot;#預先評估隊列-Pre-Evaluation&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="可持久化" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
      <category term="可持久化" scheme="http://morris821028.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="queue" scheme="http://morris821028.github.io/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>可持久化隊列 Persistent Queue 序</title>
    <link href="http://morris821028.github.io/2019/12/24/mproblem-persistent-queue/"/>
    <id>http://morris821028.github.io/2019/12/24/mproblem-persistent-queue/</id>
    <published>2019-12-23T22:43:50.000Z</published>
    <updated>2020-01-01T11:58:07.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們完成了持久化堆疊後，必然要去完成隊列 (Queue)。難度遠比想像中的高，很多人的第一個反應是用兩個指標去完成持久化隊列，分別指向最前和最後的兩個元素。不幸地，<strong>直覺無法套用</strong>在不同的領域上。</p><p>下述為一個例子，假定每一個節點都往後指到下一次會被 pop 的節點，則我們無法同時描述 B 和 C。如果每一個節點都往前指到前一個加入的節點，則無法解決隊列的 pop 操作。上述的兩種設計都無法滿足可持久化的定義，則得到<strong>用兩個指標是無法完成可持久化隊列</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A = empty().push(1); // [1]</div><div class="line">B = A.push(2);       // [1, 2]</div><div class="line">C = A.push(3);       // [1, 3]</div><div class="line">D = B.pop();         // [2]</div></pre></td></tr></table></figure><h3 id="攤銷分析的錯誤"><a href="#攤銷分析的錯誤" class="headerlink" title="攤銷分析的錯誤"></a>攤銷分析的錯誤</h3><p>定義：可持久化隊列 <span>$Q = \left \langle L, \; R \right \rangle$</span><!-- Has MathJax --></p><p>在沒有持久化的要求下，我們的確可以用兩個堆疊 <span>$L, \; R$</span><!-- Has MathJax --> 去實作隊列 <span>$Q$</span><!-- Has MathJax -->。當 <span>$|L|  = 0$</span><!-- Has MathJax --> 時，令 <span>$L&apos; = \text{Rev}(R), \; R&apos; = \left [ \; \right ]$</span><!-- Has MathJax -->，每一個操作的時間複雜度為 <span>$\text{amortized} \; \mathcal{O}(1)$</span><!-- Has MathJax -->。</p><p>然而，對於可持久化的場合中，這種忽大忽小的成本是不切實際的，因為持久化會複製整體的攤銷成本，而獨立於前一個狀態。達到真正的即時 (realtime)，必須保證每一個操作 <span>$\mathcal{\Theta}(1)$</span><!-- Has MathJax -->，才能防止攤銷最慘情況不會發生。</p><h2 id="即時隊列-Realtime"><a href="#即時隊列-Realtime" class="headerlink" title="即時隊列 (Realtime)"></a>即時隊列 (Realtime)</h2><ul><li>REAL-TIME QUEUE OPERATIONS IN PURE LISP, Robert HOOD and Robert MEVILL, 1981</li></ul><p>這快三十年前的論文，給了我們設計函數式的另一種啟發。不透過函數式語言的語法結構，我們可以很直觀地用傳統算法去模擬可持久化隊列。好比 C++ 中的 <code>vector&lt;T&gt;</code> 或者是 Java 中 的<code>ArrayList&lt;T&gt;</code>，每當快滿的時候，我們變將元素複製到兩倍大的容器裡。那可持久化就好比背景程式一般，在每一次操作的過程中，就開始準備好抽換的兩倍容器，直到真的要替換的時候，就可以常數搬移。</p><p>定義：隊列 <span>$Q = \left \langle O^{\triangleleft}, I^{\triangleright} \right \rangle$</span><!-- Has MathJax --> 且滿足 <span>$|O^{\triangleleft}| \ge |I^{\triangleright}|$</span><!-- Has MathJax --></p><ul><li><span>$O^{\triangleleft}$</span><!-- Has MathJax --> 表示出隊的堆疊</li><li><span>$I^{\triangleright}$</span><!-- Has MathJax --> 表示入隊的堆疊</li></ul><p>當發生 <span>$|O^{\triangleleft}| = n, \; |I^{\triangleright}| = n+1$</span><!-- Has MathJax --> 時，我們標記這個隊列為 <strong>轉移中</strong> (<em>transferring</em>)，此時開始可不滿足上述 <span>$|O^{\triangleleft}| \ge |I^{\triangleright}|$</span><!-- Has MathJax --> 的規定。接著，我們將預期在下一次 <span>$|O^{\triangleleft}| = 0$</span><!-- Has MathJax --> 的 pop 操作前，變換成 <span>$Q = \left \langle (OI)^{\triangleleft}, \left [ \; \right ]  \right \rangle$</span><!-- Has MathJax -->。因此這中間至少有 <span>$n$</span><!-- Has MathJax --> 次的 push/pop 操作，讓我們將轉移中隊列變成正規隊列。</p><p>需要以下操作：</p><ol><li>將 <span>$I^{\triangleright}$</span><!-- Has MathJax --> 的所有元素 pop 至 <span>$I_\text{aux} = I^{\triangleleft}$</span><!-- Has MathJax -->，需 <span>$n+2$</span><!-- Has MathJax --> 步。</li><li>將 <span>$O^{\triangleleft}$</span><!-- Has MathJax --> 的所有元素 pop 至 <span>$O_\text{aux} = O^{\triangleright}$</span><!-- Has MathJax -->，需 <span>$n+1$</span><!-- Has MathJax --> 步。</li><li>將 <span>$O_\text{aux}$</span><!-- Has MathJax --> 的所有元素 pop 至 <span>$I_\text{aux}$</span><!-- Has MathJax -->，<span>$O_\text{new}= (OI)^{\triangleleft}$</span><!-- Has MathJax -->，需 <span>$n+1$</span><!-- Has MathJax --> 步。</li></ol><p>共計 <span>$3n+4$</span><!-- Has MathJax --> 步。平均在 <span>$n$</span><!-- Has MathJax --> 次操作內完成。變成 <strong>轉移中</strong> 狀態的那一瞬間，操作 <span>$7$</span><!-- Has MathJax --> 次，隨後的每一個 push/pop 完成 <span>$3$</span><!-- Has MathJax --> 次操作。 確保了每一步在常數時間內完成。</p><p>在轉移過程中，若進行 push 操作，直接在清空完後的 <span>$I^{\triangleright}$</span><!-- Has MathJax --> 上操作、或者 <span>$I_\text{extra}^{\triangleright}$</span><!-- Has MathJax --> 。若進行 pop 操作時，步驟 3 的最後幾個會成為多餘操作，故需要額外的計數器統計總共完成了幾個 <span>$O_\text{aux}$</span><!-- Has MathJax --> 複製，當完成數量等於當前數量 <span>$|O|$</span><!-- Has MathJax --> 便停止轉移，並標記為正規隊列 <span>$Q = \left \langle O_\text{new}^{\triangleleft}, I^{\triangleright} \right \rangle$</span><!-- Has MathJax -->、或者 <span>$Q = \left \langle O_\text{new}^{\triangleleft}, I_\text{extra}^{\triangleright} \right \rangle$</span><!-- Has MathJax --></p><p>宣告不可變物件的類別時，以 Java 為例相當棘手，展開代碼會造成進入 HotSpot 的機會變低，傳遞這個多的參數進行轉移卻要用在回傳值上額外宣告變數來接取。因此，透過平均 <span>$3$</span><!-- Has MathJax --> 次，可能會需要額外宣告 3 次變數，這對 GC 的壓力非同小可。貪心一點，用常數 4 取代，這麼一來可讀性不會下降太多，代碼也能更明確一點，呼叫 2 次的 2 個操作。</p><p>實作時，一個可持久化隊列除了一開始的 2 個堆疊，還要維護轉移狀態 5~6 的狀態空間，因此一個隊列需要 7~8 個欄位。</p><h2 id="預先評估隊列-Pre-Evaluation"><a href="#預先評估隊列-Pre-Evaluation" class="headerlink" title="預先評估隊列 (Pre-Evaluation)"></a>預先評估隊列 (Pre-Evaluation)</h2><ul><li>SIMPLE AND EFFICIENT PURELY FUNCTIONAL QUEUES AND DEQUES, Chris Okasaki, 1995</li></ul><p>這是另一種設計方法，上述方法用了 7~8 欄位來表示一個隊列，作為一個函數式定義太複雜了，這一概念將只使用 3 個，其他的塞在別的定義中，讓其他函數式定義也能夠共享，下一篇文章再來細說。</p><h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p><h2 id="效能評比"><a href="#效能評比" class="headerlink" title="效能評比"></a>效能評比</h2><p>以 Java 實作，Realtime 與 Pre-Evaluation 效能差不多，但以 OOP 的角度看來 Realtime 很像當初打比賽的精明能幹，Pre-Evaluation 則是代碼量巨大，擴充概念性高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我們完成了持久化堆疊後，必然要去完成隊列 (Queue)。難度遠比想像中的高，很多人的第一個反應是用兩個指標去完成持久化隊列，分別指向最前和
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="可持久化" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
      <category term="可持久化" scheme="http://morris821028.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="queue" scheme="http://morris821028.github.io/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>可持久化堆疊 操作 Persistent Stack Operators</title>
    <link href="http://morris821028.github.io/2019/12/23/mproblem-persistent-stack-operators/"/>
    <id>http://morris821028.github.io/2019/12/23/mproblem-persistent-stack-operators/</id>
    <published>2019-12-23T13:21:21.000Z</published>
    <updated>2020-01-01T11:57:22.690Z</updated>
    
    <content type="html"><![CDATA[<p>接續前一篇 《可持久化堆疊 Persistent Stack》，接下來要探討可持久化堆疊相互操作，如何照常在常數複雜度內完成。這一連貫的定義，將在後續的隊列、雙向隊列中使用。</p><h2 id="串接-Append"><a href="#串接-Append" class="headerlink" title="串接 Append"></a>串接 Append</h2><p>定義：串接堆疊 <span>$A = \text{Append} \; (T, B)$</span><!-- Has MathJax --></p><span>$$\begin{aligned}\left [ \; \right ]_{\textit{append}} &amp;= \left \langle \left [ \; \right ], \left [ \; \right ] \right \rangle\\\\|\left \langle T, \; B \right \rangle | &amp;= |T| + |B|\\\\\textit{push} \; (\textit{e}, \left \langle T, \; B \right \rangle) &amp;= \left \langle e : T, \; B \right \rangle\\\\\textit{pop} \; (\left \langle T, \; B \right \rangle) &amp;= \left \langle \text{hd} \; T, \left \langle \text{tl} \; T, \; B \right \rangle \right \rangle &amp; \{ |T| &gt; 0 \} \\&amp;= \left \langle \text{hd} \; B, \text{tl} \; B \right \rangle &amp; \{ |T| = 0 \}\end{aligned}$$</span><!-- Has MathJax --><p>串接兩個堆疊 <span>$T, \; B$</span><!-- Has MathJax -->，並且 <span>$T$</span><!-- Has MathJax --> 放置於頂首、<span>$B$</span><!-- Has MathJax --> 放置於末端，這時候串接也可以被視為一個堆疊結構。由於我們只在意堆疊的接口，完成這三項基礎操作並不是難事。皆可以在 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 內完成。</p><p>對於大小這一個計算，要特別小心一個錯誤，如果直接以回傳值 <span>$|T| + |B|$</span><!-- Has MathJax --> 撰寫，將在遞迴使用時，其一方也為串接定義出的堆疊而退化成 <span>$\mathcal{O}(n)$</span><!-- Has MathJax --> 的計算。因此在宣告時，紀錄大小是很重要的。</p><p>此外，我們也很容易遞迴定義出 Append，如果 <span>$T$</span><!-- Has MathJax --> 本身也是 Append 出來的結果，那麼 pop 時會付出遞迴深度的代價，按照使用的演算法，這種情況會使得時間複雜度為 <span>$\mathcal{O}(\log n)$</span><!-- Has MathJax -->。構造時，如果 <span>$T \in \text{Append}$</span><!-- Has MathJax -->，拆解成 <span>$\text{Append}(T.l, \; \text{Append}(T.r, \; B))$</span><!-- Has MathJax --> 可以避免。</p><p>我們透過簡單的工廠模式 (Factory Design Pattern)，防止額外的空間宣告，當 <span>$T$</span><!-- Has MathJax --> 或者 <span>$B$</span><!-- Has MathJax --> 其一為空時，直接回傳其中一方。接著就能保證 <span>$|T| &gt; 0, \; |B| &gt; 0$</span><!-- Has MathJax -->，操作就能簡化許多。</p><h2 id="提取-Take"><a href="#提取-Take" class="headerlink" title="提取 Take"></a>提取 Take</h2><p>定義：提取堆疊 <span>$A = \text{Take} \; (n, X)$</span><!-- Has MathJax --></p><span>$$\begin{aligned}\left [ \; \right ]_{\textit{take}} &amp;= \left \langle 0, X \right \rangle\\\\|\left \langle n, X \right \rangle | &amp;= n\\\\\textit{push} \; (\textit{e}, \left \langle n, X \right \rangle) &amp;= \text{Append}(e,\; \left \langle n, X \right \rangle)\\\\\textit{pop} \; (\left \langle n, X \right \rangle) &amp;= \left [ \; \right ] &amp; \{ n = 1 \} \\&amp;= \left \langle \text{hd} \; X, \left \langle n-1, \text{tl} \; X \right \rangle \right \rangle &amp; \{ n &gt; 1 \}\end{aligned}$$</span><!-- Has MathJax --><p>只提取堆頂的前 <span>$n$</span><!-- Has MathJax --> 個元素，剩餘的都不需要。無疑地，提取堆疊也是可持久化的，並且在 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 時間內完成所有堆疊操作。但是在 push 操作時，將使用串接操作。</p><p>發生遞迴定義時，意即 <span>$X \in \text{Take}$</span><!-- Has MathJax -->，則必須提取成 <span>$A = \text{Take}(n, \; X.x)$</span><!-- Has MathJax --> 防止退化成 <span>$\mathcal{O}(\log n)$</span><!-- Has MathJax --></p><h2 id="移除-Drop"><a href="#移除-Drop" class="headerlink" title="移除 Drop"></a>移除 Drop</h2><p>定義：移除堆疊 <span>$A = \text{Drop} \; (n, X)$</span><!-- Has MathJax --></p><span>$$\begin{aligned}\text{Drop} \; (n, X) &amp;= X &amp; \{ n = 0 \} \\                      &amp;= \text{Drop} \; (n-1, X) &amp; \{ n &gt; 1\}\end{aligned}$$</span><!-- Has MathJax --><p>相反於提取，忽略堆頂的前 <span>$n$</span><!-- Has MathJax --> 個元素，從 <span>$n+1$</span><!-- Has MathJax --> 個開始算。</p><p>這裡僅提供遞迴定義，由於移除操作並非完全的常數操作，一旦需要拿到堆頂的第一個元素時，勢必要運行 <span>$n$</span><!-- Has MathJax --> 次。唯有在運行操作中，若 <span>$n \le c$</span><!-- Has MathJax --> 小於某個常數定值時，這時候才能把移除操作視為常數且可持久化的堆疊，否則將視為一般的攤平操作。</p><p>爾後，我們將提及一些算法的定義 <span>$c = 3$</span><!-- Has MathJax -->，使用這一個 Drop 操作。實作時要特別小心，同時 X 也是一個移除堆疊，那麼在建構前，必然要將 X 攤平，意即把 n 弄成 0 的表示法。防止 pop 操作時，意外地發生 stack overflow 的慘劇。</p><p>或許有人會問為什麼不一開始就攤平，早就是常數操作？其實，這就要看理論目標的最壞情況最小化，常數要怎麼分配到不同操作中。在可持久化的領域中，每一個常數操作的大小是每個操作的最大值，而非加總起來，<strong>完全不同於一般算法設計攤銷分析</strong>，因此優化的思維要有所轉變。</p><h2 id="反轉-Rev"><a href="#反轉-Rev" class="headerlink" title="反轉 Rev"></a>反轉 Rev</h2><p>定義：反轉堆疊 <span>$A = \text{Rev} \; (X)$</span><!-- Has MathJax --></p><span>$$\begin{aligned}\text{Rev} \; (X) &amp;= \text{Rev}&apos;(X, \left [ \; \right ]) &amp; \\\\\text{Rev}&apos;(X, A) &amp;= A &amp; \{ |X| = 0\} \\                  &amp;= \text{Rev}&apos; \; (\text{tl} \; X, \text{hd} \; X : A) &amp; \{ |X| &gt; 0\}\end{aligned}$$</span><!-- Has MathJax --><p>將整個堆疊 <span>$X$</span><!-- Has MathJax --> 反轉後置放成一個堆疊 <span>$A$</span><!-- Has MathJax -->。</p><p>同樣地，若沒有定義 <span>$|X| \le c$</span><!-- Has MathJax -->，反轉操作也<strong>無法在常數時間內完成</strong>。網路上許多實作號稱常數、攤銷持久化，實際上若牽涉到回傳反轉的過程，即使做了快取答案，也可以輕易地將它效能擊破。只需要不斷地呼叫反轉那一瞬間的的操作，或者倒退版本再推進一個版本去觸發攤銷的反轉操作，複雜度就會落入  <span>$\mathcal{O}(n)$</span><!-- Has MathJax -->。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li>SIMPLE AND EFFICIENT PURELY FUNCTIONAL QUEUES AND DEQUES, Chris Okasaki, 1995</li></ul><h2 id="來點題目-《記憶中的堆疊》"><a href="#來點題目-《記憶中的堆疊》" class="headerlink" title="來點題目 《記憶中的堆疊》"></a>來點題目 《記憶中的堆疊》</h2><h3 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h3><p>不斷地進行「思想實驗」的妮可，終於讓大腦演進到平行思考。假想在腦海裡，我們把狀態以堆疊 (Stack) 的方式儲存，當走投無路的時候，就會退回到上一個狀態，再把新的分支因素堆疊上去。正在全力計算的妮可無法細說每一個思維狀態，而我們可以操作戳記，反推出當前狀態。</p><p>操作有以下三種：</p><ul><li><code>0 v</code>: 退回版本 v</li><li><code>1 x</code>: 在當前堆疊，push x 到堆頂</li><li><code>2</code>: 印出當前堆疊狀態</li></ul><p>起始版本編號為 0，第 <span>$i$</span><!-- Has MathJax --> 次操作版本編號為 <span>$i$</span><!-- Has MathJax -->。</p><h3 id="範例輸入"><a href="#範例輸入" class="headerlink" title="範例輸入"></a>範例輸入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1 1</div><div class="line">1 2</div><div class="line">2</div><div class="line">0 1</div><div class="line">2</div><div class="line">1 3</div><div class="line">2</div><div class="line">0 3</div><div class="line">2</div></pre></td></tr></table></figure><h3 id="範例輸出"><a href="#範例輸出" class="headerlink" title="範例輸出"></a>範例輸出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2 1 ]</div><div class="line">1 ]</div><div class="line">3 1 ]</div><div class="line">2 1 ]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接續前一篇 《可持久化堆疊 Persistent Stack》，接下來要探討可持久化堆疊相互操作，如何照常在常數複雜度內完成。這一連貫的定義，將在後續的隊列、雙向隊列中使用。&lt;/p&gt;
&lt;h2 id=&quot;串接-Append&quot;&gt;&lt;a href=&quot;#串接-Append&quot; class
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="可持久化" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
      <category term="可持久化" scheme="http://morris821028.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="stack" scheme="http://morris821028.github.io/tags/stack/"/>
    
      <category term="堆" scheme="http://morris821028.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>可持久化堆疊 Persistent Stack</title>
    <link href="http://morris821028.github.io/2019/12/22/mproblem-persistent-stack/"/>
    <id>http://morris821028.github.io/2019/12/22/mproblem-persistent-stack/</id>
    <published>2019-12-22T12:07:37.000Z</published>
    <updated>2020-01-01T11:40:51.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在某些情況下，我們想要每次操作都能對應一個新的物件，即使變動當前的數據結構，也不影響前一次的數據結構。「可持久化 Persistent」一詞用來描述在這一段時間內，保存所有操作狀態的方法。若用在資料庫儲存概念中，「持久化 Persistence」則是用來描述將內存數據對照寫入檔案的可行性，兩者的意思不盡相同。</p><p>在工作發現許多語言開始支援函數式設計，也就是 <span>$\lambda$</span><!-- Has MathJax --> 計算 (lambda function)，以現在手上的 Java 開發，主要發生幾個常見的效能問題：</p><ul><li><p><strong>惰性求值</strong> (Lazy Evaluation)：<br>每一個惰性求值是需要的時候再計算，然而有些歷史代碼並不是這麼回事，導致一部分函數回傳整個串列，因此消耗了至少為 <span>$\mathcal{O}(n)$</span><!-- Has MathJax --> 的時間，而非函數式所需要的 <span>$\mathcal{O}(1)$</span><!-- Has MathJax -->。如果一個函數只針對前 10 個數值感興趣，大部分的資料都會被捨棄掉，在未來使用這些函數接口時，都還要去檢查每一個相關實作是否為真惰性，而非假性惰性。請參閱 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="external">Java Stream</a> 串流實作細節。</p></li><li><p><strong>不可變物件</strong> (Immutable Object)：<br>對於某些中間表達式，如檔案系統路徑。若要列出一個資料夾下的所有檔案路徑，在上述的惰性求值中，樸素的實作將會把路徑之間的重複不斷複製。正如同經典的字串問題，每串接一個字串，必然會複製一份，倘若複製的順序相反，時間複雜度將從 <span>$\mathcal{O}(n)$</span><!-- Has MathJax --> 變成 <span>$\mathcal{O}(n^2)$</span><!-- Has MathJax -->。</p></li></ul><p>串流操作 Stream 以 functional-style operation 為主，又細分成好幾種操作。即使運行結果相同，造就的效能與可拓展性也不同，如 <code>reduce</code> 和 <code>collect</code> 的差別，都能將一系列的元素縮合成一個，但是 <code>reduce</code> 採用二合一，容易在合成操作上退化成 <span>$\mathcal{O}(n^2)$</span><!-- Has MathJax -->，對不可變物件操作，其空間消耗量大，唯一個優勢是平行加速的擴充性。相反地，<code>collect</code> 則是逐一將元素納入一個集合，這樣一個簡單的合併操作，是沒辦法并行處理的，好處則是不會產生太多額外使用空間。</p><p>為了達到具拓展性且不失效能的設計，函數式編程那些獨特的數據結構和算法，或許能解決我們的問題。</p><h2 id="堆疊定義"><a href="#堆疊定義" class="headerlink" title="堆疊定義"></a>堆疊定義</h2><p>堆疊 Stack，主要有兩個操作：</p><ul><li><span>$\textit{push} \; (\textit{value})$</span><!-- Has MathJax -->：將一個元素 <span>$\textit{value}$</span><!-- Has MathJax --> 放置到堆頂</li><li><span>$\textit{pop} \; ()$</span><!-- Has MathJax -->：將堆頂元素移除</li></ul><p>課堂上總是會教資料結構，使用鏈結串列 (Linked List) 或者是陣列 (Array) 來實作，每一個操作皆為 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 常數。而持久化一個堆疊，我們將要針對改變結構內容的操作進行複製。</p><h2 id="可持久化堆疊定義"><a href="#可持久化堆疊定義" class="headerlink" title="可持久化堆疊定義"></a>可持久化堆疊定義</h2><p>可持久化堆疊 Stack 定義：</p><ul><li><span>$[\;]_{\textit{stack}} = \left \langle [\;] \right \rangle$</span><!-- Has MathJax --></li><li><span>$|\left \langle A \right \rangle| = |\left \langle \text{hd} \; A \right \rangle| + |\left \langle \text{tl} \; A \right \rangle|$</span><!-- Has MathJax --></li><li><span>$\textit{push} \; (\textit{e}, A) = \left \langle e : A \right \rangle$</span><!-- Has MathJax --></li><li><span>$\textit{pop} \; (A) = \left \langle \text{hd} \; A, \left \langle \text{tl} \; A \right \rangle \right \rangle$</span><!-- Has MathJax --></li></ul><p>上述的數學式</p><ul><li><span>$\text{hd}$</span><!-- Has MathJax --> 為堆疊的首元素。另一個使用術語為 <span>$\textit{car}$</span><!-- Has MathJax -->。</li><li><span>$\text{tl}$</span><!-- Has MathJax --> 為剔除首元素之後的結果。另一個使用術語為 <span>$\textit{cdr}$</span><!-- Has MathJax -->。從堆疊來看，即為回傳指向前一個節點的位置。</li><li><span>$:$</span><!-- Has MathJax --> 為串接操作。</li></ul><p>這一簡單結構，又被稱作為 list。只允許對堆頂操作的串列，這麼說很混淆，但在函數式設計中，他們通用的 list 就是這麼構造的，在後續的算法中，我們都用可持久化堆疊來表示 list。</p><p>以下述的例子，我們構造 4 個堆疊，每一個堆疊指向堆頂元素。對於加入一個元素到堆疊，我們就額外多一個節點指向先前的堆疊；相同地，移除堆頂元素時，回傳前一個堆疊結果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A = empty.push(X)    // [X]</div><div class="line">B = A.push(Y)        // [X, Y]</div><div class="line">C = B.push(Z)        // [X, Y, Z]</div><div class="line">D = B.push(W)        // [X, Y, W]</div></pre></td></tr></table></figure><p>相應的儲存圖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   A         B         C</div><div class="line">+--+-+    +--+-+    +--+-+</div><div class="line">|  |X&lt;----+  |Y&lt;----+  |Z|</div><div class="line">+--+-+    +--+^+    +--+-+</div><div class="line">              |</div><div class="line">              |        D</div><div class="line">              |     +--+-+</div><div class="line">              +-----+  |W|</div><div class="line">                    +--+-+</div></pre></td></tr></table></figure><p>此時，<span>$D$</span><!-- Has MathJax --> 進行 <span>$\textit{pop}$</span><!-- Has MathJax --> 操作，回傳值為 <span>$\left \langle W, B \right \rangle$</span><!-- Has MathJax -->。</p><p>最後，對於每一個操作在 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 時間內完成，需要額外的 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 空間。對於沒有垃圾回收 (Garbage Collection) 的語言實作上，需要維護參照數量 reference counter 來回收沒有用到的堆疊節點。</p><h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> persistent.stack;</div><div class="line"></div><div class="line"><span class="keyword">import</span> persistent.PStack;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> morrisy</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; The type of element</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">PStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PersistStack&lt;?&gt; EMPTY = <span class="keyword">new</span> PersistStack();</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">PersistStack&lt;T&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (PersistStack&lt;T&gt;) EMPTY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersistStack&lt;T&gt; next;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PersistStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PersistStack</span><span class="params">(T value, PersistStack&lt;T&gt; next, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.size = size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> PersistStack&lt;T&gt; <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> create();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isEmpty())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> PersistStack&lt;T&gt; <span class="title">push</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersistStack&lt;&gt;(value, <span class="keyword">this</span>, size + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> PersistStack&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span> ? next : create();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;在某些情況下，我們想要每次操作都能對應一個新的物件，即使變動當前的數據結構，也不影響前一次的數據結構。「可持久化 Persistent」一詞
      
    
    </summary>
    
      <category term="工作應用" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/"/>
    
      <category term="可持久化" scheme="http://morris821028.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%87%89%E7%94%A8/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
      <category term="可持久化" scheme="http://morris821028.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="stack" scheme="http://morris821028.github.io/tags/stack/"/>
    
      <category term="堆" scheme="http://morris821028.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
</feed>
