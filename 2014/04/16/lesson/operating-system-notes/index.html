<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>作業系統 筆記 (1) | Morris&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="讀物現在恐龍書不知道第幾版了，而且中文翻譯有點慘。看英文原文又太慢的情況，剛好查到聯合大學陳士杰教授寫的 ppt。繁體中文的說明，採用恐龍書第七版的內容。 下附章節簡報和課後習題解答。 稍微看過每一章的內容後，就可以著手看習題解答。 CH 1CH 2CH 3CH 4CH 5CH 6CH 7CH 8CH 9CH 10 恐龍書課後習題解答 感謝大大的提供 之前也有好幾次參照教授寫的中文簡報，相當有助益">
<meta name="keywords" content="作業系統">
<meta property="og:type" content="article">
<meta property="og:title" content="作業系統 筆記 (1)">
<meta property="og:url" content="http://morris821028.github.io/2014/04/16/lesson/operating-system-notes/index.html">
<meta property="og:site_name" content="Morris&#39; Blog">
<meta property="og:description" content="讀物現在恐龍書不知道第幾版了，而且中文翻譯有點慘。看英文原文又太慢的情況，剛好查到聯合大學陳士杰教授寫的 ppt。繁體中文的說明，採用恐龍書第七版的內容。 下附章節簡報和課後習題解答。 稍微看過每一章的內容後，就可以著手看習題解答。 CH 1CH 2CH 3CH 4CH 5CH 6CH 7CH 8CH 9CH 10 恐龍書課後習題解答 感謝大大的提供 之前也有好幾次參照教授寫的中文簡報，相當有助益">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://morris821028.github.io/img/test.jpg">
<meta property="og:updated_time" content="2016-04-20T11:50:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="作業系統 筆記 (1)">
<meta name="twitter:description" content="讀物現在恐龍書不知道第幾版了，而且中文翻譯有點慘。看英文原文又太慢的情況，剛好查到聯合大學陳士杰教授寫的 ppt。繁體中文的說明，採用恐龍書第七版的內容。 下附章節簡報和課後習題解答。 稍微看過每一章的內容後，就可以著手看習題解答。 CH 1CH 2CH 3CH 4CH 5CH 6CH 7CH 8CH 9CH 10 恐龍書課後習題解答 感謝大大的提供 之前也有好幾次參照教授寫的中文簡報，相當有助益">
<meta name="twitter:image" content="http://morris821028.github.io/img/test.jpg">
<link rel="publisher" href="108158678174364350000">
  
    <link rel="alternative" href="/atom.xml" title="Morris&#39; Blog" type="application/atom+xml">
  
  
    <meta name="google-site-verification" content="5mRgj8NanEMpGZuNfHNJNmH90RgNlrnJXsFlTaKD6Gs" />
  
  
    <link rel="shortcut icon" href="/img/f.ico">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <script src="/js/jquery-2.1.0.min.js"></script>
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="http://cdn.oesmith.co.uk/morris-0.5.1.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"></script>
<script src="http://cdn.oesmith.co.uk/morris-0.5.1.min.js"></script>
  <!-- <link rel="import" href="/bower_components/app-layout/app-layout.html"> --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"><div id="banner-right"></div></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Morris&#39; Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          
            <a class="main-nav-link" href="/"><i class=icon-home title='Home'></i></a>
          
        
          
            <a class="main-nav-link" href="/about"><i class=icon-user title='About'></i></a>
          
        
          
            <a class="main-nav-link" href="/archives"><i class=icon-archive title='Archives'></i></a>
          
        
          
            <a class="main-nav-link" href="/tags"><i class=icon-tags title='Tags'></i></a>
          
        
          
            <a class="main-nav-link" href="/picture"><i class=icon-camera title='Pictures'></i></a>
          
        
          
            <a class="main-nav-link" href="/works"><i class=icon-trophy title='Works'></i></a>
          
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://morris821028.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        
          
          <section id="main" style="width: 95%"><article id="post-lesson/operating-system-notes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/16/lesson/operating-system-notes/" class="article-date">
  <time datetime="2014-04-16T09:55:38.000Z" itemprop="datePublished">2014-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>/<a class="article-category-link" href="/categories/學校課程/作業系統/">作業系統</a>
  </div>

  </div>
  <div class="article-inner ">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="/img/test.jpg" rel="gallery_cksbltk5s02ampovnvu2yclvl">
        <img src="/img/test.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      作業系統 筆記 (1)
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2014/04/16/lesson/operating-system-notes/" data-id="cksbltk5s02ampovnvu2yclvl" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2014/04/16/lesson/operating-system-notes/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/作業系統/">作業系統</a></li></ul>

    </footer>
    <div class="article-entry " itemprop="articleBody">
      
          
              <div id="toc" class="toc-article">
              <h2 class="toc-title"><span>contents</span></h2>
              
                  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#讀物"><span class="toc-number">1.</span> <span class="toc-text">讀物</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可能遭遇的問題"><span class="toc-number">2.</span> <span class="toc-text">可能遭遇的問題</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Round-Robin-Scheduling"><span class="toc-number">2.1.</span> <span class="toc-text">Round-Robin Scheduling</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#考古題-課本後習題"><span class="toc-number">3.</span> <span class="toc-text">考古題(課本後習題)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#95-期中考"><span class="toc-number">3.1.</span> <span class="toc-text">95 期中考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-期中考"><span class="toc-number">3.2.</span> <span class="toc-text">96 期中考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#課本習題快取區"><span class="toc-number">4.</span> <span class="toc-text">課本習題快取區</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ch-5"><span class="toc-number">4.1.</span> <span class="toc-text">ch 5</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">5.</span> <span class="toc-text">Reference</span></a></li></ol>
              
              </div>
          
        
          <h1 id="讀物"><a href="#讀物" class="headerlink" title="讀物"></a>讀物</h1><p>現在恐龍書不知道第幾版了，而且中文翻譯有點慘。看英文原文又太慢的情況，剛好查到聯合大學陳士杰教授寫的 ppt。繁體中文的說明，採用恐龍書第七版的內容。</p>
<p>下附章節簡報和課後習題解答。</p>
<p>稍微看過每一章的內容後，就可以著手看習題解答。</p>
<p><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_1.pdf" target="_blank" rel="external">CH 1</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_2.pdf" target="_blank" rel="external">CH 2</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_3.pdf" target="_blank" rel="external">CH 3</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_4.pdf" target="_blank" rel="external">CH 4</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_5.pdf" target="_blank" rel="external">CH 5</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_6.pdf" target="_blank" rel="external">CH 6</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_7.pdf" target="_blank" rel="external">CH 7</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_8.pdf" target="_blank" rel="external">CH 8</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_9.pdf" target="_blank" rel="external">CH 9</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_10.pdf" target="_blank" rel="external">CH 10</a></p>
<p><a href="/file/os.zip">恐龍書課後習題解答</a> 感謝大大的提供</p>
<p>之前也有好幾次參照教授寫的中文簡報，相當有助益。</p>
<h1 id="可能遭遇的問題"><a href="#可能遭遇的問題" class="headerlink" title="可能遭遇的問題"></a>可能遭遇的問題</h1><p><strong> 個人拙見，請自行過濾 </strong></p>
<h2 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h2><ul>
<li>這個問題在寫考題的時候，略顯著的疑惑。</li>
<li>對於 Round-Robin Scheduling 的部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">queue Q</div><div class="line">while(true) &#123;</div><div class="line">    w = Q.front()</div><div class="line">    w = work(w)</div><div class="line">    if(hasProcess())</div><div class="line">        Q.push(nextPorcess())</div><div class="line">    if(w != null)</div><div class="line">        Q.push(w)</div><div class="line">    time++</div><div class="line">&#125;</div></pre></td></tr></table></figure>
詳見代碼後，由於超過時限後，還要將變數存起來，所以丟入 queue 的時間會晚一點，也就是說在同一時刻會慢於新抵達的 process。之後的程序就按照 queue 的順序去運行。</li>
</ul>
<h1 id="考古題-課本後習題"><a href="#考古題-課本後習題" class="headerlink" title="考古題(課本後習題)"></a>考古題(課本後習題)</h1><p>(=ﾟωﾟ)= <strong> 下附解答僅個人拙見，請勿隨意採信，請發揮您的善心，救救笨蛋 </strong></p>
<h2 id="95-期中考"><a href="#95-期中考" class="headerlink" title="95 期中考"></a>95 期中考</h2><ul>
<li><p>What is multiprogramming ? what is time-sharing ?(10%)</p>
<ul>
<li><p>Multiprogramming(多重程式)：</p>
<ul>
<li>定義：<br>內存有多個 processs 同時執行，一般電腦的運行方式。透過 CPU scheduling 將發生中斷 (eg. wait for I/O complete, resource not available, etc.) 的行程切換給可執行的運作。</li>
<li>特色：<br>可以避免 CPU idle，提高 CPU utilization(使用率)</li>
<li>其他：<ol>
<li>Multiprogramming Degree：系統內存在執行的 process 數目</li>
<li>通常 Multiprogramming Degree 越高，則 CPU utilization 越高(p.s. ch7 Thrashing 除外)</li>
<li>多個 process 同時執行，mode 有兩種 Concurrent(並行)、Parallel(平行)</li>
</ol>
</li>
</ul>
</li>
<li><p>Time-sharing:</p>
<ul>
<li>定義：<br>Multiprogramming 的一種，在 CPU 排班法則方面，其使用 RR(Round-Robin) 法則。<br>// RR 法則－CPU time quantum，若 process 在取得 CPU 後，未能於 quantum<br>// 內完成工作，則必須被迫放棄 CPU，等待下一次輪迴。</li>
<li>特色：<br>對每個 user 皆是公平的，適用在 user interactive 且 response time (反應時間)要求較短的系統環境，透過 resource sharing 技術(eg. CPU scheduling, memory sharing, spooling 達到 I/O Device 共享)，使得每個user皆認為有專屬的系統存在。</li>
</ul>
</li>
</ul>
</li>
<li><p>Describe the differences between symmetric and asymmetric multiprocessing. What are three advantages and one disadvantage of multiprocessor systems ?<br>  In Distributed System - Multiprocessor - Tightly-Coupled System(different from Loosely-Coupled Distributed System)</p>
<ul>
<li>Symmetric Multiprocessors (SMP) 對稱式多處理器 <ul>
<li>定義：<br>每個 processor 的能力皆相同，即可負責的功能完全一樣。萬一某個 processor 壞了，其上工作可由其他processor 接手，系統不會整個 crash，只是整體效能下降而已。</li>
<li>特色：<br>Reliability (可靠性)大幅提升，強調 load balancing (負載平衡)(每個CPU的工作負擔相同)</li>
</ul>
</li>
<li>Asymmetric Multiprocessors (ASMP) 非對稱式多處理器 <ul>
<li>定義：<br>不同(群)顆的 processor，其負擔的功能不盡相同，在此架構下，通常含有一個Master CPU，負責工作的分派與協調，其他 CPUs 稱為 Slave CPU (稱為 Master-Slave Architecture)</li>
<li>特色：<br>效能通常較SMP高，但可靠度較差 </li>
</ul>
</li>
</ul>
</li>
<li>What are the differences between a trap and an interrupt? What is the use of each function ?<ul>
<li>Trap:<br>軟體產生 system call<br>an exception in a user process.<br>ex. system call (software divide-by-zero)</li>
<li>Interrupt:<br>硬體產生 signal<br>something generated by the hardware.<br>ex. IO-complete interrupt (hardware generated)</li>
<li>兩者相同之處<br>從 User Mode 切換到 Kernel Mode。<br>兩者都算是 interrupt 中斷指令。</li>
</ul>
</li>
<li>What is the purpose of system calls?<br>  System calls allow user-level processes to request services of the operating system.<br>  System calls 提供 <strong> 使用者級別 </strong> 的程序來請求作業系統給的服務。<br>  // process control, file Management, device management, information maintenance, communication</li>
<li>Describe the differences among short-term, medium-term, and long-term scheduling.<ul>
<li>short-term (CPU scheduler) —<br>CPU 工作排程<br>selects from jobs in memory those jobs that are ready to execute and allocates the CPU to them.</li>
<li>medium-term —<br>常用於分時系統的排程器。當記憶體不夠的時候，需要暫時將部分的執行程序搬出，將新來的程序載入，置換機制被建置用來移除部份在記憶體執行中及恢復那些被暫時移除的程式。<br>used especially with time-sharing systems as an intermediate scheduling level. A swapping scheme is implemented to remove partially run programs from memory and reinstate them later to continue where they left off.</li>
<li>long-term (job scheduler) —<br>將 job 變成 process 的工作排程，將工作從硬碟載入到主記憶體中。<br>determines which jobs are brought into memory for processing.</li>
</ul>
</li>
<li>Can a multithreaded solution using multiple user-level threads achieve better performance on a multiprocessor system than on a single-processor system? Why?<ul>
<li>A multithreaded system comprising of multiple user-level threads cannot make use of the different processors in a multiprocessor system simultaneously. The operating system sees only a single process and will not schedule the different threads of the process on separate processors. Consequently, there is no performance benefit associated with executing multiple user-level threads on a multiprocessor system.</li>
<li>以 user-level hreads 實現 multithread 的程式，在多處理器系統中不能比在單處理機系統中有更好的效率， 因在多處理機系統中之作業系統不會將多個 CPU 同時分配給該 user-level multithread 程式。</li>
</ul>
</li>
<li><p>Consider the following set of processes, with the length of the CPU-burst time given in milliseconds:</p>
<pre><code>Process           Burst Time         Priority
  P1                 10                  3
  P2                  1                  1
  P3                  2                  3
  P4                  1                  4
  P5                  5                  2
</code></pre><p>The processes are assumed to have arrived in the order P1,P2,P3,P4,P5, all at time 0.</p>
<ul>
<li>(a) Draw four Gantt charts illustrating the execution of these processes using FCFS, SJF, a nonpreempitive priority(a small priority number implies a higher priority), and RR(quantum = 1) scheduling.(5%)</li>
<li>(b) What is the turnaround time of each process for each of the scheduling algorithms in part(a).(5%)</li>
<li>(c) What is the waiting time of each process for each of the scheduling algorithms in part(a).(5%)</li>
<li><p>(d) Which of the schedules in part (a) results in the minimal average waiting time(over all processes)? (5%)</p>
<pre><code>請參照上附的習題解法。
</code></pre><p><img src="/img/operation-system-5.12sol.PNG" alt="5.12 solution"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="96-期中考"><a href="#96-期中考" class="headerlink" title="96 期中考"></a>96 期中考</h2><ul>
<li><p>FCFS, SJF, Priority, Round-Robin and Multilevel Queue<br>Which can be preemptive ? (5%)</p>
<ul>
<li>preemptive 可搶先<br>SRTF (剩餘最短優先)、Priority (優先權優先)、Multilevel Queue (多層佇列)、RR</li>
<li>non-preemptive 不可搶先<br>FCFS (先到先服務)、SJF (最短工作優先)、Priority (優先權優先)</li>
<li>Priority (優先權優先) 屬於可搶先跟不可搶先。</li>
<li>可搶先的定義為非自願性被踢出 CPU。</li>
</ul>
</li>
<li><p>What are the four main purposes of an operating system ? (10%)</p>
<ul>
<li>Managing programs</li>
<li>Managing Memory</li>
<li>Handling input and output</li>
<li>User Interface</li>
</ul>
</li>
<li><p>Please give a detail description on the differences among the terms multiprocessing, multitasking and multithreading. (15%)</p>
<ul>
<li>multiprocessing<br>具有多個處理器，在同一時間可以在各自處理器上運行程序。</li>
<li>multitasking<br>執行單一使用者的多個行程，利用排程器讓每一個行程都在平均時間內解決。</li>
<li>multithreading<br>可以將程序切成好幾個執行緒，若硬體可以同時執行多個執行緒，效率將會上升，如果不能，由於速度夠快看起來也很像多個執行緒同時運行。</li>
</ul>
</li>
<li><p>What are the differences between a trap and an interrupt ? What is the use if each function ? (20%)</p>
<ul>
<li>Trap:<br>軟體產生 system call<br>an exception in a user process.<br>ex. system call (software divide-by-zero)</li>
<li>Interrupt:<br>硬體產生 signal<br>something generated by the hardware.<br>ex. IO-complete interrupt (hardware generated)</li>
<li>兩者相同之處<br>從 User Mode 切換到 Kernel Mode。<br>兩者都算是 interrupt 中斷指令。</li>
</ul>
</li>
<li><p>What is the purpose of system calls, Please describe three general methods that be used to pass parameters to the operating system. (10%).</p>
<ul>
<li>System call 由作業系統提供 API interface 給 user program，可以藉由 system call 向作業系統請求服務，作業系統接收到請求後，執行完報告結果給 user program。</li>
<li>[方法1] Registers<br>  利用Registers ( 暫存器 )儲存這些參數<br>  優：速度快<br>  (∵不用作記憶體的存取 )<br>  缺：不適用於參數個數多的情況</li>
<li>[方法2] Memory<br>  將參數利用 Table 或 Block 的方式儲存在 Memory 中，同時利用一個 Register 記錄此 Table 或 Block 的起始位址，並傳給O.S.<br>  優：適用於參數個數較多的情況<br>  缺：速度慢</li>
<li>[方法3] Stack<br>  利用System Stack (堆疊 )。要存放參數時，將之Push 到Stack Stack， 再由O.S.從Stack中Pop 取出參數 。<br>  Stack在系統中比Register多一些(可用Mem. 或其它硬體(如：Register)來實作此Stack)</li>
</ul>
</li>
<li><p>What is a process ? Draw the diagram of Process State. And describe every state. (15%)<br><img src="/img/ProcessState.PNG" alt="process state"></p>
</li>
<li><p>What are the differences between thread and process ? Why do threads have much shorter context switching times ? (10%)</p>
<pre><code>|        Thread                   |      Process              |
|---------------------------------|---------------------------|
| Light Weight Process            | Heavy Weight Process      |
|                                 |                           |
| 同一個Task (或 Process ) 內的   |  不同的Process之間無共享的| 
| Threads可以共享 Code Section,   |  Address Space，互為獨立。|
| Data Section, 及O.S. Resources  |                           |
|                                 |
| Context Switching 負擔輕        |  負擔重
|                                 |
| Thread的管理(Management)成本低  |  成本高
| (管理項目： Creation,           |
| Scheduling, Context, Switching  |
| Switching…etc.)                 |
|                                 |
| 一個Task內有多條Threads存在     |  一個Task內只有一條Thread
|  Process (Task) 內的某 Thread   |
| 被 Block，則可切到其它Thread    |
| 執行。此時，若 Process 內只要還有
| Thread 在執行，則 Process 不會被 Block
</code></pre></li>
<li><p>What is Multilevel Feedback-Queue scheduling ? (5%)</p>
<pre><code>定義：
與Multilevel Queue的定義相似，差別在於允許 Process 在各佇列之間移動 ，以避免Starvation 的情況。
* 採取類似 “Aging” 技術，毎隔一段時間就將 Process 往上提升到上一層 Queue 中。∴在經過有限時間後，在 Lower Priority Queue 中的 Process 會被置於 Highest Priority Queue 中。故無 Starvation。
* 亦可配合降級之動作。當上層 Queue 中的 Process 取得 CPU 後，若未能在 Quantum 內完成工作，則此 Process 在放棄 CPU 後，會被置於較下層的 Queue 中。
</code></pre></li>
<li><p>Please draw the Gantt charts for the following processes for the problems shown below.<br>  (a) Round-Robinm time quantum = 1 (5%)<br>  (b) Shortest-remaining-time-first (Preemptive SJF) (5%)</p>
<pre><code>            Arrival Time    Brust Time

    P1      0               4
    P2      1               2
    P3      2               3
    P4      5               4
    P5      6               3

(a) Time : 0
    Queue: P1

    0   1
    +---+
      P1

    先丟入 P2, P1 因為超時丟入，此時執行 P2
    Time : 1
    Queue: P2, P1

    0   1   2
    +---+---+
     P1  P2

    丟入 P3, P2 因為超時丟入，此時執行 P1
    Time : 2
    Queue: P1, P3, P2

    0   1   2   3
    +---+---+---+
     P1  P2  P1

    P1 因為超時丟入，此時執行 P3
    Time : 3
    Queue: P3, P2, P1

    0   1   2   3   4
    +---+---+---+---+
     P1  P2  P1  P3

    P3 因為超時丟入，此時執行 P2
    Time : 4
    Queue: P2, P1, P3

    0   1   2   3   4   5
    +---+---+---+---+---+
     P1  P2  P1  P3  P2

    P2 完成，P4 抵達丟入，此時執行 P1
    Time : 5
    Queue: P1, P3, P4

    0   1   2   3   4   5   6
    +---+---+---+---+---+---+
     P1  P2  P1  P3  P2  P1

    P5 抵達丟入，P1 超時丟入，此時執行 P3
    Time : 6
    Queue: P3, P4, P5, P1

    0   1   2   3   4   5   6   7
    +---+---+---+---+---+---+---+
     P1  P2  P1  P3  P2  P1  P3

    P3 超時丟入，此時執行 P4
    Time : 7
    Queue: P4, P5, P1, P3

    0   1   2   3   4   5   6   7   8
    +---+---+---+---+---+---+---+---+
     P1  P2  P1  P3  P2  P1  P3  P4

    P4 超時丟入，此時執行 P5
    Time : 8
    Queue: P5, P1, P3, P4

    0   1   2   3   4   5   6   7   8   9
    +---+---+---+---+---+---+---+---+---+
     P1  P2  P1  P3  P2  P1  P3  P4  P5

    P5 超時丟入，此時執行 P1
    Time : 6
    Queue: P1, P3, P4, P5

    0   1   2   3   4   5   6   7   8   9  10
    +---+---+---+---+---+---+---+---+---+---+
     P1  P2  P1  P3  P2  P1  P3  P4  P5  P1

    P1 完成，此時執行 P3
    Time : 10
    Queue: P3, P4, P5

    0   1   2   3   4   5   6   7   8   9  10  11
    +---+---+---+---+---+---+---+---+---+---+---+
     P1  P2  P1  P3  P2  P1  P3  P4  P5  P1  P3

    P3 完成，此時執行 P4
    Time : 11
    Queue: P4, P5

    0   1   2   3   4   5   6   7   8   9  10  11  12
    +---+---+---+---+---+---+---+---+---+---+---+---+
     P1  P2  P1  P3  P2  P1  P3  P4  P5  P1  P3  P4

    ...

    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     P1  P2  P1  P3  P2  P1  P3  P4  P5  P1  P3  P4  P5  P4  P5  P4
</code></pre></li>
</ul>
<hr>
<h1 id="課本習題快取區"><a href="#課本習題快取區" class="headerlink" title="課本習題快取區"></a>課本習題快取區</h1><h2 id="ch-5"><a href="#ch-5" class="headerlink" title="ch 5"></a>ch 5</h2><ul>
<li>5.9 Why is it important for the scheduler to distinguish I/O-bound programs<br>from CPU-bound programs?<br>為什麼排程器需要需分 <strong> IO 密集程式 </strong> 和 <strong> CPU 綁定程式 </strong> ?</li>
</ul>
<blockquote><p>Answer: I/O-bound programs have the property of performing only a small amount of computation before performing I/O. Such programs typically do not use up their entire CPU quantum. CPU-bound programs, on the other hand, use their entire quantum without performing any blocking I/O operations. Consequently, one could make better use of the computer’s resouces by giving higher priority to I/O-bound programs and allow them to execute ahead of the CPU-bound programs.<br>IO 密集程式占用 CPU 的時間比較少，大部分時間等在等待 IO。相反地 CPU 綁定程式則會大幅度占用 CPU 的時候，因為沒有 IO 操作的堵塞。</p>
<p>而 CPU bound 的程序因此而得到了很多調度機會並且每次都能把CPU run完。故在這樣的系統裡要給 I/O bound 的程序更高的優先級使其能被調度得更多些。</p>
</blockquote>
<ul>
<li>5.10 Discuss how the following pairs of scheduling criteria conflict in certain<br>settings.<br>a. CPU utilization and response time // CPU 使用率 和 回應時間 的比較<br>b. Average turnaround time and maximum waiting time // 平均運轉時間 和 最大等待時間 的比較<br>c. I/O device utilization and CPU utilization // IO 裝置使用率 和 CPU 使用率 的比較</li>
</ul>
<blockquote><p>Answer:<br>a. CPU utilization and response time: CPU utilization is increased if the overheads associatedwith context switching isminimized. The context switching overheads could be lowered by performing context switches infrequently. This could, however, result in increasing<br>the response time for processes.<br>CPU 的使用率(utilization)上升時，切換工作的次數(context-switches)就會少，由於切換次數少，則回應時間(response time)就會上升。</p>
<p>b. Average turnaround time and maximum waiting time: Average turnaround time is minimized by executing the shortest tasks first. Such a scheduling policy could, however, starve long-running tasks and thereby increase their waiting time.<br>平均運作時間(average turnaround time) 的最小化可以藉由最短工作優先的方式，但是這將會使得長工作飢餓，如此會增加最大等待時間。</p>
<p>c. I/O device utilization and CPU utilization: CPU utilization is maximized by running long-running CPU-bound tasks without performing context switches. I/O device utilization is maximized by scheduling I/O-bound jobs as soon as they become ready to run, thereby incurring the overheads of context switches.<br>CPU 使用率的上升盡可能讓 CPU 密集工作長時間運行 (減少 IO 或者其他的中斷所引發的上下文切換)，IO 裝置使用率的上升靠的是讓排入的 IO 密集工作立即地運行，但這會增加上下文切換的開銷。</p>
</blockquote>
<ul>
<li>5.11 Consider the exponential average formula used to predict the length of the next CPU burst.What are the implications of assigning the following values to the parameters used by the algorithm?<br>使用指數平均公式去預測下一次的 CPU burst。 t0 預估時間。<br>a. a = 0 and t0 = 100 milliseconds<br>b. a = 0.99 and t0 = 10 milliseconds</li>
</ul>
<blockquote><p>Answer: When a = 0 and t0 = 100 milliseconds, the formula always makes a prediction of 100 milliseconds for the next CPU burst. When a = 0.99 and t0 = 10 milliseconds, themost recent behavior of the process is given much higher weight than the past history associated with the process. Consequently, the scheduling algorithm is almost memoryless, and simply predicts the length of the previous burst for the next quantum of CPU execution.<br>當 a = 0 時，預測的時間總會是 100 milliseconds，而當 a = 0.99 時，將會高度依賴近期幾次的結果，而對於歷史關聯只有較輕的權重。<br>// t(n+1) = a * 上一次實際時間 + (1 - a) * t(n)</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.ptt.cc/bbs/b97902HW/M.1267018497.A.3B1.html" target="_blank" rel="external">Kernel Mode 與 User Mode 的概念</a><br><a href="http://sjchen.im.nuu.edu.tw/OS/97Spring/Ch_4.pdf" target="_blank" rel="external">恐龍書中文 ppt 介紹 聯合大學 陳士杰</a></p>

        
      
    </div>

  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/04/17/test/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Scarky 您的博客線上檢測系統
        
      </div>
    </a>
  
  
    <a href="/2014/04/15/web/nodejs-first-learn/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Nodejs 初學上手</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
          
          
        
      </div>
      <footer id="footer">
  
  <div class="outer">    
    <div class="social-group">
      
      <a href="https://github.com/morris821028" target="_blank" title="github"><i class="icon-github"></i></a>
      
      
      <a href="https://www.facebook.com/Morris1028" target="_blank" title="facebook"><i class="icon-facebook-sign"></i></a>
      
      
      <a href="http://uhunt.felix-halim.net/id/46705" target="_blank" title="uhunt" ><span class="icon-uhunt">UVa<span></a>
      
    </div>
    <div id="footer-info" class="inner">
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/morris821028/hexo-theme-landscape" target="_blank" title="landscape">landscape</a> &copy; 2021 Shiang-Yun Yang 
    </div>
  </div>
</footer>


    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link"><i class=icon-home ></i>&nbsp&nbspHome</a>
  
    <a href="/about" class="mobile-nav-link"><i class=icon-user ></i>&nbsp&nbspAbout</a>
  
    <a href="/archives" class="mobile-nav-link"><i class=icon-archive ></i>&nbsp&nbspArchives</a>
  
    <a href="/tags" class="mobile-nav-link"><i class=icon-tags ></i>&nbsp&nbspTags</a>
  
    <a href="/picture" class="mobile-nav-link"><i class=icon-camera ></i>&nbsp&nbspPictures</a>
  
    <a href="/works" class="mobile-nav-link"><i class=icon-trophy ></i>&nbsp&nbspWorks</a>
  
</nav>
    
<script>
  var disqus_shortname = 'morris1028';
  
  var disqus_url = 'http://morris821028.github.io/2014/04/16/lesson/operating-system-notes/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/jquery.lazyload.js"></script>
<script src="/js/jquery.als-1.6.js"></script>

<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>