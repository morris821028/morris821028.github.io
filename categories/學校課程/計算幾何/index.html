<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Category: 計算幾何 | Morris&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Morris&#39; Blog">
<meta property="og:url" content="http://morris821028.github.io/categories/學校課程/計算幾何/index.html">
<meta property="og:site_name" content="Morris&#39; Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Morris&#39; Blog">
<link rel="publisher" href="108158678174364350000">
  
    <link rel="alternative" href="/atom.xml" title="Morris&#39; Blog" type="application/atom+xml">
  
  
    <meta name="google-site-verification" content="5mRgj8NanEMpGZuNfHNJNmH90RgNlrnJXsFlTaKD6Gs" />
  
  
    <link rel="shortcut icon" href="/img/f.ico">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <script src="/js/jquery-2.1.0.min.js"></script>
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="http://cdn.oesmith.co.uk/morris-0.5.1.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"></script>
<script src="http://cdn.oesmith.co.uk/morris-0.5.1.min.js"></script>
  <!-- <link rel="import" href="/bower_components/app-layout/app-layout.html"> --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"><div id="banner-right"></div></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Morris&#39; Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          
            <a class="main-nav-link" href="/"><i class=icon-home title='Home'></i></a>
          
        
          
            <a class="main-nav-link" href="/about"><i class=icon-user title='About'></i></a>
          
        
          
            <a class="main-nav-link" href="/archives"><i class=icon-archive title='Archives'></i></a>
          
        
          
            <a class="main-nav-link" href="/tags"><i class=icon-tags title='Tags'></i></a>
          
        
          
            <a class="main-nav-link" href="/picture"><i class=icon-camera title='Pictures'></i></a>
          
        
          
            <a class="main-nav-link" href="/works"><i class=icon-trophy title='Works'></i></a>
          
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://morris821028.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        
          
          <section id="main">
  
    <article id="post-lesson/geometry-hw5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/28/lesson/geometry-hw5/" class="article-date">
  <time datetime="2014-12-28T00:56:01.000Z" itemprop="datePublished">2014-12-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>/<a class="article-category-link" href="/categories/學校課程/計算幾何/">計算幾何</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/28/lesson/geometry-hw5/">計算幾何 - HW05</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2014/12/28/lesson/geometry-hw5/" data-id="cksbltk4n0298povnfcs7uysh" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2014/12/28/lesson/geometry-hw5/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/計算幾何/">計算幾何</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="Chapter-10"><a href="#Chapter-10" class="headerlink" title="Chapter 10"></a>Chapter 10</h2><h3 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h3><p>In Section 10.1 we solved the problem of finding all horizontal line segments in a set that intersect a vertical segment. For this we used an interval tree with priority search trees as associated structures. There is also an alternative approach. We can use a 1-dimensional range tree on the y-coordinate of the segments to determine those segments whose y-coordinate lies in the y-range of the query segment. The resulting segments cannot lie above or below the query segment, but they may lie completely to the left or to the right of it. We get those segments in O(logn) canonical subsets. For each of these subsets we use as an associated structure an interval tree on the x-coordinates to find the segments that actually intersect the query segment.</p>
<p>a. Give the algorithm in pseudocode.<br>b. Prove that the data structure correctly solves the queries.<br>c. What are the bounds for preprocessing time, storage, and query time of this structure? Prove your answers.</p>
<p>給 n 個水平線段，詢問垂直的線段與那些水平線段有相交，輸出所有有相交的線段。</p>
<p>a. Algorithm:</p>
<ol>
<li>對 n 個線段建造 interval tree，使用課本上 CONSTRUCTINTERVALTREE(l) 的做法。</li>
<li>對 interval tree 上每一個 node 建造 Priority Search Tree，node 依照 x 劃分，分別對 node.x 的左右兩側建造 PST，距離 node.x 越遠的端點，其優先權越高，左右子樹依照 y-value 分兩堆。</li>
<li>詢問調用 QUERYINTERVALTREE(v, qx)，得到相對應的 ndoe 後，查找每個 node 下的 Priority Search tree 與線段相交，調用 QUERYPRIOSEARCHTREE()。</li>
</ol>
<p>b. Prove that the data structure correctly solves the queries.<br>上述的作法與 axis-parallel rectangular query window 相同。而此問題的詢問是 axis-parallel rectangular query window 的 subset，一個線段的詢問是 <em> qx = qx’</em> 的情況，故得證。</p>
<p>c. What are the bounds for preprocessing time, storage, and query time of this structure? Prove your answers.</p>
<p>preprocessing time : <strong><em> O(n log n) </em></strong><br>store space : <strong><em> O(n) </em></strong><br>query time : <strong><em> O(log n + k) </em></strong></p>
<p>前處理因 interval tree 最慘 <em> T(n) = 2 T(n/2) + O(n) </em>，建造 PST 只需要 <em> O(n) </em>，每個線段最多在兩個 PST 中，得到記憶體空間最多為 <em> O(n) </em>。詢問最多為 interval tree 的深度 <em> O(log n) </em></p>
<h3 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h3><p>Let P be a set of n points in the plane, sorted on y-coordinate. Show that, because P is sorted, a priority search tree of the points in P can be constructed in <em> O(n) </em> time.</p>
<p>類似 bottom0up heap construction，已知 bottom-up heap 可在 O(n) 時間內完成。</p>
<p>假設最後的樹高 H，第 i 次的 bottom-up 會調整 2<sup>H-i</sup> 個元素，每個元素最多下降 i 層。則</p>
<span>$$O(\sum_{i = 1}^{H} i \times 2^{H-i}) = O(1 \times 2^{H-1} + 2 \times 2^{H-2} + ... ) \\
= O((2^{H-1} + 2^{H-2} + ... + 1) + (2^{H-2} + 2^{H-3} + ... + 1) + ...) \\
= O(2^{H} + 2^{H-1} + ... + 1) = O(2^{H+1}) = O(n)$$</span><!-- Has MathJax -->
<p>雖然要求左右子樹的 y 值要符合左小、右大，但由於已經根據 y 排好，bottom-up 時，保證調整的 shiftdown 操作會符合其性質。</p>
<h3 id="10-6"><a href="#10-6" class="headerlink" title="10.6"></a>10.6</h3><p>Let I be a set of intervals on the real line. We want to be able to count the number of intervals containing a query point in O(logn) time. Thus, the query time must be independent of the number of segments containing the query point.</p>
<p>a. Describe a data structure for this problem based on segment trees, which uses only O(n) storage. Analyze the preprocessing time, and the query time of the data structure.<br>b. Describe a data structure for this problem based on interval trees. You should replace the lists associated with the nodes of the interval tree with other structures. Analyze the amount of storage, preprocessing time, and the query time of the data structure.<br>c. Describe a data structure for this problem based on a simple binary search tree. Your structure should have O(n) storage and O(logn) query time. (Hence, segment trees are actually not needed to solve this problem efficiently.)</p>
<p>有 n 個 [l<sub>i</sub>, r<sub>i</sub>]，詢問一個點 x 被多少個區間包含，輸出為一個整數。</p>
<p>a. 使用 segment tree 儲存所有的 interval。</p>
<p>對於其 node(u) 會 cover(l, r) 的區間，紀錄有多少區間 cover(l, r)，最多有 <em> 2n </em> 個葉節點，樹節點最多 <em> 4n </em> 個，每個 node 只有一個額外的整樹紀錄區間個數。然而一個區間最多被拆分 <em> O(log n) </em> 個，依序插入需消耗共計 <em> O(n log n) </em> 時間。</p>
<p>preprocessing time : <strong><em> O(n log n) </em></strong><br>query time : <strong><em> O(log n) </em></strong><br>store space : <strong><em> O(n) </em></strong></p>
<p>b. 使用 inteerval tree 處理 interval。</p>
<p>對於每個 node 分別對左右兩側建造平衡樹，這個平衡樹要支持某數字是第 k 大或第 k 小的操作。對於一個 node 而言，會有數個區間交 node.x，假設詢問點 qx 在 node.x 左側，則根據左側的平衡樹，查找 qx 是第 k 小，用以回報個數。每一個區間對多在 2 個平衡樹中，故空間複雜度為 <em> O(n) </em>。</p>
<p>preprocessing time : <strong><em> O(n log n) </em></strong><br>query time : <strong><em> O(log<sup>2</sup> n) </em></strong><br>store space : <strong><em> O(n) </em></strong></p>
<p>c. 使用 simple binary search tree。</p>
<ol>
<li>將 n 個線段的端點，共計 2n 個丟入 binary search tree。</li>
<li>每一個 node 紀錄有多少個區間包含它，如果 node 是某個線段的右端點，則無視此區間的包含情況。</li>
<li>對於每個詢問 qx，輸出 node = lower_bound(qx) 的包含結果。</li>
</ol>
<p>將所有端點排序後，會得到 [a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, …, a<sub>2n</sub>]，每一個 node 的資訊是 [a<sub>i</sub>, a<sub>i+1</sub>) 的區間包含訊息。簡單地說，切成最小塊的相鄰資訊，與 segment tree 反過來的概念。</p>
<p>前處理使用 line sweep algorithm 掃描線算法，來找到每一個端點被多少個線段包含。掃描線算法需要 <em> O(n log n) </em>，binary search tree 只需要 <em> O(n) </em>，查找 lower_bound 只需要 <em> O(log n) </em>，保證最多 2n 個端點，樹最多使用 <em> O(n) </em> 個空間。</p>
<p>preprocessing time : <strong><em> O(n log n + n) = O(n log n) </em></strong><br>query time : <strong><em> O(log n) </em></strong><br>store space : <strong><em> O(n) </em></strong></p>
<h3 id="10-7"><a href="#10-7" class="headerlink" title="10.7"></a>10.7</h3><p>a. We want to solve the following query problem: Given a set S of n disjoint line segments in the plane, determine those segments that intersect a vertical ray running from a point (qx,qy) vertically upwards to infinity. Describe a data structure for this problem that uses O(nlogn) storage and has a query time of O(logn+k), where k is the number of reported answers.<br>b. Now suppose we only want to report the first segment hit by the query ray. Describe a data structure for this problem with O(n) expected storage and O(logn) expected query time. Hint: Apply the locus approach</p>
<p>給定 n 個不相交的線段，詢問一點開始的射線，射線方向向 y 軸正向，輸出所有交到的線段。</p>
<p>a. 使用 segment tree，依照所有的端點的 x 值，接著對於每個 node 建造以 y 值得 binary search tree，儲存數個線段，因為不相交，保證 binary search tree 在 [xl, xr] 區間的所有線段都是單調的。每個線段最多切成 <em> O(log n) </em>，故使用空間 <em> O(n log n) </em>，詢問 <em> O(log n + k) </em>，只須訪問 <em> O(log n) </em> 個節點，從 binary tree tree 最遠的開始往下輸出即可。</p>
<p>b. 只找第一個碰到的線段，使用 trapezoidal map 找到 point location，走訪 DG 其最後一個 segment below 的情況就是輸出結果。已知 trapezoidal map 在隨機增量算法中，expected size of search structure <em> O(n) </em>，expected query time <em> O(log n) </em>。</p>
<h2 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h2><h3 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h3><p>In Chapter 1 we defined the convex hull of a set P of points as the intersection of all convex sets containing the points. In the current chapter we saw another definition: the convex hull of P is the set of all convex combinations of the points in P. Prove that these two definitions are equivalent, that is, prove that a point q is a convex combination of points in P if and only if q lies in every convex set containing P.</p>
<p>首先 convex combinations 指得是<span>$q = \sum_{i = 1}^{n} \lambda_{i} p_{i}, \lambda_{i} \geq 0, \sum_{i = 1}^{n} \lambda_{i} = 1$</span><!-- Has MathJax -->，證明 q 會在所有的凸包集中，也就是 q 點相當於任抓幾點出來，會在這幾點形成的凸包中，公式計算類似物理上的質心計算。</p>
<p>(=&gt;)<span>$q = \sum_{i = 1}^{n} \lambda_{i} p_{i}, \lambda_{i} \geq 0, \sum_{i = 1}^{n} \lambda_{i} = 1$</span><!-- Has MathJax -->. Prove q lies in every convex set containing P.</p>
<ul>
<li>Base :  <span>$n = 2, q = \lambda_{1} p_{1} + \lambda_{2} p_{2}$</span><!-- Has MathJax -->, q lies on segment p<sub>1</sub>p<sub>2</sub>, which must be a subset of every convex set containing p<sub>1</sub>, p<sub>2</sub>.</li>
<li>Suppose:  <span>$n \le k$</span><!-- Has MathJax --> 均成立，當 <em> n = k + 1 </em> 時<span>$\lambda_{k+1} = 0$</span><!-- Has MathJax --> 必定成立。  </li>
</ul>
<span>$$\begin{align}
&amp; q = \lambda_{1} p_{1} + \lambda_{2} p_{2} + ... + \lambda_{k} p_{k} + \lambda_{k+1} p_{k+1} \\
&amp; = (1 - \lambda_{k+1}) \left [ \frac{\lambda_{1}}{1 - \lambda_{k+1}} p_{1} + \frac{\lambda_{2}}{1 - \lambda_{k+1}} p_{2} + ... + \frac{\lambda_{k}}{1 - \lambda_{k+1}} p_{k} \right ] + \lambda_{k+1} p_{k+1} \\
&amp; = (1 - \lambda_{k+1}) ({\lambda_{1}}&apos; p_{1} + {\lambda_{2}}&apos; p_{2} + ... + {\lambda_{k}}&apos; p_{k}) + \lambda_{k+1} p_{k+1} \\
&amp; \text{where } {\lambda_{i}}&apos; = \frac{\lambda_{i}}{1 - \lambda_{k+1}}, \lambda_{1} + \lambda_{2} + ... + \lambda_{k} = 1 - \lambda_{k+1} \\
&amp; \sum_{i = 1}^{k} {\lambda_{i}}&apos; = \sum_{i = 1}^{k} \frac{\lambda_{i}}{1 - \lambda_{k+1}} = \frac{1}{1 - \lambda_{k+1}} \sum_{i = 1}^{k} \lambda{i} = 1
\end{align}$$</span><!-- Has MathJax -->  
<p>Hence, the point<span>${q}&apos; = \sum_{i=1}^{k} {\lambda_{i}}&apos; p_{i}$</span><!-- Has MathJax --> is convex combination of p<sub>1</sub>, p<sub>2</sub>, …, p<sub>k</sub>, q’ lies every convex set containing the them.  </p>
<span>$q = (1 - \lambda_{k+1}) {q}&apos; + \lambda_{k+1} p_{k+1}$</span><!-- Has MathJax -->  
<p>every convex set containing p<sub>1</sub>, p<sub>2</sub>, …, p<sub>k</sub>, q’. Since it also contains p<sub>k+1</sub> the set must contain q as a convex combination of two points.<br>(&lt;=) Prove q lies in every convex set containing P =&gt;<span>$q = \sum_{i = 1}^{n} \lambda_{i} p_{i}, \lambda_{i} \geq 0, \sum_{i = 1}^{n} \lambda_{i} = 1$</span><!-- Has MathJax --><br>In particular, q lies in the smallest convex set, the convex hull of P. Triangulate the convex hull, q must lie in one of the triangles<span>$\triangle p_{1} p_{2} p_{3}$</span><!-- Has MathJax -->. Connect q to p<sub>1</sub>, p<sub>2</sub>, p<sub>3</sub>. This partitions the triangle into tree smaller ones.  </p>
<span>$$\left\{\begin{matrix}
\triangle p_{1} p_{2} p_{3} = A \\
\triangle q p_{2} p_{3} = A_{1} \\ 
\triangle q p_{1} p_{3} = A_{2} \\ 
\triangle q p_{1} p_{2} = A_{3} \\
A = A_{1} + A_{2} + A_{3}
\end{matrix}\right. \Rightarrow q = \frac{A_{1}}{A} p_{1} + \frac{A_{2}}{A} p_{2} + \frac{A_{3}}{A} p_{3}$$</span><!-- Has MathJax -->  
<p>得證。</p>
<h3 id="11-2"><a href="#11-2" class="headerlink" title="11.2"></a>11.2</h3><p>Prove that the worst case running time of algorithm CONVEXHULL is O(n3), and that there are sets of points where a bad choice of the random permutation makes the algorithm actually need Θ(n3) time.</p>
<p>CONVEXHULL 共有三層 for loop.</p>
<ul>
<li>LINE 7 如果每次的新加入的 p<sub>i</sub> 都在 convex hull 外面，即 F<sub>conflict</sub>(p<sub>i</sub>) 非空。</li>
<li>LINE 10<span>$e \in \pounds$</span><!-- Has MathJax -->，而最多有 i - 1 個，投影的情況下，最多 i 個點都在凸包上，因此最多產生 i - 1 個 facets。</li>
<li>LINE 18 對每個新加入的 facets 最多增加 n - i 個 conflict 點。</li>
</ul>
<p>故最慘 O(n<sup>3</sup>)。</p>
<h3 id="11-6"><a href="#11-6" class="headerlink" title="11.6"></a>11.6</h3><p>Describe a data structure that allows you to test whether a query point q lies inside a convex polytope with n vertices in R3. (Hint: Use the results from Chapter 6.)</p>
<p>快速判斷一個點是否在 3D convex hull 中。</p>
<ul>
<li>方案一：3D point location by 3D trapezoidal map. 感覺非常難做，弄出很多柱狀體。</li>
<li>方案二：convex hull 最多會有 3n - 6 個面，最多有 3n - 6 個面不等式，判斷是否全在同一側 <em> O(n) </em>。</li>
<li>方案三：將做好的 3D convex hull，將所有點投影到 x-y 平面，每一個梯形區域會由 2 個 convex hull 的面覆蓋，要不沒有面。對於投影的 2D 建造 trapezoidal map。query 一個點 q 時，先投影到 x-y 平面，找到所在的梯形區域，針對兩面的不等式進行判斷。預處理 <em> O(n log n) </em>，詢問 <em> O(log n) </em>。</li>
</ul>
<h3 id="11-8"><a href="#11-8" class="headerlink" title="11.8"></a>11.8</h3><p>Describe a randomized incremental algorithm to compute the intersection of half-planes, and analyze its expected running time. Your algorithm should maintain the intersection of the current set of half-planes. To figure out where to insert a new half-plane, maintain a conflict graph between the vertices of the current intersection and the half-planes that are still to be inserted.</p>
<ul>
<li><p>維護半平面 hi 與 Sj 的相交資訊。</p>
</li>
<li><p><code>add half-place</code><br>繞外部 (半平面的另一側的凸包邊) 的 edge e，將 h<sub>conflict</sub>(e) 移除掉 intersection(e, h<sub>conflict</sub>(e)) in<span>$\bar{h_{i}}$</span><!-- Has MathJax -->。<br>期望值的複雜度依賴中間過程中產生的交集點個數。</p>
</li>
<li><p>假設 c(H, h) 表示 inter(H) 和 h 的 conflict vertice 個數。<br>則<span>$\sum_{i = 1}^{n} \left [ \frac{2}{i} \sum_{h \in S \setminus S_{i} }{c(H,  h)} \right ]$</span><!-- Has MathJax -->－所有的花費。  </p>
</li>
</ul>
<span>$$E[c(S_{i}, h_{i})] = \frac{1}{n-i} \sum_{h \in S \setminus S_{i} } c(S_{i}, h) \\
\Rightarrow \sum_{i = 1}^{n} \left ( \frac{2}{i} \sum_{h \in S \setminus S_{i} }{c(H,  h)} \right ) = \sum_{i = 1}^{n} \left ( \frac{2}{i} \sum_{h \in S \setminus S_{i} }{E(S_{i},  h_{i-1})} \right ) \\
= \sum_{i = 1}^{n} \left ( \frac{2}{i} (n - i) E(S_{i},  h_{i-1}) \right ) = \sum_{i = 1}^{n} \left ( \frac{2(n-i)}{i} E[\text{the number of of vertices destroy ed at i+1}] \right )$$</span><!-- Has MathJax -->  
<p>對於每一個 vertice v 被創建的時間為 tc(v), 被移除的時間 td(v)。</p>
<span>$$\sum_{i = 1}^{n} \left ( \frac{2(n-i)}{i} E[\text{the number of vertices destroy ed at i+1}] \right ) \\
= \sum_{v} \frac{2(n - td(v) + 1)}{td(v) - 1} \le \sum_{v} \frac{2(n - tc(v)) + 2}{tc(v)} \\
\le \sum_{n}^{i=1} \frac{2(n - i) + 2}{i} E[\left |v \mid tc(v) = i \right |] \\
= \sum_{n}^{i=1} \frac{2(n - i) + 2}{i} \times 2
= O(\sum_{n}^{i=1} \frac{n}{i} - 1) = O(n ln n)$$</span><!-- Has MathJax -->  
<p>得證。</p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-lesson/geometry-hw4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/28/lesson/geometry-hw4/" class="article-date">
  <time datetime="2014-11-28T00:39:44.000Z" itemprop="datePublished">2014-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>/<a class="article-category-link" href="/categories/學校課程/計算幾何/">計算幾何</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/28/lesson/geometry-hw4/">計算幾何 - HW04</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2014/11/28/lesson/geometry-hw4/" data-id="cksbltk4q029cpovnvegse8zs" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2014/11/28/lesson/geometry-hw4/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/計算幾何/">計算幾何</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h2><h3 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h3><p>Prove that for any n &gt; 3 there is a set of n point sites in the plane such that one of the cells of Vor(P) has n−1 vertices</p>
<p>證明一個點個數 n &gt; 3 的 Voronoi diagram，存在一個 cell 具有 n - 1 個頂點。</p>
<p><img src="http://i.imgur.com/86AoEWl.png" alt="7.1"></p>
<p>如圖所示，一個點放置在圓心，剩餘的 n - 1 個放置在圓周上。則中間的 cell 必然有 n - 1 個頂點。</p>
<h3 id="7-3"><a href="#7-3" class="headerlink" title="7.3"></a>7.3</h3><p>Show that<span>$\Omega (nlogn)$</span><!-- Has MathJax --> is a lower bound for computing Voronoi diagrams by reducing the sorting problem to the problem of computing Voronoi diagrams. You can assume that the Voronoi diagram algorithm should be able to compute for every vertex of the Voronoi diagram its incident edges in cyclic order around the vertex.</p>
<p><img src="http://i.imgur.com/Algk5Xi.png" alt="7.3"></p>
<p>證明 Voronoi diagram 的 lower bound<span>$\Omega (nlogn)$</span><!-- Has MathJax -->，藉由 reduce 到 sorting problem。</p>
<blockquote>
<p>關於 reduce 證明，將一個簡單、約束較少的問題 A，藉由一個合適的轉換，變成一個困難問題 B 的 subset，已知 A 的 lower bound，則 B 的 lower bound 至少與 A 相同。</p>
</blockquote>
<ol>
<li>假設排序 n 個整數<span>$x_{1}, x_{2}, ..., x_{n}$</span><!-- Has MathJax --> </li>
<li>轉換成<span>$(x_{1}, 0), (x_{2}, 0), ..., (x_{n}, 0)$</span><!-- Has MathJax --> 將所有點放置在 x 軸上，並且額外增加一點<span>$(\infty, 0)$</span><!-- Has MathJax -->。將 n + 1 個點找到 Voronoi diagram，對於<span>$(\infty, 0)$</span><!-- Has MathJax --> 的 cell 而言，恰好邊都是由另外 n 個點對應的 cell 構成 cell edge (相鄰)。假設儲存邊的順序為順或逆時針，則邊的順序等價排序結果。</li>
</ol>
<p>最後如上圖所示，又已知轉換需要<span>$O(n)$</span><!-- Has MathJax -->，sorting<span>$\Omega (nlogn)$</span><!-- Has MathJax -->，則 Voronoi diagram 的 lower bound<span>$\Omega (nlogn)$</span><!-- Has MathJax -->。</p>
<h3 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h3><p>Give an example where the parabola defined by some site<span>$p_{i}$</span><!-- Has MathJax --> contributes more than one arc to the beach line. Can you give an example where it contributes a linear number of arcs?</p>
<p><img src="http://i.imgur.com/VEwhdjt.png" alt="7.5"></p>
<p>如上圖所示<span>$p_{i}$</span><!-- Has MathJax --> 拉出的拋物線 (parabola) 有可能提供多個弧 (arc)。(最左側的點提供 2 個弧)</p>
<p>一個點<span>$p_{i}$</span><!-- Has MathJax --> 存有的 arc 數量與 cell<span>$p_{i}$</span><!-- Has MathJax -->) 的頂點數量線性相關。由 exercose 7.1 得到最多<span>$O(n)$</span><!-- Has MathJax --> 的頂點。同理 arc 數量最多<span>$O(n)$</span><!-- Has MathJax -->。</p>
<p>beach line 上的 arc 數最多為 Voronoi diagram 的 edge 數，又 Voronoi diagram 的 edge 最大數為<span>$3n - 6$</span><!-- Has MathJax -->，也因此最多為<span>$O(n)$</span><!-- Has MathJax --></p>
<h3 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h3><p>Let P be a set of n points in the plane. Give an<span>$O(nlogn)$</span><!-- Has MathJax --> time algorithm to find two points in P that are closest together. Show that your algorithm is correct.</p>
<p>Algorithm:</p>
<ol>
<li>建造 Voronoi Diagram by fortune’s algorithm<span>$O(nlogn)$</span><!-- Has MathJax --></li>
<li>對於每一個 cell<span>$p_{i}$</span><!-- Has MathJax -->) 檢查鄰居 cell<span>$p_{neighbor}$</span><!-- Has MathJax -->)，計算<span>$distance(p_{i}, p_{neighbor})$</span><!-- Has MathJax --> 的結果。Voronoi diagram 的 edge 數<span>$3n - 6$</span><!-- Has MathJax -->，每一條 edge 檢查只需要<span>$O(1)$</span><!-- Has MathJax -->。<span>$O(n)$</span><!-- Has MathJax --></li>
</ol>
<p>證明：每一個點所張開的 cell 只會與相鄰的 cell 最近，否則不符合 Voronoi diagram 的定義。</p>
<h3 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h3><p>Show that the farthest point Voronoi diagram on n points in the plane has at most 2n−3 (bounded or unbounded) edges. Also give an exact bound on the maximum number of vertices in the farthest point Voronoi diagram.</p>
<ul>
<li>歐拉公式<span>$v - e + f = 2$</span><!-- Has MathJax --></li>
<li>一個頂點至少三條邊。</li>
<li>farthest point Voronoi diagram 的最多有 n - 2 個頂點。<ul>
<li>對於每一個頂點而言，通過其相鄰 cell 對應的點的外接圓，其圓包含所有平面點。</li>
<li>這種圓最多 n - 2 個。</li>
</ul>
</li>
<li>從隨機增量算法中得知，插入一個點時，最多增加一個 vertex (繞行時，會刪除對於 cell 相交兩個線段之間的所有 vertex，這種 vertex 至少一個，並且增加與線段的交點 1 個)。<span>$v(3) = 1, v(n) = v(n-1) + 1 \text{ for } n &gt; 3$</span><!-- Has MathJax --></li>
<li>考慮增加一個虛點，連接所有 unbounded edge  <span>$v - e + f = 2 \Rightarrow (n-2+1) - e + n = 2 \Rightarrow e = 2n - 3$</span><!-- Has MathJax -->。</li>
</ul>
<hr>
<h2 id="Chpater-9"><a href="#Chpater-9" class="headerlink" title="Chpater 9"></a>Chpater 9</h2><h3 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h3><p>The degree of a point in a triangulation is the number of edges incident to it. Give an example of a set of n points in the plane such that, no matter how the set is triangulated, there is always a point whose degree is n−1.</p>
<p>對於任意三角化的結果，總會有一個點的 degree = n - 1。</p>
<p><img src="http://i.imgur.com/JEnOhDo.png" alt="9.2"></p>
<ul>
<li>此點一定能用一條線區隔所有剩餘點。</li>
<li>剩餘 n - 1 個點，一定能滿足任兩點的連線不遮蔽其他的點。</li>
</ul>
<p>example：n - 1 個點落在<span>$y = e^{x}$</span><!-- Has MathJax --> 上，且<span>$x &lt; p$</span><!-- Has MathJax -->，另外一點在<span>$(p, q)$</span><!-- Has MathJax --></p>
<h3 id="9-4"><a href="#9-4" class="headerlink" title="9.4"></a>9.4</h3><p>Prove that the smallest angle of any triangulation of a convex polygon whose vertices lie on a circle is the same. This implies that any completion of the Delaunay triangulation of a set of points maximizes the minimum angle.</p>
<p>對於所有頂點共圓的凸多邊形，任何的三角化的最小角度都會相同。</p>
<ol>
<li>任何三角形必然是圓上三點。</li>
<li>任何凸邊形的邊都會是一個三角形上的邊</li>
<li>三角形的邊都是圓的弦，並且對應角度正比弦長大小。</li>
<li>凸多邊形的最小弦長是多邊上的邊，又因一定會在三角形上，任何三角化一定包含這個最小角。</li>
</ol>
<h3 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h3><p>Prove that all edges of DG(Pr) that are not in DG(Pr−1) are incident to pr. In other words, the new edges of DG(Pr) form a star as in Figure 9.8. Give a direct proof, without referring to algorithm DELAUNAYTRIANGULATION.</p>
<p>對於新增加的邊<span>$e$</span><!-- Has MathJax -->，只會與新加入的點<span>$p_{r}$</span><!-- Has MathJax --> 相連。</p>
<ul>
<li><p>從 Voronoi diagram 等價 Delaunay triangulation，加入點的 cell，不會使其他兩個 cell 從沒相鄰變成相鄰。</p>
</li>
<li><p>對於<span>$\Delta(p_{i}, p_{j}, p_{k})$</span><!-- Has MathJax --> 之間加入<span>$p_{r}$</span><!-- Has MathJax -->，由於<span>$C(p_{i}, p_{j}, p_{k})$</span><!-- Has MathJax --> 內部不存在任何點<span>$C&apos;(p_{i}, p_{r})$</span><!-- Has MathJax --> (兩點當直徑)，得到<span>$C&apos; \subseteq C$</span><!-- Has MathJax -->，且<span>$C&apos;$</span><!-- Has MathJax --> 內部不存在任何點，確定<span>$\bar{p_{i} p_{r}}$</span><!-- Has MathJax --> 屬於 Delaunay 上。同理<span>$\bar{p_{j} p_{r}}$</span><!-- Has MathJax --><span>$\bar{p_{k} p_{r}}$</span><!-- Has MathJax -->。  </p>
</li>
<li><p>由於<span>$\Delta(p_{l}, p_{i}, p_{j})$</span><!-- Has MathJax --> 原本是 Delaunay 上，如果 flip<span>$\bar{p_{i} p_{j}}$</span><!-- Has MathJax -->，得到<span>$C(p_{i}, p_{r}, p_{l}) \subseteq C(p_{l}, p_{i}, p_{j})$</span><!-- Has MathJax --><span>$C(p_{j}, p_{r}, p_{l}) \subseteq C(p_{l}, p_{i}, p_{j})$</span><!-- Has MathJax -->，確定<span>$\bar{p_{r} p_{l}}$</span><!-- Has MathJax --> 屬於 Delaunay 上。  </p>
</li>
<li><p>也因此，對於增加的三角形進行檢查時，每次已經保證該三角形其中兩邊一定屬於 Delaunay 上，同時必然有<span>$p_{r}$</span><!-- Has MathJax -->，flip 的邊一定會接到<span>$p_{r}$</span><!-- Has MathJax --> 上。遞迴得證。</p>
</li>
</ul>
<h3 id="9-11"><a href="#9-11" class="headerlink" title="9.11"></a>9.11</h3><p>A Euclidean minimum spanning tree (EMST) of a set P of points in the plane is a tree of minimum total edge length connecting all the points. EMST’s are interesting in applications where we want to connect sites in a planar environment by communication lines (local area networks), roads, railroads, or the like.</p>
<ol>
<li>Prove that the set of edges of a Delaunay triangulation of P contains an EMST for P.</li>
<li>Use this result to give an O(nlogn) algorithm to compute an EMST for P.</li>
</ol>
<p>對於歐幾里得距離的平面最小生成樹。</p>
<ol>
<li><p>證明 EMST 的 edge set 被 Delaunay triangulation 的 edge set 包含。(參考 <a href="http://en.wikipedia.org/wiki/Euclidean_minimum_spanning_tree" target="_blank" rel="external">wiki</a>)<br> 目標： <strong> every edge not in a Delaunay triangulation is also not in any EMST </strong></p>
<ul>
<li>最小生成樹的性質：任何一個 cycle 上的最重邊將不會在最小生成樹中。</li>
<li><p>Delaunay triangulation： If there is a circle with two of the input points on its boundary which contains no other input points, the line between those two points is an edge of every Delaunay triangulation.</p>
<blockquote>
<p>對於鈍角三角形，最大邊必然不在 EMST 中，然而對於 Delaunay triangulation 性質，必須考慮他們兩點的 boundary (shared Voronoi edge) 是否存在。</p>
</blockquote>
<p>假設 p, q 之間沒有邊於 Delaunay，則對於任意通過 p, q 的圓都存在點 r 在圓內，從性質中發現 r 到 p, q 的距離一定小於 p q 之間的距離。同時在 EMST 中，p q r 三點會構成鈍角三角形，其中 p q 是最大邊，p q 之間必然沒有邊。</p>
</li>
</ul>
</li>
<li><p>找到 EMST 的<span>$O(nlogn)$</span><!-- Has MathJax --> 算法<br> Algorithm:</p>
<ol>
<li>利用 Delaunay triangulation 找到所有邊<span>$O(nlogn)$</span><!-- Has MathJax --></li>
<li>最多有 3n - 6 條邊，利用 MST 中的 kruskal’s algorithm<span>$O(ElogE)$</span><!-- Has MathJax --><br>3.<span>$E = O(3n-6) = O(n)$</span><!-- Has MathJax -->，得到<span>$O(nlogn)$</span><!-- Has MathJax --> 的做法。</li>
</ol>
</li>
</ol>
<h3 id="9-13"><a href="#9-13" class="headerlink" title="9.13"></a>9.13</h3><p>The Gabriel graph of a set P of points in the plane is defined as follows:<br>p q Two points p and q are connected by an edge of the Gabriel graph if and only if the disc with diameter pq does not contain any other point of P.</p>
<ol>
<li>Prove that DG(P) contains the Gabriel graph of P.</li>
<li>Prove that p and q are adjacent in the Gabriel graph of P if and only if the Delaunay edge between p and q intersects its dual Voronoi edge.</li>
<li>Give an O(nlogn) time algorithm to compute the Gabriel graph of a set of n points</li>
</ol>
<p>Gabriel graph：任兩點之間為直徑的圓內若沒有其他點，則兩點之間有邊。</p>
<ol>
<li>證明 subgraph 關係。 </li>
</ol>
<ul>
<li>根據 Theorem 9.6 (1) 任三點圓內<span>$C(p_{i}, p_{j}, p_{k})$</span><!-- Has MathJax -->沒有其他點，但是<span>$C(p_{i}, p_{j})$</span><!-- Has MathJax --> 內部可能存有其他點 (如單純的 n = 3 的鈍角三角形)。找到<span>$e_{p_{i}, p_{j}} \notin Gabriel \text{ but } e_{p_{i}, p_{j}} \in Delaunay$</span><!-- Has MathJax --><br>*<span>$C(p_{i}, p_{j})$</span><!-- Has MathJax --> 內部沒有其他點，則兩點之間必然有 shared Voronoi edge，符合 Theorem 9.6 (2)。得到  <span>$\text{ if }e_{p_{i}, p_{j}} \in Gabriel \text{ , then } e_{p_{i}, p_{j}} \in Delaunay$</span><!-- Has MathJax -->，得證<span>$g(P) \subseteq DG(P)$</span><!-- Has MathJax -->。</li>
</ul>
<ol>
<li>如果<span>$\bar{pq}$</span><!-- Has MathJax --> 經過多個 Voronoi edge，則<span>$\bar{pq}$</span><!-- Has MathJax --> 上一點 x 滿足 <span>$$\bar{xr} &lt; \bar{xp}, \bar{xr} &lt; \bar{xq} \\
\Rightarrow \angle rpx &lt; \angle prx, \angle rqx &lt; \angle xrq \text{(triangle)} \\
\text{let } \angle rpx = a, \angle prx = c, \angle rqx = b, \angle xrq = d \\
\Rightarrow a + b + c + d = 180^{\circ} \\ 
\Rightarrow c + d &gt; 90^{\circ}$$</span><!-- Has MathJax -->
</li>
</ol>
<p>符合圓內角性質，點 r 一定在圓內，得證<span>$e_{p_{i}, p_{j}} \notin Gabriel$</span><!-- Has MathJax -->。</p>
<ol>
<li><p>在 O(n logn) 時間內完成。<br> Algorithm： </p>
<ol>
<li>利用 Delaunay triangulation 找到所有邊<span>$O(nlogn)$</span><!-- Has MathJax --></li>
<li><p>將<span>$e_{p{i}, p{j}} \in DG(P)$</span><!-- Has MathJax --> 進行測試是否有點落在<span>$C(p{i}, p{j})$</span><!-- Has MathJax --><span>$O(n)$</span><!-- Has MathJax --></p>
<p>只需要拿鄰居進行檢測，鄰居最多 2 個 (共邊的三角形)。</p>
</li>
</ol>
</li>
</ol>
<h3 id="9-14"><a href="#9-14" class="headerlink" title="9.14"></a>9.14</h3><p>The relative neighborhood graph of a set P of points in the plane is defined as follows: Two points p and q are connected by an edge of the relative neighborhood graph if and only if</p>
<span>$d(p, q) \leq \underset{r \in P, r \neq p, q }{min} max(d(p, r), d(q, r)).$</span><!-- Has MathJax -->
<ol>
<li>Given two points p and q, let lune(p,q) be the moon-shaped region p q lune(p,q) formed as the intersection of the two circles around p and q whose radius is d(p,q). Prove that p and q are connected in the relative neighborhood graph if and only if lune(p,q) does not contain any point of P in its interior.</li>
<li>Prove that DG(P) contains the relative neighborhood graph of P.</li>
<li>Design an algorithm to compute the relative neighborhood graph of a given point set.</li>
</ol>
<p>整體而言類似 9.13。</p>
<ol>
<li>若 p, q 之間沒有邊，則  <span>$$\exists r : d(p, q) &gt; \underset{r \in P, r \neq p, q }{min} max(d(p, r), d(q, r)) \\
\exists r : d(p, q) &gt; d(p, r) \text{ and } d(p, q) &gt; d(q, r)$$</span><!-- Has MathJax -->
AND 就是做交集操作，不知道該怎麼寫才好。</li>
<li>與 9.14 依樣畫葫蘆，只是<span>$lune(p, q) \subseteq C(p, q)$</span><!-- Has MathJax -->，則更暗示<span>$\text{ if }e_{p_{i}, p_{j}} \in G \text{ , then } e_{p_{i}, p_{j}} \in Gabriel$</span><!-- Has MathJax --> </li>
<li>速度是<span>$O(n^{2})$</span><!-- Has MathJax -->，沒辦法單純看鄰居進行檢查。拿每一條邊進行 O(n) 窮舉。不過在分散式計算，整體是 O(n)。</li>
</ol>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-lesson/geometry-mid" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/26/lesson/geometry-mid/" class="article-date">
  <time datetime="2014-10-26T01:15:32.000Z" itemprop="datePublished">2014-10-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>/<a class="article-category-link" href="/categories/學校課程/計算幾何/">計算幾何</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/lesson/geometry-mid/">計算幾何 - 期中考練習</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2014/10/26/lesson/geometry-mid/" data-id="cksbltk4s029gpovn0mgpkfnj" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2014/10/26/lesson/geometry-mid/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/計算幾何/">計算幾何</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <ol>
<li>(15 points total)<br>a.    (10 points) Given a set of points that are presorted by their x-coordinate value, provide an algorithm that computes the convex hull of these points in O(n).<br>b.    (5 points) If more than 2 points are possibly on an edge of convex hull, explain briefly how your algorithm handles this case.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int cross(Pt o, Pt a, Pt b) &#123;</div><div class="line">    return (a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);</div><div class="line">&#125;</div><div class="line">int monotone(int n, Pt p[], Pt ch[]) &#123;</div><div class="line">    sort(p, p+n);</div><div class="line">    int i, m = 0, t;</div><div class="line">    for(i = 0; i &lt; n; i++) </div><div class="line">        while(m &gt;= 2 &amp;&amp; cross(ch[m-2], ch[m-1], p[i]) &lt;= 0)</div><div class="line">            m--;</div><div class="line">        ch[m++] = p[i];</div><div class="line">    for(i = n-1, t = m+1; i &gt;= 0; i--) </div><div class="line">        while(m &gt;= t &amp;&amp; cross(ch[m-2], ch[m-1], p[i]) &lt;= 0)</div><div class="line">            m--;</div><div class="line">        ch[m++] = p[i];</div><div class="line">    return m - 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>會將三點一線段的中間那一點替除掉，直到一個線段上只經過兩個點。</p>
<ol>
<li>(20 points total)<br>a.    (5 points) What are the types of event points in the plane sweep algorithm for line segment intersection problem?<br>b.    (10 points) Explain briefly when each type of event points is inserted to the event queue. Create a simple example (with 2 line segments) to demonstrate how it works.<br>c.    (5 points) When will the plane sweep algorithm for line segment intersection problem not suitable? Give a quantitative answer (i.e., describe your answer by using the Big-O notations). In addition, why is applying plane sweep algorithm on subdivision overlay in general a good idea?    </li>
</ol>
<hr>
<ul>
<li>掃描時遇到的三種情況<ol>
<li>碰到開始的左端點 (加入此線段)</li>
<li>碰到結束的右端點 (移除此線段)</li>
<li>碰到線段之間的交點 (預測下個最近的相交點後，將其包含這個交點線段移除後，重新加入)</li>
</ol>
</li>
<li>很簡單的，請參考上述三種情況繪製。</li>
<li>當交集的數量在<span>$\Theta(n^{2})$</span><!-- Has MathJax --> 的時候，複雜度是<span>$\Theta(n^{2}log n)$</span><!-- Has MathJax -->，還不如直接窮舉任兩個線段計算交點<span>$\Theta(n^{2})$</span><!-- Has MathJax -->，就算要去重複，常數也比掃描線算法來得低。</li>
</ul>
<ol>
<li>(20 points total)<br>a.    (10 points) Draw a simple polygon with 4 different types of vertices. Mark each vertex with its type. In addition, which two out of these 4 types are NOT allowed in a y-monotone piece?<br>b.    (5 points) Mark the “helper” for each of the vertices in your part (a) simple polygon that are not allowed in a y-monotone piece.<br>c.    (5 points) The triangulation of a y-monotone piece (with n vertices) can be done in linear time. Explain briefly why.</li>
</ol>
<hr>
<ul>
<li>start, split, end, merge, regular vertex 明明有五種！</li>
<li>split, merge vertex 不符合 y-monotone piece</li>
<li>加入 helper，對於 split 而言要往下找 split 或者是 regular vertex 相連，對 merge 而言要往上找 merge 或者是 regular 相連。</li>
<li>因為往左可以根據維護凹性在 O(n) 時間內完成三角化，同理往右走訪。</li>
</ul>
<ol>
<li>(20 points total)<br>a.    (5 points) What is the worst-case time complexity for the algorithm that solves the 2-dimensional linear programming problem?<br>b.    (5 points) Simplex algorithm is known to solve the linear programming problem in Operational Research. Why don’t we simple apply Simplex algorithm for the 2-dimensional linear programming problem?<br>c.    (10 points) Let (H, c) be a linear program. We number the half-planes h1, h2,…, hn. Let Hi be the set of the first i constraints, together with the special constraints m1 and m2 (i.e., the bound so that the solution space is limited). Let vi be the optimal point in Hi that satisfies the constraints. Explain why vi = vi-1 if vi-1 is contained in hi.</li>
</ol>
<hr>
<p>*<span>$O(n^{2})$</span><!-- Has MathJax --> incremental LP problem，每加入一個半平面，都必須重新計算最佳交集。</p>
<ul>
<li>Simplex algorithm O(n log n)，在 2D 限制下，可以做到 O(n)。</li>
<li>其實這是一個廢話，因為 hi 加上去，只會讓最佳解更糟，如果最佳解沒變，那麼最佳解仍然維持。</li>
</ul>
<ol>
<li>(15 points total)<br>a.     (10 points) Briefly explain what a “split node” is. Create a balanced one-dimensional search tree with 8 leave nodes to be “1”, “2”, “3”, “4”, “5”, “6”, “7”, and “8”, and a range query [2, 6] to show where the split node is and how it helps to find all numbers in the range.<br>b.    (5 points) Both kd-trees and range trees are designed to do range query. Give one scenario that the kd-trees should be used and another scenario that the range trees should be adopted.</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">           [4]</div><div class="line">          /   \</div><div class="line">         /     \</div><div class="line">        /       \</div><div class="line">     [2]        [6]</div><div class="line">    /   \       / \</div><div class="line">  [1]  [3]    [5]  \</div><div class="line">  /\    /\     /\   \</div><div class="line">[1][2][3][4] [5][6] [7]</div></pre></td></tr></table></figure>
<p>找到其中一邊的 split node 的寫法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">v = root</div><div class="line">while v is not leaf &amp;&amp; (r &lt;= xv || xv&apos; &gt; l)</div><div class="line">    if l &lt;= xv&apos;</div><div class="line">        v = lc(v)</div><div class="line">    else</div><div class="line">        v = rc(v)</div></pre></td></tr></table></figure>
<p>最後我們找到兩個 <code>split node [1], [7]</code>，在兩個 split node 之間的葉節點都是答案，對於葉節點可以利用建造時，使用一個 linked list 去完成。</p>
<ul>
<li>對於多維度範圍查找用 range tree 最好，可以保證在<span>$O(log^{d} n)$</span><!-- Has MathJax --> 以內找到解，kd-tree 在這種情況很容易退化。</li>
<li>對於最鄰近點搜索則是使用 kd-tree 最好，range tree 反而沒辦法支持這種操作。</li>
</ul>
<ol>
<li>(20 points)<br>a.    (5 points) Draw the trapezoidal map of the following given figure. Note that the bounding box is provided already. (Give each trapezoid a number, which will be used in part (b).)<br>b.    (10 points) Follow the algorithm to construct the search structure D for the trapezoidal map in part a). The segments are inserted in the order of s4, s3, s2, and s1.<br>c.    (5 points) In the trapezoidal algorithm, the endpoints of line segments are assumed to have different x-coordinate value (i.e., so-called general position). While a method was provided to relax this constraint, explain briefly why the composite-number method (i.e., transform (x, y) to (x|y, y|x)) which has been used in kd-trees and range trees to deal with the similar constraint was not adopted?</li>
</ol>
<hr>
<ul>
<li>因為它們是 range query，對於相同的 x 值仍然要算相同，利用偏斜的效果不利於操作。</li>
</ul>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-lesson/geometry-hw3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/26/lesson/geometry-hw3/" class="article-date">
  <time datetime="2014-10-25T22:49:32.000Z" itemprop="datePublished">2014-10-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>/<a class="article-category-link" href="/categories/學校課程/計算幾何/">計算幾何</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/lesson/geometry-hw3/">計算幾何 - HW03</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2014/10/26/lesson/geometry-hw3/" data-id="cksbltk4l0294povnq4ej3h8v" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2014/10/26/lesson/geometry-hw3/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/計算幾何/">計算幾何</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="Master-Theorem"><a href="#Master-Theorem" class="headerlink" title="Master Theorem"></a>Master Theorem</h2><span>$$T(n) = 
\begin{cases}
aT(n/b) + n^{c} &amp; \text{ if } n &gt; 1 \\
d &amp; \text{ if } n = 1
\end{cases}$$</span><!-- Has MathJax -->
<p>1.<span>$\text{if } log_{b}a &lt; c, T(n) = \theta(n^{c})$</span><!-- Has MathJax --><br>2.<span>$\text{if } log_{b}a = c, T(n) = \theta(n^{c} log n)$</span><!-- Has MathJax --><br>3.<span>$\text{if } log_{b}a &gt; c, T(n) = \theta(n^{log_{b}a})$</span><!-- Has MathJax --></p>
<h2 id="Extend-Master-Theorem"><a href="#Extend-Master-Theorem" class="headerlink" title="Extend Master Theorem"></a>Extend Master Theorem</h2><span>$$T(n) = 
\begin{cases}
aT(n/b) + f(n) &amp; \text{ if } n &gt; 1 \\
d &amp; \text{ if } n = 1
\end{cases} \\

E = log_{b}(a)$$</span><!-- Has MathJax -->
<p>1.<span>$\text{if } f(n) = O(n^{E} (log_{b}n)^{\alpha} ) \text{ and } \alpha &lt; -1, T(n) = \theta(n^{E})$</span><!-- Has MathJax --><br>2.<span>$\text{if } f(n) = O(n^{E} (log_{b}n)^{\alpha} ) \text{ and } \alpha = -1, T(n) = \theta(n^{E} log_{b} log_{b}(n))$</span><!-- Has MathJax --><br>3.<span>$\text{if } f(n) = O(n^{E} (log_{b}n)^{\alpha} ) \text{ and } \alpha &gt; -1, T(n) = \theta(n^{E}(log_{b}n)^{\alpha + 1})$</span><!-- Has MathJax --></p>
<h1 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h1><h2 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h2><p>In the proof of the query time of the kd-tree we found the following<br>recurrence:<br><span>$$Q(n) = 
\begin{cases}
O(1) &amp; \text{ if } n = 1 \\
2 + 2Q(n/4)&amp; \text{ if } n &gt; 1
\end{cases}$$</span><!-- Has MathJax --><br>Prove that this recurrence solves to Q(n) = O(√n). Also show that Ω(√n) is a lower bound for querying in a kd-tree by defining a set of n points and a query rectangle appropriately.</p>
<hr>
<ol>
<li>by master theorem,<span>$a = 2, b = 4, c = 0 \Rightarrow Q(n) = \Theta(\sqrt{n})$</span><!-- Has MathJax --><br>2.<span>$\Omega(\sqrt{n})$</span><!-- Has MathJax --> 是 kd-tree 的 lower_bound。如果 + 號存在的行都一直被執行，另外 - 號行都不會被執行，那麼複雜度就會達到<span>$\Omega(\sqrt{n})$</span><!-- Has MathJax -->，要明白如何加上 report 則會更慢，必須將包含的點依序回報。找一個不包含所有點的細長矩形於正中央即可，每次循環切割到 x 時，保證會留下 n/4 個節點。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Algorithm: SEARCHKDTREE(v, R) </div><div class="line">if v is leaf</div><div class="line">    report the points stored at v if it lies in R.</div><div class="line">else</div><div class="line">-	if region(lc(v)) contains R</div><div class="line">        report subtree lc(v)</div><div class="line">+	else if lc(v) intersects R</div><div class="line">        SEARCHKDTREE(lc(v), R)</div><div class="line">  </div><div class="line">-	if region(rc(v)) contains R</div><div class="line">        report subtree rc(v)</div><div class="line">+ 	else if rc(v) intersects R</div><div class="line">        SEARCHKDTREE(rc(v), R)</div></pre></td></tr></table></figure>  
<h2 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h2><p>In Section 5.2 it was indicated that kd-trees can also be used to store sets of points in higher-dimensional space. Let P be a set of n points in d-dimensional space. In parts a. and b. you may consider d to be a constant.</p>
<ol>
<li>Describe an algorithm to construct a d-dimensional kd-tree for the points in P. Prove that the tree uses linear storage and that your algorithm takes<span>$O(n log n)$</span><!-- Has MathJax --> time.</li>
<li>Describe the query algorithm for performing a d-dimensional range query. Prove that the query time is bounded by<span>$O(n^{1&minus;1/d} +k)$</span><!-- Has MathJax -->.</li>
<li>Show that the dependence on d in the amount of storage is linear, that is, show that the amount of storage is<span>$O(dn)$</span><!-- Has MathJax --> if we do not consider d to be a constant. Give the dependence on d of the construction time and the query time as well.</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Algorithm : build(int k, int l, int r, int dep)</div><div class="line">    if l &gt; r</div><div class="line">        return NULL</div><div class="line">    m = (l + r)/2</div><div class="line">    Node ret = median axis[k%K] of point[l, r] ----- O(n)</div><div class="line">    split points[l, r] by median               ----- O(n), C++ std::nth_element()</div><div class="line">    ret.lson = build((k+1)%K, l, m-1);</div><div class="line">    ret.rson = build((k+1)%K, m+1, r);</div><div class="line">    return ret;</div></pre></td></tr></table></figure>
<ol>
<li>利用 median of medians 算法找到中位數，數據儲存用指針來完成搜索，不用移動資料。<br>以上代碼根據遞迴公式<span>$T(n) = 2T(n/2) + O(n) \Rightarrow T(n) = \Theta(n log n)$</span><!-- Has MathJax -->，而 kd-tree 是一個 full binary tree，每一個節點都代表一個實際資料，因此空間複雜度<span>$O(n)$</span><!-- Has MathJax --> </li>
<li>假設在 d 為空間，Q(n) 表示 n 個點的詢問，依序按照維度切割 (ex. x, y, z, x …)，現在只關注 x 軸上的切割，假設詢問範圍包含所有的 y, z，那麼在 2ed x 節點中，每一個節點具有<span>$n/2^{d}$</span><!-- Has MathJax --> 資料，而同一層會有<span>$2^{d-1}$</span><!-- Has MathJax --> 個 x 維度的子節點。然後遞迴詢問<span>$2^{d-1}$</span><!-- Has MathJax --> 所包含的範圍查找。<br>藉由 master theorem,<span>$a = 2^{d-1}, b = 2^{d}, c = 0 \Rightarrow Q(n) = \Theta(n^{1 - 1/d})$</span><!-- Has MathJax -->  <span>$$Q(n) =
\begin{cases}
O(1) &amp; \text{ if } n &lt; 2^{d} \\
2^{d-1} + 2^{d-1} Q(n/2^{d}) &amp; \text{ if } n \geq 2^{d}
\end{cases}$$</span><!-- Has MathJax --></li>
<li>如果 d 不是常數，每一個內部節點空間 O(d)，有 n 個節點則需 O(dn) 的儲存空間。詢問上，需要在 intersected 花 O(d) 時間決定是否存在交集、包含，再來判斷是否走訪子樹，因此詢問是<span>$2dQ(n) = O(dn^{1-1/d})$</span><!-- Has MathJax -->，加上回報的效率為<span>$2dQ(n) = O(dn^{1-1/d} + k)$</span><!-- Has MathJax -->。</li>
</ol>
<h2 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h2><p>Algorithm SEARCHKDTREE can also be used when querying with other ranges than rectangles. For example, a query is answered correctly if the range is a triangle.</p>
<p>a. Show that the query time for range queries with triangles is linear in the worst case, even if no answers are reported at all. Hint: Choose all points to be stored in the kd-tree on the line y = x.<br>b. Suppose that a data structure is needed that can answer triangular range queries, but only for triangles whose edges are horizontal, vertical, or have slope +1 or −1. Develop a linear size data structure that answers such range queries in O(n3/4+k) time, where k is the number of points reported. Hint: Choose 4 coordinate axes in the plane and use a 4-dimensional kd-tree.<br>c. Improve the query time to O(n2/3+k). Hint: Solve Exercise 5.4 first.</p>
<hr>
<ol>
<li>最慘情況是 O(n)－詢問範圍為三角形。<br>詢問的範圍如圖，所有點落在 y = x 上，三角形範圍是一個很貼近 y = x 的三角形，三角形並沒有包含任何一個點，卻與所有劃分的區域有交集，因此必須走訪所有節點。</li>
<li>如果要支持三角形範圍查找 (三角形的邊要不垂直、平行、斜率 +1、斜率 -1)。找到一個詢問<span>$O(n^{3/4} + k)$</span><!-- Has MathJax --> 的資料結構。<br>類似 kd-tree，但是輪替的標準為 <strong> x 軸 </strong>、<strong> y 軸 </strong>、<strong> 斜率 1 </strong>、<strong> 斜率 -1 </strong>，根據 5.3(b) 的公式，相當於 d = 4 的情況，得到<span>$O(n^{1 - 1/4} + k) = O(n^{3/4} + k)$</span><!-- Has MathJax -->。</li>
<li>加快到<span>$O(n^{2/3} + k)$</span><!-- Has MathJax --> 的詢問時間。<br>在這裡想到是建立兩個 kd-tree，其中一個順序為 <strong> x 軸 </strong>、<strong> 斜率 1 </strong>、<strong> 斜率 -1 </strong>，另一個順序為 <strong> y 軸 </strong>、<strong> 斜率 1 </strong>、<strong> 斜率 -1 </strong>。前者可以回答向上、向下三角形，後者回答向左、向右三角形。相當於 d = 3 的切割，最多拆成 4 個範圍查找<span>$O(4n^{1 - 1/3} + k) = O(n^{2/3} + k)$</span><!-- Has MathJax -->。<ol>
<li>在詢問矩形時，拆成四個三角形查找 (向上、向下、向左、向右三角形)</li>
<li>在詢問三角形時，拆成兩個三角形查找</li>
</ol>
</li>
</ol>
<h2 id="5-9"><a href="#5-9" class="headerlink" title="5.9"></a>5.9</h2><p>One can use the data structures described in this chapter to determine whether a particular point (a,b) is in a given set by performing a range query with range [a : a]×[b : b]. </p>
<ol>
<li>Prove that performing such a range query on a kd-tree takes time O(logn).</li>
<li>What is the time bound for such a query on a range tree? Prove your answer.</li>
</ol>
<hr>
<ol>
<li>對於 kd-tree 所消耗的時間 O(log n) 說明。  <span>$[a:a] \times [b:b]$</span><!-- Has MathJax --> 並不會跨區間。在 SEARCHKDTREE(v, R) 函數中，Line SEARCHKDTREE(lc(v), R) 和 SEARCHKDTREE(rc(v), R) 只會有一個符合。<span>$$Q(n) =
\begin{cases}
O(1) &amp; \text{ if } n = 1 \\
1 + Q(n/2) &amp; \text{ if } n &gt; 1
\end{cases}$$</span><!-- Has MathJax --></li>
<li>對於 kd-tree 所消耗的時間 O(d log n) 說明。<br>首先能知道會先在第一維度探訪<span>$[a:a]$</span><!-- Has MathJax --> 的葉節點，中間經過 log n 個節點最後到葉節點，然後在其相對應的 y 軸 tree 中查找<span>$[b:b]$</span><!-- Has MathJax --> 也是 log n。因此是<span>$O(\sum{i = 1}^{d} log n) = O(d log n)$</span><!-- Has MathJax --></li>
</ol>
<h2 id="5-11"><a href="#5-11" class="headerlink" title="5.11"></a>5.11</h2><p>Let S1 be a set of n disjoint horizontal line segments and let S2 be a set<br>of m disjoint vertical line segments. Give a plane-sweep algorithm that<br>counts in O((n+m) log(n+m)) time how many intersections there are<br>in S1 ∪ S2.</p>
<hr>
<p>給 n 個不相交的水平線段、m 個不相交的垂直線段，在 O((n+m) log (n+m)) 的時間內找到焦點個數。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Algorithm:</div><div class="line">    1. sort all x-coordinate ----- O((n+m) log (n+m))</div><div class="line">    2. sweep x from small to large, maintain a segment tree or range tree.</div><div class="line"></div><div class="line">    for x = -oo to oo</div><div class="line">        for each horizontal line (sx, y)-(ex, y) in x</div><div class="line">            if sx = x</div><div class="line">                1Drangetree.add(y) 				----- O(log (n+m))</div><div class="line">        for each vertical line (x, sy)-(x, ey) in x</div><div class="line">            ret += 1Drangetree.query(sy, ey) 	----- O(log (n+m))</div><div class="line">        for each horizontal line (sx, y)-(ex, y) in x</div><div class="line">            if ex = x</div><div class="line">                1Drangetree.remove(y) 			----- O(log (n+m))</div><div class="line">    return ret</div></pre></td></tr></table></figure>
<h1 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h2><p>Draw the graph of the search structure D for the set of segments depicted<br>in the margin, for some insertion order of the segments.</p>
<hr>
<p>雖然沒有加入順序的考量，但是手爆一個 17 個線段、平面空間 29 個的建造 … 也許有點瘋狂，用最簡單的由上而下掃描，造成一個傾斜的樹也是各種不容易。</p>
<h2 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h2><p>Give an example of a set of n line segments with an order on them that<br>makes the algorithm create a search structure of size Θ(n2) and worst-case<br>query time Θ(n).</p>
<hr>
<p>找到一個最慘空間<span>$\Theta(n^{2})$</span><!-- Has MathJax -->，最慘詢問時間<span>$\Theta(n)$</span><!-- Has MathJax -->。</p>
<p>n 個線段，將其中 n/2 放置在同一個水平線上，對於剩餘 n/2 個：</p>
<p>每次加入的順序 s1, s2, …, si，每次的線段的 x 值會包含前一個線段<span>$s_{i}.lx &lt; s_{i-1}.lx, s_{i}.rx &gt; s_{i-1}.rx$</span><!-- Has MathJax -->，美加入一個線段，會增加 n/2 個內部節點，並且最大深度增加 1。總計加入 n/2 次，增加的節點數量 O(n/2 x n/2) = O(n^2)，深度 O(n/2) = O(n)。</p>
<h2 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h2><p>Given a convex polygon P as an array of its n vertices in sorted order along the boundary. Show that, given a query point q, it can be tested in time O(logn) whether q lies inside P.</p>
<hr>
<p>由於詢問次數相當多，必須將複雜度降到 O(log n)，採用的方式將凸包其中一個點當作基準，則如果在凸包的點而言，一定會落在某個以基點拉出的三角形內部中，為了方便計算，則可以拿外積的正負邊界上。得到可能的三角形後，從邊界中可以藉由外積計算是否同側。</p>
<p>採用射線法 O(n) 肯定是吃大虧的。</p>
<figure class="highlight plain"><figcaption><span>part of UVa 12048 - Inhabitants</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">double cross(Pt o, Pt a, Pt b) &#123;</div><div class="line">    return (a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);</div><div class="line">&#125;</div><div class="line">int inside_convex(const Pt &amp;p, Pt ch[], int n) &#123;</div><div class="line">    if(n &lt; 3)</div><div class="line">        return false;</div><div class="line">    if(cross(ch[0], p, ch[1]) &gt; eps)</div><div class="line">        return false;</div><div class="line">    if(cross(ch[0], p, ch[n-1]) &lt; -eps)</div><div class="line">        return false;</div><div class="line">    </div><div class="line">    int l = 2, r = n-1;</div><div class="line">    int line = -1;</div><div class="line">    while(l &lt;= r) &#123;</div><div class="line">        int mid = (l + r)&gt;&gt;1;</div><div class="line">        if(cross(ch[0],p, ch[mid]) &gt; -eps) &#123;</div><div class="line">            line = mid;</div><div class="line">            r = mid - 1;</div><div class="line">        &#125; else l = mid + 1;</div><div class="line">    &#125;</div><div class="line">    return cross(ch[line-1], p, ch[line]) &lt; eps;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-lesson/geometry-hw2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/17/lesson/geometry-hw2/" class="article-date">
  <time datetime="2014-10-17T07:33:44.000Z" itemprop="datePublished">2014-10-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>/<a class="article-category-link" href="/categories/學校課程/計算幾何/">計算幾何</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/17/lesson/geometry-hw2/">計算幾何 - HW02</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2014/10/17/lesson/geometry-hw2/" data-id="cksbltk4i0290povn28cv6pgu" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2014/10/17/lesson/geometry-hw2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/計算幾何/">計算幾何</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h1 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h1><h2 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h2><p>A rectilinear polygon is a simple polygon of which all edges are horizontal or vertical. Let P be a rectilinear polygon with n vertices. Give an example to show that<span>$\left \lfloor n/4 \right \rfloor$</span><!-- Has MathJax --> cameras are sometimes necessary to guard it.</p>
<hr>
<p>正交多邊形是其中一種多邊形，邊與邊之間不是平行就是垂直。至少需要 n/4 個攝影機才能監視每一個角落。</p>
<p>The rectilnear polygon would contain<span>$\left \lfloor n/4 \right \rfloor$</span><!-- Has MathJax --> parallel “alleys”. At least<span>$\left \lfloor n/4 \right \rfloor$</span><!-- Has MathJax --> cameras are needed because no cameras can see more than one alleys.</p>
<p>正交多邊形，可以產生<span>$\left \lfloor n/4 \right \rfloor$</span><!-- Has MathJax --> 個平行的走廊，每一個攝影機只能顧及一個走廊，因此得到一個最簡單的例子需要<span>$\left \lfloor n/4 \right \rfloor$</span><!-- Has MathJax --> 個攝影機。</p>
<h2 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h2><p>Let P be a simple polygon with n vertices, which has been partitioned into monotone pieces. Prove that the sum of the number of vertices of the pieces is O(n).</p>
<hr>
<p>證明一個 n 個節點的簡單多邊形，拆成多個 monotone pieces，節點總數仍然是 O(n)。</p>
<p>一個簡單多邊形可以三角化成 n - 2 個三角形，每個三角形都是一個 monotone piece，因此節點個數總和<span>$3 * (n - 2) = O(n)$</span><!-- Has MathJax --></p>
<p>證明一個簡單多邊形有 n 個頂點，可以切成 n - 2 個三角形。</p>
<ul>
<li>n = 3 時，T(3) = 1, 符合 T(n) = n - 2 成立</li>
<li>當 n = k 時，k &gt;= 3, 且符合 T(n) = n - 2</li>
<li>n = k + 1 時，T(n + 1) = T(n) + 1 = (n - 2) + 1 = n - 1，</li>
</ul>
<p>切割的證明為，找到多邊形的最左側點，然後他一定是凸的，將相鄰兩點拉一條線，如果構成的三角形內部沒有其他點，則直接變成 n - 1 個節點的多邊形，如果裡面有點，則挑一個最靠近最左側點的那個點，將最左側那個點與其相連，這時劃分成兩個多邊形，保證算法一樣。</p>
<h2 id="3-11"><a href="#3-11" class="headerlink" title="3.11"></a>3.11</h2><p>Give an efficient algorithm to determine whether a polygon P with n<br>vertices is monotone with respect to some line, not necessarily a horizontal<br>or vertical one.</p>
<hr>
<p>請參考 <a href="http://morris821028.github.io/2014/10/17/mproblem-monotone/">[ACM 題目] 單調測試</a> 的解法。</p>
<p>主要解法複雜度為 <code>O(n log n)</code>，採用角度掃描。</p>
<h1 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h1><h2 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h2><p>Consider the casting problem in the plane: we are given polygon P and a 2-dimensional mold for it. Describe a linear time algorithm that decides whether P can be removed from the mold by a single translation.</p>
<hr>
<ol>
<li>對於 P 的任一面<span>$f_{i}$</span><!-- Has MathJax --> 的法向量<span>$\vec{n_{i}}$</span><!-- Has MathJax -->，找到一個移動向量<span>$\vec{d}$</span><!-- Has MathJax -->，使其<span>$\vec{n_{i}}$</span><!-- Has MathJax --> 和<span>$\vec{d}$</span><!-- Has MathJax --> 張角全大於 90 度。也就是內積小於 0。</li>
<li><p>給 {(n1x, n1y), (n2x, n2y), …}<br><code>nix * dx + niyy * dy &lt;= 0</code></p>
</li>
<li><p>如果不單純派 <code>dy = 1</code>，調用 2DRANDOMIZEDBOUNDLP 判斷是否有解即可，不必最佳化其結果。</p>
</li>
</ol>
<h2 id="4-8"><a href="#4-8" class="headerlink" title="4.8"></a>4.8</h2><p>The plane z = 1 can be used to represent all directions of vectors in 3-dimensional space that have a positive z-value. How can we represent all directions of vectors in 3-dimensional space that have a non-negative z-value? And how can we represent the directions of all vectors in 3-dimensional space?</p>
<hr>
<p>1.<span>$z = 0 \cup z = 1$</span><!-- Has MathJax --><br>2.<span>$z = -1 \cup z = 1 \cup x = -1 \cup x = 1 \cup y = -1 \cup y = 1$</span><!-- Has MathJax -->，有人問說單純<span>$z = -1 \cup z = 1$</span><!-- Has MathJax --> 不就包含了所有方向嗎？但是我思考了一下收斂問題，這之間到底有沒有連續？極限上是相同，但是包不包含呢？這一點我比較擔憂，總之找一個方法將原點包起，保證原點拉到任一個面都能產生出所有方向，我附的答案是六面體，最簡單的四面體都然也可以，但是不太好寫。</p>
<h2 id="4-16"><a href="#4-16" class="headerlink" title="4.16"></a>4.16</h2><p>On n parallel railway tracks n trains are going with constant speeds v1, v2, . . . , vn. At time t = 0 the trains are at positions k1, k2, . . . , kn. Give an O(nlogn) algorithm that detects all trains that at some moment in time are leading. To this end, use the algorithm for computing the intersection of half-planes.</p>
<hr>
<ul>
<li>公式<span>$X_{i}(t) = K_{i} + V_{i} *  t$</span><!-- Has MathJax --></li>
<li>對於所有 polyhedral set<span>$H = {(t, x) : \forall i; X \geq X_{i}(t)}$</span><!-- Has MathJax --></li>
</ul>
<p>之後將這些半平面做交集，看交集結果的邊屬於哪一個半平面的邊界，哪一個火車就曾經領先過。套用半平面求交集只需要 <code>O(n log n)</code></p>
<p>請參考 <a href="http://morris821028.github.io/2014/10/12/mproblem-tanks/">[ACM 題目] 少女與戰車</a></p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-lesson/geometry-hw1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/05/lesson/geometry-hw1/" class="article-date">
  <time datetime="2014-10-05T07:26:10.000Z" itemprop="datePublished">2014-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>/<a class="article-category-link" href="/categories/學校課程/計算幾何/">計算幾何</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/05/lesson/geometry-hw1/">計算幾何 - HW01</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2014/10/05/lesson/geometry-hw1/" data-id="cksbltk4g028xpovn9cp1gij3" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2014/10/05/lesson/geometry-hw1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/計算幾何/">計算幾何</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><p>The convex hull of a set S is defined to be the intersection of all convex sets that contain S. For the convex hull of a set of points it was indicated that the convex hull is the convex set with smallest perimeter. We want to show that these are equivalent definitions</p>
<p>a. Prove that the intersection of two convex sets is again convex. This implies that the intersection of a finite family of convex sets is convex as well.<br>b. Prove that the smallest perimeter polygon P containing a set of points P is convex.<br>c. Prove that any convex set containing the set of points P contains the smallest perimeter polygon P.</p>
<hr>
<p>a. 證明兩個凸包交集仍然是凸包<br>假設凸包分別為<span>$C1, C2$</span><!-- Has MathJax -->，題目所求<span>$C = C1 \bigcap C2$</span><!-- Has MathJax --><br>已知：A set<span>$K$</span><!-- Has MathJax --> is convex if each<span>$u \neq v$</span><!-- Has MathJax -->, the line-segment<span>$\bar{uv}$</span><!-- Has MathJax --> is contained in<span>$K$</span><!-- Has MathJax -->,<span>$\bar{uv}\subseteq K$</span><!-- Has MathJax --><br>假設<span>$C$</span><!-- Has MathJax --> 不是凸包，則存在<span>$\bar{uv} \nsubseteq C$</span><!-- Has MathJax -->，根據定義<span>$u, v \in C1, C2$</span><!-- Has MathJax -->，得到<span>$\bar{uv} \nsubseteq C1, C2$</span><!-- Has MathJax -->，矛盾得證<span>$C$</span><!-- Has MathJax --> 一定是凸包。</p>
<p>b. 證明最小周長的多邊形 P 包含所有點集 S 一定是凸包<br>假設<span>$P$</span><!-- Has MathJax --> 是最小周長的非凸包多邊形，令<span>$x, y \in P, and \bar{xy} \nsubseteq P$</span><!-- Has MathJax -->，則<span>$\bar{xy}$</span><!-- Has MathJax --> 會交<span>$P$</span><!-- Has MathJax --> 於至少兩點<span>$x&apos;, y&apos;$</span><!-- Has MathJax --><span>$P&apos;$</span><!-- Has MathJax --> 是將<span>$\bar{x^{&apos;}y^{&apos;}}$</span><!-- Has MathJax --> 連起所產生的新多邊形，顯然地<span>$P&apos;$</span><!-- Has MathJax --> 的周長更小。矛盾得證。</p>
<p>c. 證明任何一個凸多邊形 C 包含點集 S 的同時也一定會包含最小周長的多邊形 P。<br>假設有 vertex<span>$v \in P, but v \notin C$</span><!-- Has MathJax -->，同時 v 不會在 S 範圍中，因為 C 已經包含了 S<span>$v1, v2$</span><!-- Has MathJax --> 為<span>$C, P$</span><!-- Has MathJax --> 交點，則<span>$P&apos;$</span><!-- Has MathJax --> 是<span>$v1, v2$</span><!-- Has MathJax --> 相連產生的多邊形，則 P’ 藉由 (b) 一定是多邊形，v1 到 v2 的距離更短，找到一個周長更小的多邊形。矛盾得證。</p>
<h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><p>Let E be an unsorted set of n segments that are the edges of a convex polygon. Describe an O(nlogn) algorithm that computes from E a list containing all vertices of the polygon, sorted in clockwise order.</p>
<hr>
<p>Algorithm:</p>
<ol>
<li>得到所有點<span>${(x1, y1), (x2, y2), ..., (xn, yn)}$</span><!-- Has MathJax -->，並且附加是屬於哪兩個邊的端點對點作排序。<code>map&lt; point, vector&lt;seg&gt; &gt; R</code> - <code>O(n log n)</code></li>
<li>挑最左下的角當作<span>$(x1, y1)$</span><!-- Has MathJax --> 的其中一邊<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">A[0] = (x0, y0) = R.begin().first;</div><div class="line">for (int i = 0; i &lt; E.size(); i++) &#123;</div><div class="line">    for (seg s : R[A[0]]) &#123;</div><div class="line">        if (s.p0 == A[i] &amp;&amp; (i == 0 || s.p1 != A[i-1]))</div><div class="line">            A[i+1] = s.p1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>檢查是否為順時針，否則反轉序列 - <code>O(n)</code></li>
</ol>
<h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p>The O(nlogn) algorithm to compute the convex hull of a set of n points in the plane that was described in this chapter is based on the paradigm of incremental construction: add the points one by one, and update the convex hull after each addition. In this exercise we shall develop an algorithm based on another paradigm, namely divide-and-conquer.</p>
<p>a. Let P1 and P2 be two disjoint convex polygons with n vertices in total. Give an O(n) time algorithm that computes the convex hull of P1 ∪P2.<br>b. Use the algorithm from part a to develop an O(nlogn) time divide-andconquer algorithm to compute the convex hull of a set of n points in the plane.</p>
<hr>
<p>D&amp;C 的 <code>O(n log n)</code> 凸包算法</p>
<p>a. 將兩個沒有相交的凸包，用 <code>O(n)</code> 時間內合併凸包<span>$P1 \cup P2$</span><!-- Has MathJax -->。</p>
<p>假設兩個凸包儲存方式都是逆時針順序，並第一個節點為最左下的節點。<br>Algorithm:</p>
<ol>
<li>將最左側的凸包另為 P1，反之 P2。</li>
<li>代碼如下，找到下凸包 - <code>O(n)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">vector C</div><div class="line">C[m = 0] = P1[0]</div><div class="line">for (i = 1, j = 0; i &lt; P1.size(); i++) &#123;</div><div class="line">    if (m &gt;= 2 &amp;&amp; cross(C[m-1] - C[m-2], P2[j] - C[m-2]) &lt;= 0)</div><div class="line">        break;</div><div class="line">    C[m++] = P1[i]</div><div class="line">&#125;</div><div class="line">for (; j &lt; P2.size(); j++)</div><div class="line">    while (m &gt;= 2 &amp;&amp; cross(C[m-1] - C[m-2], P2[j] - C[m-2]) &lt;= 0)</div><div class="line">        m--;</div><div class="line">    C[m++] = P2[j];</div></pre></td></tr></table></figure></li>
<li>仿 <strong>2.</strong> 反過來作，找到上凸包 - <code>O(n)</code></li>
<li>上下凸包合併 - <code>O(n)</code></li>
</ol>
<p>b.<br>Algorithm:</p>
<ol>
<li>將所有點按照 x 做升排序 - <code>O(n log n)</code></li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">convex DC(int l, int r, point p[]) &#123;</div><div class="line">    if (l == r)</div><div class="line">        return convex(p[l])</div><div class="line">    convex leftconvex = DC(l, (l + r)/2, p);</div><div class="line">    convex rightconvex = DC((l+r)/2 + 1, r, p);</div><div class="line">    return merge(leftconvex, rightconvex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Prove<span>$T(n) = 2 T(n/2) + O(n)$</span><!-- Has MathJax -->,<br>by master theorem:<span>$a = 2, b = 2, c = 1, log_{a}b = c, \Rightarrow T(n) = \theta (n^{c} log n) = \theta (n log n)$</span><!-- Has MathJax --></p>
<hr>
<h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p>Let S be a set of n disjoint line segments whose upper endpoints lie on the line y=1 and whose lower endpoints lie on the line y=0. These segments partition the horizontal strip [−∞ : ∞]×[0 : 1] into n+1 regions. Give an O(nlogn) time algorithm to build a binary search tree on the segments in S such that the region containing a query point can be determined in O(logn) time. Also describe the query algorithm in detail.</p>
<hr>
<p><a href="http://zerojudge.tw/ShowProblem?problemid=b321" target="_blank" rel="external">參閱實作 b321: 河道分界</a></p>
<p>Algorithm: (build)</p>
<ol>
<li>sort 線段 (根據上方的 (x, 1) 進行由小排到大 ) - <code>O(n log n)</code></li>
<li>靜態建造，動態建造請參閱可平衡的 BST。因為任切一條 y = k 的線，保證相交的 x 值得順序不會變 (跟排序結果的順序相比)，因此一開始挑 y = 1 來做排序依據。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">root = dfs(0, n - 1, segments) - `O(n)`</div><div class="line">node dfs(int l, int r, segment segs[]) &#123;</div><div class="line">    if (l == r)</div><div class="line">        return new node(segs[l]);</div><div class="line">    else if (l &lt; r)</div><div class="line">        int mid = (l + r)/2;</div><div class="line">        node ret = new node(segs[mid]);</div><div class="line">        ret.lson = dfs(l, mid - 1, segs);</div><div class="line">        ret.rson = dfs(mid + 1, r, segs);</div><div class="line">        return ret;</div><div class="line">    else</div><div class="line">        return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Algorithm: (query)</p>
<ol>
<li>令 lbound = null, rbound = null</li>
<li>走訪 BST<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void query(node u, point p) &#123;</div><div class="line">    if u == NULL</div><div class="line">        return;</div><div class="line">    if p leftside by u.seg</div><div class="line">        rbound = u</div><div class="line">        dfs(u.lson, p)</div><div class="line">    else</div><div class="line">        lbound = u</div><div class="line">        dfs(u.rson, p)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>output <code>(lbound, rbound)</code></li>
</ol>
<h2 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h2><p>Which of the following equalities are always true?<br><span>$$(1) Twin(Twin(\vec{e})) = \vec{e} \\
(2) Next(Prev(\vec{e})) = \vec{e} \\
(3) Twin(Prev(Twin(\vec{e}))) = Next(\vec{e}) \\
(4) IncidentFace(\vec{e}) = IncidentFace(Next(\vec{e})) \\$$</span><!-- Has MathJax --></p>
<hr>
<p>(1)(2)(4) are always true. (3) may not be true.</p>
<h2 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h2><p>Give an example of a doubly-connected edge list where for an edge e the faces<span>$IncidentFace(\vec{e})$</span><!-- Has MathJax --> and<span>$IncidentFace(Twin(\vec{e}))$</span><!-- Has MathJax --> are the same.</p>
<hr>
<p>已知<span>$IncidentFace(\vec{e}) = IncidentFace(Next(\vec{e}))$</span><!-- Has MathJax --> always true，讓<span>$Next(\vec{e}) = Twin(\vec{e})$</span><!-- Has MathJax --> always true。</p>
<table>
<thead>
<tr>
<th>Half-edge</th>
<th>Orign</th>
<th>Twin</th>
<th>IncidentFace</th>
<th>Next</th>
<th>Prev</th>
</tr>
</thead>
<tbody>
<tr>
<td><span>$\vec{e_{1, 2}}$</span><!-- Has MathJax --></td>
<td><span>$v_{1}$</span><!-- Has MathJax --></td>
<td><span>$\vec{e_{2, 1}}$</span><!-- Has MathJax --></td>
<td>f1</td>
<td><span>$\vec{e_{2, 1}}$</span><!-- Has MathJax --></td>
<td><span>$\vec{e_{2, 1}}$</span><!-- Has MathJax --></td>
</tr>
<tr>
<td><span>$\vec{e_{2, 1}}$</span><!-- Has MathJax --></td>
<td><span>$v_{2}$</span><!-- Has MathJax --></td>
<td><span>$\vec{e_{1, 2}}$</span><!-- Has MathJax --></td>
<td>f1</td>
<td><span>$\vec{e_{1, 2}}$</span><!-- Has MathJax --></td>
<td><span>$\vec{e_{1, 2}}$</span><!-- Has MathJax --></td>
</tr>
</tbody>
</table>
<h2 id="2-14"><a href="#2-14" class="headerlink" title="2.14"></a>2.14</h2><p>Let S be a set of n disjoint line segments in the plane, and let p be a point not on any of the line segments of S. We wish to determine all line segments of S that p can see, that is, all line segments of S that contain some point q so that the open segment pq doesn’t intersect any p not visible line segment of S. Give an O(nlogn) time algorithm for this problem that uses a rotating half-line with its endpoint at p.</p>
<hr>
<p><a href="http://zerojudge.tw/ShowProblem?problemid=b325" target="_blank" rel="external">參閱實作 b325: 人格分裂</a></p>
<p>Algorithm:</p>
<ol>
<li>對於所有的端點相對 p 做極角排序，並且知道相對應的角度上會存有那些線段的端點。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">map&lt;double, vector&lt;int, int&gt; &gt; angle;</div><div class="line">for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">    double v1 = atan2(D[i].s.y - pos.y, D[i].s.x - pos.x);</div><div class="line">    double v2 = atan2(D[i].e.y - pos.y, D[i].e.x - pos.x);</div><div class="line">    angle[v1].push_back(make_pair(i, 0));</div><div class="line">    angle[v2].push_back(make_pair(i, 1));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>藉由出現的角度，使用極角掃描，一開始必須將碰的線段加入。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">double c;</div><div class="line">CMP::base = pos;</div><div class="line">double ftheta = angle.begin()-&gt;first;</div><div class="line">pair&lt;int, int&gt; u = angle.begin()-&gt;second[0];</div><div class="line">Pt fpt;</div><div class="line">if (u.second == 0)</div><div class="line">    fpt = D[u.first].s;</div><div class="line">else</div><div class="line">    fpt = D[u.first].e;</div><div class="line">for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">    if (cross(pos, fpt, D[i].s) * cross(pos, fpt, D[i].e) &lt; 0)</div><div class="line">        S.insert(D[i]);</div><div class="line">&#125;</div><div class="line">CMP::sin = sin(ftheta);</div><div class="line">CMP::cos = cos(ftheta);</div><div class="line">for (map&lt;double, vector&lt; pair&lt;int, int&gt; &gt;, CMP2&gt;::iterator it = angle.begin();</div><div class="line">    it != angle.end(); it++) &#123;</div><div class="line">    CMP::sin = sin(it-&gt;first);</div><div class="line">    CMP::cos = cos(it-&gt;first);</div><div class="line">    for (int i = 0; i &lt; it-&gt;second.size(); i++) &#123;</div><div class="line">        pair&lt;int, int&gt; u = it-&gt;second[i];</div><div class="line">        if (u.second == 0)</div><div class="line">            c = cross(pos, D[u.first].s, D[u.first].e);</div><div class="line">        else</div><div class="line">            c = cross(pos, D[u.first].e, D[u.first].s);</div><div class="line">        if (fabs(c) &gt; eps) &#123;</div><div class="line">            if (c &gt; 0)</div><div class="line">                S.insert(D[u.first]);</div><div class="line">            else</div><div class="line">                S.erase(D[u.first]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (S.size()) &#123;</div><div class="line">        visual[S.begin()-&gt;label] = 1;</div><div class="line">    &#125;</div><div class="line">&#125; </div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>出題目，出題目，萌萌哒</p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
  
</section>
          
          
            <aside id="sidebar">
  <!-- <div id="ukagaka_panel"></div> -->
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/">學校課程</a><span class="category-list-count">115</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/介面設計/">介面設計</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/作業系統/">作業系統</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/即時系統/">即時系統</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/大學專題/">大學專題</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/巨量資料/">巨量資料</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/平行程式/">平行程式</a><span class="category-list-count">43</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/敏捷方法/">敏捷方法</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/數位影像生成/">數位影像生成</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/編譯器/">編譯器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/自然語言/">自然語言</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/虛擬實境/">虛擬實境</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/計算型智慧/">計算型智慧</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/計算幾何/">計算幾何</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/計算機圖學/">計算機圖學</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/資料庫系統/">資料庫系統</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/資訊安全/">資訊安全</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/通識課程/">通識課程</a><span class="category-list-count">14</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/">工作應用</a><span class="category-list-count">35</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/Meme/">Meme</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/可持久化/">可持久化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/鬼故事/">鬼故事</a><span class="category-list-count">12</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/手札日記/">手札日記</a><span class="category-list-count">47</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/">網頁設計</a><span class="category-list-count">15</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/About-This-Blog/">About This Blog</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/HTML5/">HTML5</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/JQuery/">JQuery</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/Markdown/">Markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/NodeJs/">NodeJs</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/">解題區</a><span class="category-list-count">633</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/Latex/">Latex</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/出題解題/">出題解題</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-POJ/">解題區 - POJ</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-UVa/">解題區 - UVa</a><span class="category-list-count">483</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-Zerojudge/">解題區 - Zerojudge</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-其他題目/">解題區 - 其他題目</a><span class="category-list-count">45</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-未解題目/">解題區 - 未解題目</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/雜言筆記/">雜言筆記</a><span class="category-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="text" href="/2021/08/15/diary-202108/">
              
                <i class="icon-file-o"></i> 
              
            被預告要開始管人的我，今天開始學管理？</a>
          </li>
        
          <li>
            <a class="text" href="/2021/08/14/work/company-ghost-story-12/">
              
                <i class="icon-file-o"></i> 
              
            Company Ghost Story 公司鬼故事 12</a>
          </li>
        
          <li>
            <a class="text" href="/2021/07/29/java/java-jni-tls-error-2/">
              
                <i class="icon-file-o"></i> 
              
            Java JNI GC Thread Error (EINVAL)</a>
          </li>
        
          <li>
            <a class="text" href="/2021/07/29/work/company-ghost-story-11/">
              
                <i class="icon-file-o"></i> 
              
            Company Ghost Story 公司鬼故事 11</a>
          </li>
        
          <li>
            <a class="text" href="/2021/06/21/diary-202106/">
              
                <i class="icon-file-o"></i> 
              
            疫情下的工作變化</a>
          </li>
        
          <li>
            <a class="text" href="/2021/06/21/work/company-ghost-story-10/">
              
                <i class="icon-file-o"></i> 
              
            Company Ghost Story 公司鬼故事 10</a>
          </li>
        
          <li>
            <a class="text" href="/2021/05/30/diary-202105/">
              
                <i class="icon-file-o"></i> 
              
            前思後想 新居落成</a>
          </li>
        
          <li>
            <a class="text" href="/2021/05/30/java/java-memory-optimization-2/">
              
                <i class="icon-file-o"></i> 
              
            Java 優化內存使用 組合篇</a>
          </li>
        
          <li>
            <a class="text" href="/2021/05/30/java/java-memory-optimization-1/">
              
                <i class="icon-file-o"></i> 
              
            Java 優化內存使用 結構篇</a>
          </li>
        
          <li>
            <a class="text" href="/2021/01/31/diary-202101/">
              
                <i class="icon-file-o"></i> 
              
            二八進展</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">   
        <ul>
          <li><a href="http://mypaper.pchome.com.tw/zerojudge" target="_blank" title="Old Blog"><i class="icon-star"></i> Morris' Blog (pchome)</a></li>
        </ul>
    </div>
</div>

  
    
<script src="/js/jquery-ui.js"></script>
<script src="/js/ukagaka/jquery.morris.ukagaka.resource.js"></script>
<script src="/js/ukagaka/typed.js"></script>
  
  
</aside>
          
        
      </div>
      <footer id="footer">
  
  <div class="outer">    
    <div class="social-group">
      
      <a href="https://github.com/morris821028" target="_blank" title="github"><i class="icon-github"></i></a>
      
      
      <a href="https://www.facebook.com/Morris1028" target="_blank" title="facebook"><i class="icon-facebook-sign"></i></a>
      
      
      <a href="http://uhunt.felix-halim.net/id/46705" target="_blank" title="uhunt" ><span class="icon-uhunt">UVa<span></a>
      
    </div>
    <div id="footer-info" class="inner">
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/morris821028/hexo-theme-landscape" target="_blank" title="landscape">landscape</a> &copy; 2021 Shiang-Yun Yang 
    </div>
  </div>
</footer>


    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link"><i class=icon-home ></i>&nbsp&nbspHome</a>
  
    <a href="/about" class="mobile-nav-link"><i class=icon-user ></i>&nbsp&nbspAbout</a>
  
    <a href="/archives" class="mobile-nav-link"><i class=icon-archive ></i>&nbsp&nbspArchives</a>
  
    <a href="/tags" class="mobile-nav-link"><i class=icon-tags ></i>&nbsp&nbspTags</a>
  
    <a href="/picture" class="mobile-nav-link"><i class=icon-camera ></i>&nbsp&nbspPictures</a>
  
    <a href="/works" class="mobile-nav-link"><i class=icon-trophy ></i>&nbsp&nbspWorks</a>
  
</nav>
    
<script>
  var disqus_shortname = 'morris1028';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/jquery.lazyload.js"></script>
<script src="/js/jquery.als-1.6.js"></script>

<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>