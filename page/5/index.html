<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Morris&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Morris&#39; Blog">
<meta property="og:url" content="http://morris821028.github.io/page/5/index.html">
<meta property="og:site_name" content="Morris&#39; Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Morris&#39; Blog">
<link rel="publisher" href="108158678174364350000">
  
    <link rel="alternative" href="/atom.xml" title="Morris&#39; Blog" type="application/atom+xml">
  
  
    <meta name="google-site-verification" content="5mRgj8NanEMpGZuNfHNJNmH90RgNlrnJXsFlTaKD6Gs" />
  
  
    <link rel="shortcut icon" href="/img/f.ico">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <script src="/js/jquery-2.1.0.min.js"></script>
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="http://cdn.oesmith.co.uk/morris-0.5.1.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"></script>
<script src="http://cdn.oesmith.co.uk/morris-0.5.1.min.js"></script>
  <!-- <link rel="import" href="/bower_components/app-layout/app-layout.html"> --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"><div id="banner-right"></div></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Morris&#39; Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          
            <a class="main-nav-link" href="/"><i class=icon-home title='Home'></i></a>
          
        
          
            <a class="main-nav-link" href="/about"><i class=icon-user title='About'></i></a>
          
        
          
            <a class="main-nav-link" href="/archives"><i class=icon-archive title='Archives'></i></a>
          
        
          
            <a class="main-nav-link" href="/tags"><i class=icon-tags title='Tags'></i></a>
          
        
          
            <a class="main-nav-link" href="/picture"><i class=icon-camera title='Pictures'></i></a>
          
        
          
            <a class="main-nav-link" href="/works"><i class=icon-trophy title='Works'></i></a>
          
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://morris821028.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        
          
          <section id="main">
  
    <article id="post-diary-202001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/06/diary-202001/" class="article-date">
  <time datetime="2020-01-06T07:23:53.000Z" itemprop="datePublished">2020-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/手札日記/">手札日記</a>
  </div>

  </div>
  <div class="article-inner ">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="https://i.imgur.com/HqLcuAj.jpg" rel="gallery_ckvd6e82m00489cvnbx30yo2i">
        <img src="https://i.imgur.com/HqLcuAj.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/06/diary-202001/">糾纏與糾結</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2020/01/06/diary-202001/" data-id="ckvd6e82m00489cvnbx30yo2i" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2020/01/06/diary-202001/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>距離上一次編寫日記到現在已過五個月，累積著不同的經歷與感受，才能寫出一篇有所不同的日記。然而，工作後每天回寢室不是睡覺就是打個遊戲，周末也沒特別想做什麼，完全地放空就是最好的休閒，這使得寫一篇文章又變得更加困難。一成不變的煩惱，到底能寫些什麼。</p>
<h3 id="單元測試"><a href="#單元測試" class="headerlink" title="單元測試"></a>單元測試</h3><p>這幾個月來，總算把單元測試拉了起來，從原本代碼覆蓋率 1% 拉到 6%，測試數量十幾拉到四百多個，這過程最痛苦的就是慢慢將所有代碼重新審視，就會開始發現一堆函數不同名稱卻功能相似，甚至是子集合的概念。有人會說「至少沒錯啊，你改那個做什麼」。的確，只是重複的代碼多了一點，但後續的維護就非常痛苦，一旦這重複的代碼中出了 BUG，我們花了九牛二虎之力修了它，卻發現到處都有，這時候心裡不鬱悶嗎？</p>
<p><img src="https://i.imgur.com/MNJEmSE.jpg" alt="「感覺超沮喪的」－《這個勇者明明超TUEEE卻過度謹慎》"></p>
<p>程式碼多寡會影響效能嗎？大部分的情況並不會，但是對於 Java 的 JIT 而言，跑越多次的代碼它就會更進一步地優化，把沒有用處的代碼移除，做到跟 GCC O2 的效果類似。這其中最困難的處理操作為另一個函數的子集，大部分的情況下，直接導向到另一個函數是沒有問題的，例外是時間複雜度增加與例外處理的不同，為了處理更複雜的情況，功能越強的函數通常都會有一些額外的邊際效應 (side effect)，這時候就要非常小心。</p>
<p>於是每天就是把上千行代碼、數百條函數裝進腦子裡，然後攪一攪把相同功能的代碼移除。好比，判斷一個圖是否同構，這基本上已經接近 NP-Complete 問題，一下子腦子運轉就會過熱，無法去思考其他的項目。有些人的腦子的確可以完全阻隔思考吧，但是對我來說，潛意識帶動的壓迫卻是無盡的痛苦。</p>
<p><img src="https://i.imgur.com/4U63dKp.jpg" alt="《這個勇者明明超TUEEE卻過度謹慎》"></p>
<p>做這一些很無趣，出於使命必須審視它，不然每次呼叫函數都不確定自己在處理什麼，甚至傳錯了組態也不會噴任何錯誤。於是開始加起了無數的防火牆，各種防禦性編程的代碼。果真還有不少代碼使用錯了，造成永遠拿到錯誤的結果，那問題就擴散出去，於是又針對相關函數進行修改，連帶回歸測試都要更新，工程浩大卻沒有產出。</p>
<p><img src="https://i.imgur.com/2mHyJfe.jpg" alt="《這個勇者明明超TUEEE卻過度謹慎》"></p>
<p>這過程發現一些無理的要求，發現自己努力了好幾個月，依然會有人亂加函數，要解決問題，果然還是要拔除源頭。傳了個完全不到的參數，還特地做了重載 (overloading)，此時心裡就納悶了，這傢伙到底是怎麼想的？「因為原先的代碼我不敢改，但是為了效能我複製了一份，又怕自己忘記於是弄了相同的函數名稱 …」這樣子我有點明白了，永遠不該去用常理去看待問題，問題就是那些思維上的漏洞。</p>
<p>架設了 SonarQube 這一類的代碼品質監控後，上千個 bug、vulnerability 和數萬的 code smell，這幾個月終於把前者壓到三位數，目標是控制在一百內。在這五十萬行的裡，多半程式根本不會用到，也不會讓使用者觸及到。那修到底有什麼動力嗎？只有一個，因為初學者會複製類似的行為，做出一樣的蠢事。</p>
<p>公司在美國那裡的新成員，開始寫的時候總會搞不清楚 Java 的特性，就像從 C++ 跳過來的孩子，常常會忘東忘西地，不斷地複製類似的代碼片段來做事，就像字串常量常常會到處冒出來，實際上這些常量如果會一起變動，就應該用一個變數去取代之，這也方便我們去追蹤使用情況。實際的結果不是，造成了無數問題，升級版本的時候，常量到處找，耗費工時又一堆 bug 有待追蹤。</p>
<h3 id="資料庫"><a href="#資料庫" class="headerlink" title="資料庫"></a>資料庫</h3><p>因為製程的進展，大廠開始要求效能，來解決上億物件的資料庫問題，物件存取速度要快，開檔存檔都要更進一步加速。於是又開始放下那些代碼的修正，跑回去研讀資料庫相關的處理，由於 EDA 工具總是自己刻一個資料庫，方便規則的變化以及升降版本之間的問題，更提供鬆散的客製化需求，相當於要求自己刻一個嚴謹的資料庫介面。</p>
<p>除了資料庫的基本理論，還有牽涉到開檔讀檔這種小眾知識，解壓縮與壓縮的效能，在每一個階段的每一種算法中追求內存用量最少，額外宣告變數量最少，盡可能使用位址定位等等，每一步都要精準到位，當處理數量破億時，問題就會放大得相當嚴重。就像原本內存 50 GB 可以開起來，修改完卻變成 100 GB 才能使用，這種算法常數的影響就很嚴重，這些問題甚至不是整體的結果，而是處理的過程。也就是說，甚至要最小化中間過程，否則造成某個時間點是達不到運行需求。最後，記憶體用量少一半，存取速度快兩倍之多。</p>
<p>在這過程中，見識到了各種邪門歪道的升降版本的修正技術，這也造成了無數相依性問題。例如在這個時間點，你所請求的物件並未存在，實際上這段代碼毫無作用，卻也活了無數年，沒有人測試過它，看起來又相當合理。陸陸續續地將這些問題分析與移除，有時不小心修正了，激活了無數功能，卻要花時間更新好幾條的回歸測試。</p>
<p>資料庫接口的重要性影響著整個軟體的效能與穩定性，有時會有人受不了效能而開啟平行計算，那首先的問題是「<strong>為什麼會慢？</strong>」，並不是單純地「因為慢，所以開平行。」一旦開平行下去，有些問題可能不是真的問題，因為 GC 在平行情況下，遮掩著你對剖析器 (profiler) 的觀感，因為整個停頓點如果偏移一點，就會造成優化的方向都不對。</p>
<p>這麼說也許是理論派吧，信者恆信。因為能解決問題的方法，總是把原先的解法全部砍掉重做，要拿這些說服別人的確是難上加難，這裡也許該相信未來會解決吧，總有一個人會跳出來滅了這個火，也許是像神一般的編譯器、或者是 AI 可以幫你除錯並修改，就不再提及了這些公司鬼故事。</p>
<p><img src="https://i.imgur.com/90JSK2I.jpg" alt="「我已經沒有什麼可以失去的」－《BEASTARS》]"></p>
<h2 id="周末"><a href="#周末" class="headerlink" title="周末"></a>周末</h2><p>其實已經沒小夥伴在玩楓之谷，身邊認識的人也不會玩這種遊戲，大多都是課金到滿的手機遊戲或者單機遊戲。逐漸地，也不是很想玩遊戲，王沒課金也打不贏，花時間也無法達到那個境界，跟團又要看別人臉色和時間。玩遊戲各路牛馬鬼神的人都有，跟不同文化背景的人打交道相當不容易。</p>
<p>最後，我仍選擇了淡出，周末坐在電腦桌前，開著麥克風，要講著自己不太喜歡的詞，看著那無法理解的笑點，時間久了喉嚨不好受。每天上線，還會有一些不雅遊戲暱稱的人騷擾，不知道是吃飽閒著還怎麼的，難道就這麼有趣嗎？即使封鎖拉黑都沒有，這樣的情況持續一個多月，嘗試去找兇手，卻總是沒有任何音訊。</p>
<p>奇怪的是，總能挑到上線的時候發出訊息，非常高的機率是相關人士。後來有一天，群組還是透露了他們其實都知道是誰搞得，還給出了一堆提示後，仍然不願意告訴我那個混蛋是誰。這樣的狀況仍持續了幾周，依舊只說了「如果要答案的話，下一次線下聚會就跟你說。」，這種說詞，徹底讓我貫穿了所有雲雨。</p>
<p>明知答案為何，卻老是不願意透露。這讓我想到寫了幾千題的過程中，遇過一些人也採用類似的策略，終究也沒辦法從之獲得什麼，那一種糾結始終在我心裡迴盪。有一天，我突然想到自己那種快樂遊玩的感覺沒了，都是在過程中想辦法找到玩下去的理由，開始剝離原先的群組，也不需要什麼理由，我累了，在尋找那簡單快樂的旅途中累了。</p>
<p><img src="https://i.imgur.com/YwRTjUM.jpg" alt="「我果然是累了吧」－《這個勇者明明超TUEEE卻過度謹慎》"></p>
<p>接下來的幾周，逐漸地縮短遊戲時間，開始想了當初一些還沒做好的事情，整理一些瑣事，跑了一些實驗驗證算法。在房裡發呆也好，不跟人說話也罷，那一種重新探求的感覺，心想還可以持續多久？</p>
<p>年底的最後幾周，拾起了論文，開著 sci-hub 下載論文來看，嘗試解決當年規劃的藍圖，藍圖都還沒做好，卻發現了工作上更多的問題，甚至還找到了原生 JDK bug，這也解釋了為什麼老是愛開平行解決事情，這都還只是附加產物。印出了一疊論文在公司裡放著，稍微有空閒的時候看。</p>
<p>如果能解決根本問題，不需要研究論文的話，其實也不用這麼痛苦地看論文。若在公司要分享論文知識，或者請求別人一起努力什麼的，這是不太可能的。曾經與同事這麼說道「這個問題很難，總是要有人去犧牲、去解決的，看論文也是這個原因」，得到的回應卻是「那你去犧牲吧」。也許，不經意的一句話才是現實的<strong>真相</strong>。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p><img src="https://i.imgur.com/jNnKsyt.jpg" alt="「不過我的生活方式」－《BEASTARS》"></p>
<p>沒有。</p>
<p>這些日子研究了一些持久化結構，但我的生活卻不會這麼地持久。</p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-mproblem-persistent-array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/06/mproblem-persistent-array/" class="article-date">
  <time datetime="2020-01-05T23:26:10.000Z" itemprop="datePublished">2020-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作應用/">工作應用</a>/<a class="article-category-link" href="/categories/工作應用/可持久化/">可持久化</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/06/mproblem-persistent-array/">可持久化陣列 Persistent Array 始</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2020/01/06/mproblem-persistent-array/" data-id="ckvd6e85f00bs9cvnz3xqvufs" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2020/01/06/mproblem-persistent-array/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/array/">array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可持久化/">可持久化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/陣列/">陣列</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="回顧"><a href="#回顧" class="headerlink" title="回顧"></a>回顧</h2><p>幾年前，跟 liouzhou101 一起搞了很多記憶中系列題目，有一題與陣列很相似，但操作更複雜一些。陣列的操作只有下列幾種</p>
<ul>
<li><code>get(index)</code>: 回傳索引為 index 的元素，其中 <span>$\text{index} \in \left [0, n-1 \right ]$</span><!-- Has MathJax --></li>
<li><code>set(index, value)</code>: 修改 index 上的元素</li>
<li><code>pushBack(value)</code>: 陣列尾端後接一個新的元素</li>
<li><code>popBack()</code>: 移除陣列尾端的最後一個元素</li>
</ul>
<p>從演算法課程中，我們學到 C++ 中的 <code>std::vector</code> 可以做到均攤 <span>$\mathcal{O}(1)$</span><!-- Has MathJax -->，其大致的做法為陣列快填滿容量時，倍增其大小後轉移原先的所有元素到新的容器上，均攤計算為每次增加的元素都需要預先支付未來轉移自己、轉移對應的另一個元素、移除自己、移除對應的另一個元素的花費，因此均攤花費為常數。</p>
<p>而這樣子的均攤操作在可持久化卻是不利的，因為單一操作的最慘複雜度為 <span>$\mathcal{O}(n)$</span><!-- Has MathJax -->，意味著可能在同一個操作上，使用 <span>$m$</span><!-- Has MathJax --> 次持久化會造成時間複雜度退化成 <span>$\mathcal{O}(mn)$</span><!-- Has MathJax -->。因此，我們需要最小化最慘時間複雜度的結構。</p>
<p>當年初學者的我，切入觀點有二元樹 (binary tree)、塊狀表 (unrolled linked list)，前者讓操作必為 <span>$\mathcal{\Theta}(\log n)$</span><!-- Has MathJax -->、後者為 <span>$\mathcal{\Theta}(\sqrt{n})$</span><!-- Has MathJax -->，從理論分析上一定優先選擇前者實作，但如果操作有特別的比例問題，如 <code>get(index)</code>、<code>pushBack()</code> … 等，這時候快取能力好的塊狀表反而有優勢，二元樹因指標的使用導致整體的內存使用率不高，透過 2-3 tree 那一種將節點儲存多個元素的設計，就相當於把塊狀表拉成樹狀，其效果也不錯，但在計算上會更需要耗費工夫。</p>
<h2 id="塊狀表-Unrolled-Linked-List"><a href="#塊狀表-Unrolled-Linked-List" class="headerlink" title="塊狀表 (Unrolled Linked List)"></a>塊狀表 (Unrolled Linked List)</h2><p>任何操作皆為 <span>$\mathcal{\Theta}(\sqrt{n})$</span><!-- Has MathJax -->，修改操作皆需要複製整個節點。在可持久化情況時，預先每一個塊的大小較為不可行，故做不到動態調整塊狀大小。</p>
<h2 id="二元樹-Binary-Tree"><a href="#二元樹-Binary-Tree" class="headerlink" title="二元樹 (Binary Tree)"></a>二元樹 (Binary Tree)</h2><p>利用二元樹建立可持久化的情況有很多種編碼，以及紀錄節點的優化方式，這將會影響到我們的效率。盡可能地不在節點中儲存欄位 <code>size</code> 即可達到索引。若二元樹節點定義為</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    Node *lson;</div><div class="line">    Node *rson;</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line">    T value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>葉與內部節點皆帶有元素值，那麼在陣列的新增刪除尾端的操作，我們可以透過類似 heap 的方式，將其設計成不用旋轉操作、不用紀錄樹大小的編碼。當節點編碼為 <span>$k$</span><!-- Has MathJax -->，則兩個子節點 <span>$2k$</span><!-- Has MathJax --> 和 <span>$2k+1$</span><!-- Has MathJax -->，實作時只需要紀錄整體大小，接著在走訪過程中，採用位元運算得到其子樹大小作為操作依據。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      1</div><div class="line">     / \</div><div class="line">    2   3</div><div class="line">   / \ / \</div><div class="line">  4  5 6 7</div><div class="line"> /</div><div class="line">8</div></pre></td></tr></table></figure>
<p>這樣的編碼問題，對於陣列實作時，發現 <code>push/set(index, value)</code> 時，時間複雜度為 <span>$\mathcal{\Theta}(\log \text{index})$</span><!-- Has MathJax -->，那動態將 <span>$n$</span><!-- Has MathJax --> 個元素推入的時間必為 <span>$\mathcal{\Theta}(n \log n)$</span><!-- Has MathJax -->，靜態建造則為 <span>$\mathcal{\Theta}(n)$</span><!-- Has MathJax -->。索引值越大的元素，其操作花費越高。</p>
<p>設計函數庫時，我們通常希望盡可能地讓複雜度對稱，也就是兩端的索引速度不會差太多，即使是亂數也好，因為演算法設計、真實生活中的應用大多都會偏向一方，很可能總是觸發最慘情況。</p>
<h3 id="Braun-Tree"><a href="#Braun-Tree" class="headerlink" title="Braun Tree"></a>Braun Tree</h3><p>另一種編碼設計，對於每一個節點皆滿足右子樹大小最多比左子樹大小多一個，由於每一個節點都滿足，按照插入順序，可以得到下圖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          1</div><div class="line">     2         3</div><div class="line"> 4     6    5     7</div><div class="line">8 10 12 14 9 11 13 15</div></pre></td></tr></table></figure>
<p>明顯地，如同霍夫曼編碼一樣，這一個 1-indexed 的情況，最低位 0 則往左子樹、反之為右子樹。每一個操作皆為對稱的，但複雜度如同一般的二元搜尋樹，作為陣列操作也不滿足期待。</p>
<p>若用於可持久化陣列的基底，代碼量非常少，遞迴定義使得操作簡單，我們甚至可以連整體大小都不用儲存，透過其遞迴定義可在 <span>$\mathcal{O}(\log^2 n)$</span><!-- Has MathJax --> 得到，但大部分陣列使用都是會希望 <code>A.size()</code> 是可以在 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 完成的。這樣的設計在優先隊列 (priority queue) 更友善，因為鮮少需要去拿到 <code>size</code>，只需要回傳這個優先隊列是否為空。</p>
<p>同樣地，這依舊不是實作可持久化陣列的首選。</p>
<h2 id="線段樹-Segment-Tree"><a href="#線段樹-Segment-Tree" class="headerlink" title="線段樹 (Segment Tree)"></a>線段樹 (Segment Tree)</h2><p>線段樹的設計有一個缺點，大部分的情況總是預先知道大小，然後再代入修改操作。</p>
<p>如果要做到動態的增加大小，則採用 top-down 的展開節點方法。如根節點一開始設計範圍為 <span>$\left [0, 2^{32} \right ]$</span><!-- Has MathJax -->，當我們 push 一個新的元素至尾端時，相當於開出一個葉節點為 <code>index = size</code>，同理 pop 操作。一開始預設最大上限 <span>$M$</span><!-- Has MathJax -->，單一操作的時間複雜度必為 <span>$\mathcal{\Theta}(\log M)$</span><!-- Has MathJax -->。</p>
<p>以上述的狀況，每一次操作複雜度必為 <span>$32$</span><!-- Has MathJax -->，作為函數庫的設計而言，這樣的寫法沒有彈性，而且要是未來超出指定大小，修改就非常的緩慢，更因為在持久化的環境下，不可能在對數時間內轉移其架構。</p>
<h2 id="Leftist-Leaf-Tree"><a href="#Leftist-Leaf-Tree" class="headerlink" title="Leftist Leaf Tree"></a>Leftist Leaf Tree</h2><p>其概念類似二項堆積 (binomial heap)，我們將使用 <span>$\log n$</span><!-- Has MathJax --> 棵樹表示整個序列。將內容放置於葉節點上，並且每一個樹皆為完美樹，無須額外紀錄子樹大小。</p>
<p>例如：當 <code>n = dec(11) = bin(1011)</code> 時，用三棵大小分別為 8, 2, 1 的樹表示之。當 push 一個新的元素至尾端時，與最右邊的子樹 1 合併成大小為 2 的樹，再與左邊的子樹合併成大小為 4 的子樹，最後成為 <code>n&#39; = dec(12) = bin(1100)</code>，用兩棵子樹表示之。同理 pop 操作，模擬二進制的退位。</p>
<p>每一個操作皆為 <span>$\mathcal{O}(\log n)$</span><!-- Has MathJax -->，且分布較為一般的二元樹均勻。並解決一開始我們在二元樹上遇到的問題，<strong>動態將 <span>$n$</span><!-- Has MathJax --> 個元素推入的時間</strong>，整體複雜度為 <span>$\mathcal{\Theta}(n)$</span><!-- Has MathJax -->。因此，這是目前實作可持久化隊列的首選。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>函數式理論複雜度最好的結構為 finger tree，實作複雜度相當高，卻具備了合併兩個陣列的特殊操作，這是以上結構皆不具有操作。實際的效能無法預測，通常常數過大而無法使用。有朝一日，我們再來挑戰這偉大的結構吧。</p>
<h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-work/persistent-motivation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/05/work/persistent-motivation/" class="article-date">
  <time datetime="2020-01-05T12:00:00.000Z" itemprop="datePublished">2020-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作應用/">工作應用</a>/<a class="article-category-link" href="/categories/工作應用/可持久化/">可持久化</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/05/work/persistent-motivation/">可持久化應用雜談</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2020/01/05/work/persistent-motivation/" data-id="ckvd6e93h02jg9cvnu273bnhn" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2020/01/05/work/persistent-motivation/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可持久化/">可持久化</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <p>可持久化的實際用途到底有哪些？這麼複雜的概念大部分場景都用不上？</p>
<h2 id="函數式編程"><a href="#函數式編程" class="headerlink" title="函數式編程"></a>函數式編程</h2><p>其不可變的需求，造就了持久化的使用。如果是可變的特性，函數式展開的一對多操作時，就會造成操作失效，除蟲大概是一輩子的痛。以 Java 的 Stream 為例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">paths.stream()</div><div class="line">     .flatMap(path -&gt; &#123;</div><div class="line">         <span class="keyword">return</span> Stream.of(path.add(a), path.add(b));</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<p>這樣的函數還算清晰好懂，一旦包了好幾層函數下去，就不曉得 path 到底是能不能被修改。如果不可被修改，意味著每一次都要回傳一個實例，那麼可想而知效能一定不會太高 (大部分的代碼都是整個數據複製)。別去想什麼黑魔法可以在常數時間解決、相信未來人可以穿越時空幫你完成即時計算。請面對現實，計算機終究還是一行一行去執行的。</p>
<p>在編程概念的分支中，函數式編程本身需要這一種技術，達到其函數定義的規範。這一種寫法的效能不好，能理解的人也不多，其一原因學校沒有強制要求去學，一開始都是從程序式、命令式、物件導向式著手居多，所以到工作階段也不太可能遇到大型程式的需求，不過一旦遇到就無可取代。</p>
<h2 id="離線算法"><a href="#離線算法" class="headerlink" title="離線算法"></a>離線算法</h2><p>將離線版本切換成強制在線，不用特別去構造一個全新的資料結構來解決問題，只需要預處理一部份的資料，並犧牲更多的記憶體空間來完成。</p>
<h3 id="幾何計算"><a href="#幾何計算" class="headerlink" title="幾何計算"></a>幾何計算</h3><p>在幾何計算中，有很多離線算法很容易被找到，一個掃描線掃過去回答所有問題，在時間複雜度分析上總是相當優異的。那如何強迫在線的情況下，每一次都掃描一次，詢問操作的時間複雜度就從對數時間降成線性。為了解決這一種情況，持久化技術給了另一種思維，我們將掃描線的時間軸作為一個變動依據，持久化相關的結構，只要我們能將詢問在對數時間內穿梭於這個時間軸，必能動態解決先前的問題。</p>
<ul>
<li>參考資料 <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2005/lecture-notes/persistent.pdf" target="_blank" rel="external">MIT 6.854  Advanced  Algorithms - Persistent Data Structures Notes</a></li>
</ul>
<h2 id="統計方法"><a href="#統計方法" class="headerlink" title="統計方法"></a>統計方法</h2><p>在 OI 界的經典問題，區間 K 大、攤平成一維陣列的相關計算，問題本身不帶修改操作，只詢問統計於此的統計操作。通常可以透過持久化結構來完成，區間就相當於時間軸，我們能針對兩個時間戳記之間的差異變化來完成統計。</p>
<h2 id="字串處理"><a href="#字串處理" class="headerlink" title="字串處理"></a>字串處理</h2><p>為了達到非常高效率的合併操作，防止大量重複性字串的生成伴隨的效能退化，使得各方面的操作都能遠低於線性操作。如 C++ rope 就是一個持久化的資料結構，</p>
<p>不只是字串操作，若處理類型有大量重複的情況，持久化的概念便能派上用場。</p>
<h2 id="版本回溯"><a href="#版本回溯" class="headerlink" title="版本回溯"></a>版本回溯</h2><p>實際上就是對應大部分的應用軟體中的 redo/undo。如果資料庫/操作變動為了高效率操作而會配上複雜的結構 (並不像 hash, set 反轉操作只需要常數或對數時間)，那麼為了快速回推變動結果，持久化結構就是要減少 redo/undo 的花費。</p>
<p>根據工作上遇到的經驗，資料庫本身可以常數回推，紀錄變動的部分情況即可。而應用層的計算，大部分實作都是砍掉快取，並且重新計算出一份新的結構，有時候回推的變動大小為 m，為了重新計算結構而消耗了 n+m，如果 n 和 m 的差距非常大，那連續回推的體感就很糟糕。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>更強硬一點的叫做 Confluent Persistence，可以讓兩個不同的版本合併一個版本，感覺起來就相當於兩個平行宇宙要合併，實際的應用更少一些，大部分應該是在兩個資料結構的合併，如兩個堆如何合併，兩棵伸展樹的合併 … 等的底層定義所需。</p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-mproblem-persistent-deque-pre-evaluation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/05/mproblem-persistent-deque-pre-evaluation/" class="article-date">
  <time datetime="2020-01-05T11:04:31.000Z" itemprop="datePublished">2020-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作應用/">工作應用</a>/<a class="article-category-link" href="/categories/工作應用/可持久化/">可持久化</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/05/mproblem-persistent-deque-pre-evaluation/">可持久化雙向隊列 Persistent Deque 續</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2020/01/05/mproblem-persistent-deque-pre-evaluation/" data-id="ckvd6e85j00c09cvnxpkveurj" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2020/01/05/mproblem-persistent-deque-pre-evaluation/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deque/">deque</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可持久化/">可持久化</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <p>接續前一篇 《可持久化雙向隊列 Persistent Deque 序》，同樣的概念，Okasaki 用了他那精妙的公式描述了前一篇採用的策略只不過是常數 <span>$c = 3$</span><!-- Has MathJax --> 的情況，實際上可以根據需求去改變常數 <span>$c$</span><!-- Has MathJax -->，先決條件 <span>$c \ge 2$</span><!-- Has MathJax -->。</p>
<h2 id="預先評估雙向隊列-Pre-Evaluation"><a href="#預先評估雙向隊列-Pre-Evaluation" class="headerlink" title="預先評估雙向隊列 (Pre-Evaluation)"></a>預先評估雙向隊列 (Pre-Evaluation)</h2><ul>
<li>SIMPLE AND EFFICIENT PURELY FUNCTIONAL QUEUES AND DEQUES, Chris Okasaki, 1995</li>
</ul>
<p>同樣地，雙向隊列為兩個堆疊表示，並限制其中一個大小不能大於另一個的 <span>$c$</span><!-- Has MathJax --> 倍，如果發生了用另一種方式表示部分翻轉的結果。</p>
<h3 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h3><span>$$\begin{aligned}
&amp; |L| \le c |R| + 1 \; \wedge \; |R| \le c |L| + 1\\
&amp; |\hat{L}| \le \max(2j+2-k, 0) \; \wedge \; |\hat{R}| \le \max(2j+2-k, 0) &amp;\\
&amp; \text{where} \; j = \min(|L|, |R|) \; \wedge \; k = \max(|L|, |R|)
\end{aligned}$$</span><!-- Has MathJax -->
<h3 id="Functional-Definition"><a href="#Functional-Definition" class="headerlink" title="Functional Definition"></a>Functional Definition</h3><span>$$\begin{align}
\left [ \; \right ]_{d} &amp;= \left \langle \left [ \; \right ], \left [ \; \right ], \left [ \; \right ], \left [ \; \right ] \right \rangle \\
|\left \langle L, R, \hat{L}, \hat{R}\right \rangle| &amp;= |L| + |R| \\
\textit{insert}L(e, \left \langle L, R, \hat{L}, \hat{R}\right \rangle) &amp;= \textit{makedq}\left \langle e:L, R, \textit{tl}\; \hat{L}, \textit{tl}\; \hat{R}\right \rangle \\
\textit{insert}R(e, \left \langle L, R, \hat{L}, \hat{R}\right \rangle) &amp;= \textit{makedq}\left \langle L, e:R, \textit{tl}\; \hat{L}, \textit{tl}\; \hat{R}\right \rangle \\
\textit{remove}L\left \langle L, R, \hat{L}, \hat{R}\right \rangle &amp;= \left \langle \textit{hd}\; R, \left [ \; \right ]_d \right \rangle &amp; \left \{ |L| = 0 \right \}\\
&amp;= \left \langle \textit{hd}\; L, \textit{makedq} \left \langle \textit{tl} \; L, R, \textit{tl} \; (\textit{tl} \hat{L}), \textit{tl} \; (\textit{tl} \hat{R}) \right \rangle \right \rangle &amp; \left \{ |L|&gt; 0 \right \}\\
\textit{remove}R\left \langle L, R, \hat{L}, \hat{R}\right \rangle &amp;= \left \langle \textit{hd}\; L, \left [ \; \right ]_d \right \rangle &amp; \left \{ |R| = 0 \right \}\\
&amp;= \left \langle \textit{hd}\; R, \textit{makedq} \left \langle L, \textit{tl} \; R, \textit{tl} \; (\textit{tl} \hat{L}), \textit{tl} \; (\textit{tl} \hat{R}) \right \rangle \right \rangle &amp; \left \{ |R|&gt; 0 \right \}\\
\textit{makedq}\left \langle L, R, \hat{L}, \hat{R}\right \rangle &amp;= \left \langle \hat{L}, \hat{R}, \hat{L}, \hat{R} \right \rangle, \; 
\begin{aligned}
\text{let} \; n &amp;= \left \lfloor (|L| + |R|)/2 \right \rfloor \\
L&apos; &amp;= \textit{take}(n, L) \\
R&apos; &amp;= \textit{rot1}(n, R, L) 
\end{aligned} &amp; \left \{ |L| &gt; c |R| + 1 \right \} \\
&amp;= \left \langle \hat{L}, \hat{R}, \hat{L}, \hat{R} \right \rangle, \; 
\begin{aligned}
\text{let} \; n &amp;= \left \lfloor (|L| + |R|)/2 \right \rfloor \\
L&apos; &amp;= \textit{rot1}(n, L, R) \\
R&apos; &amp;= \textit{take}(n, R) 
\end{aligned} &amp; \left \{ |R| &gt; c |L| + 1 \right \} \\
&amp;= \left \langle L, R, \hat{L}, \hat{R} \right \rangle &amp; \left \{ \text{otherwise} \right \} \\
\textit{rot1}(n, L, R) &amp;= \textit{hd} \; L : \; \textit{rot1}(n-c, \textit{tl}\; L, \textit{drop}(c, R)) &amp; \left \{ n \ge c \right \} \\
&amp;= \textit{rot2}(L, \textit{drop}(n, R), \left [ \; \right ]) &amp; \left \{ n &lt; c \right \} \\
\textit{rot2}(L, R, A) &amp;= \textit{hd}\; L : \; \textit{rot2}(\textit{tl}\; L, \textit{drop}(c, R), \textit{rev}(\textit{take}(c, R)) + A) &amp; \left \{ |L| &gt; 0 \wedge |R| \ge c \right \}  \\
&amp;= L + \textit{rev}R + A &amp; \left \{ |L| = 0 \vee |R| &lt; c \right \} 
\end{align}$$</span><!-- Has MathJax -->
<p>放眼望去共計 15 條式子，而一半都是對稱操作。唯獨在式 12 到 式 15 較為特別，相當於前一篇的反轉操作，只是我們透過額外的定義來描述它，實作時相當多一個類別。不管是記憶體分析、還是時間複雜度分析，原則上與前一篇是相同的。</p>
<p>公式裡描述了一堆的 <span>$\hat{L}, \; \hat{R}$</span><!-- Has MathJax -->，我們卻沒有在任何的條件式中使用，只作為我們去理解操作的含意。因此，實作時只在 <span>$makedq$</span><!-- Has MathJax --> 區域變數中作用，並不會成為一個必要紀錄的值。</p>
<p>特別注意到建構子中，令 <span>$R&apos; = \textit{rot1}(n, R, L)$</span><!-- Has MathJax -->，這個操作可能直接成為 <span>$\textit{rot2}(L, \textit{drop}(n, R), \left [ \; \right ])$</span><!-- Has MathJax -->，思維必須往前看一步去轉化所有實際的類別，否則很容易在相關操作退化。因為 <span>$L, \; R$</span><!-- Has MathJax --> 都是作為 rot1 或者是 rot2 後的產物，盡可能地使之成為最簡單的表達式。</p>
<h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-mproblem-persistent-deque" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/01/mproblem-persistent-deque/" class="article-date">
  <time datetime="2020-01-01T11:59:02.000Z" itemprop="datePublished">2020-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作應用/">工作應用</a>/<a class="article-category-link" href="/categories/工作應用/可持久化/">可持久化</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/01/mproblem-persistent-deque/">可持久化雙向隊列 Persistent Deque 序</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2020/01/01/mproblem-persistent-deque/" data-id="ckvd6e85k00c39cvnl8kemoa2" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2020/01/01/mproblem-persistent-deque/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deque/">deque</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可持久化/">可持久化</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <p>完成了一般隊列，接下來就是雙向隊列，這個時候操作就沒有強烈的單調方向性質，需要同時維護兩種入隊、出隊的情況。</p>
<p>沿用可持久化隊列的思路。在隊列時，我們評估情況為前後各一半，預估反轉的結果，均攤每一個操作費用，一旦前半部為空，立即使用反轉完的結果。而雙向的情況更為複雜，我們若按照隊列的方式，那麼在 pop-back 的時候，預估的結果反而成為了阻礙，因為要再反轉一次回來。為此調整鬆弛反轉的限制。</p>
<h2 id="即時雙向隊列-Realtime"><a href="#即時雙向隊列-Realtime" class="headerlink" title="即時雙向隊列 (Realtime)"></a>即時雙向隊列 (Realtime)</h2><ul>
<li>REAL-TIME DEQUES, MULTIHEAD TURING MACHINES and PURELY FUNCTIONAL PROGRAMMING, Tyng-Runey Chuang and Benjamin Goldberg, 1993</li>
</ul>
<h3 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h3><p>定義雙向隊列為 <span>$Q = \left \langle L, \; R \right \rangle$</span><!-- Has MathJax --></p>
<p>在操作過程中，可以鏡像狀態，令較大的那一個為 <span>$B$</span><!-- Has MathJax -->，較小的為 <span>$S$</span><!-- Has MathJax -->，意即 <span>$\left \langle B, \; S \right \rangle = \left \langle L, \; R \right \rangle$</span><!-- Has MathJax --> 或者 <span>$\left \langle B, \; S \right \rangle = \left \langle R, \; L \right \rangle$</span><!-- Has MathJax -->。需滿足</p>
<span>$$\begin{aligned}
|B| \ge |S| \ge 1, \; \text{and} \; 3|S| \ge |B|
\end{aligned}$$</span><!-- Has MathJax -->
<p>若違反上述條件，立即進入 <strong>轉移狀態</strong>，將三分之一的 <span>$B$</span><!-- Has MathJax --> 搬入 <span>$S$</span><!-- Has MathJax -->，此時兩者具有近似的大小。在轉移中，我們可能在過程中將其中一方增減，完成轉移後必要滿足條件式。</p>
<h3 id="轉移狀態"><a href="#轉移狀態" class="headerlink" title="轉移狀態"></a>轉移狀態</h3><p>令起始轉移狀態為 <span>$\left \langle S, \; B \right \rangle$</span><!-- Has MathJax -->，其中</p>
<ul>
<li><span>$S = (p_1, p_2, \cdots, p_m)^\triangleleft$</span><!-- Has MathJax --></li>
<li><span>$B = (q_1, q_2, \cdots, q_{3m+k})^\triangleright$</span><!-- Has MathJax --></li>
<li><span>$k \in \left \{ 1, 2, 3\right \}$</span><!-- Has MathJax -->
</li>
</ul>
<p>目標狀態 <span>$\left \langle \textit{new}S, \; \textit{new}B \right \rangle$</span><!-- Has MathJax --></p>
<ul>
<li><span>$\textit{new}S = (p_1, p_2, \cdots, p_m, q_1, q_2, \cdots, q_{m+1})^\triangleleft$</span><!-- Has MathJax --></li>
<li><span>$\textit{new}B = (q_{m+2}, q_{m+3}, \cdots, q_{3m+k})^\triangleright$</span><!-- Has MathJax -->
</li>
</ul>
<p>必須均攤在 <span>$m$</span><!-- Has MathJax --> 次操作內完成，而舊有的 <span>$S$</span><!-- Has MathJax --> 可能在轉移中被 pop 到空集合，需要標記複製成功的次數，直到 <span>$\textit{new}S$</span><!-- Has MathJax --> 已經匹配了前半部的 <span>$S$</span><!-- Has MathJax -->。</p>
<ol>
<li><span>$B = (q_1, q_2, \cdots, q_{3m+k})^\triangleright$</span><!-- Has MathJax --> 拆分成<br> <span>$B = (q_1, q_2, \cdots, q_{m+1})^\triangleright$</span><!-- Has MathJax --> 和 <span>$\textit{aux}B = (q_{m+2}, q_{m+2}, \cdots, q_{3m+k})^\triangleleft$</span><!-- Has MathJax --></li>
<li><span>$\textit{new}S = (p_1, p_2, \cdots, p_m)^\triangleleft$</span><!-- Has MathJax --> 反轉成<br> <span>$S = ()^\triangleleft$</span><!-- Has MathJax --> 和 <span>$\textit{aux}S = (p_1, p_2, \cdots, p_m)^\triangleright$</span><!-- Has MathJax --></li>
<li><span>$\textit{aux}B = (q_{m+2}, q_{m+2}, \cdots, q_{3m+k})^\triangleleft$</span><!-- Has MathJax --> 反轉成<br> <span>$\textit{aux}B = ()^\triangleleft$</span><!-- Has MathJax --> 和 <span>$\textit{new}B = (q_{m+2}, q_{m+2}, \cdots, q_{3m+k})^\triangleright$</span><!-- Has MathJax --></li>
<li><span>$B = (q_1, q_2, \cdots, q_{m+1})^\triangleright$</span><!-- Has MathJax --> 放入為<br> <span>$\textit{new}S = (q_1, q_2, \cdots, q_{m+1})^\triangleleft$</span><!-- Has MathJax --> 和 <span>$B = ()^\triangleright$</span><!-- Has MathJax --></li>
<li><span>$\textit{aux}S = (p_1, p_2, \cdots, p_m)^\triangleright$</span><!-- Has MathJax --> 也放入為<br> <span>$\textit{new}S = (p_1, p_2, \cdots, p_m, q_1, q_2, \cdots, q_{m+1})^\triangleleft$</span><!-- Has MathJax --> 和 <span>$\textit{aux}S = ()^\triangleright$</span><!-- Has MathJax -->
</li>
</ol>
<p>步驟 1 和 2 同時操作，總數至多為 <span>$2m+3$</span><!-- Has MathJax -->。步驟 3 可以和 4 或 5 其中一種同時操作，總數至多為 <span>$2m+3$</span><!-- Has MathJax -->，因此操作數為 <span>$4m+6$</span><!-- Has MathJax -->。均攤在 <span>$m$</span><!-- Has MathJax --> 次操作內，得到常數因子為 4。</p>
<h3 id="隊列操作說明"><a href="#隊列操作說明" class="headerlink" title="隊列操作說明"></a>隊列操作說明</h3><p>即使說明了轉移方程，主要的問題還是卡在做到 push/pop</p>
<ul>
<li><code>pushFront</code>/<code>pushBack</code> 若<strong>計算完的雙向隊列大小</strong>小於等於 4 時，採用攤平的方式操作，強制不進入上述轉移條件。反之，直接在相應的堆疊上操作。</li>
<li><code>popFront</code>/<code>popBack</code> 若<strong>計算完的雙向隊列大小</strong>小於 4 時，採用攤平的方式操作，強制不進入上述轉移條件。反之，直接在相應的堆疊上操作。</li>
</ul>
<p>額外維護的指針告訴我們複製的 <span>$S$</span><!-- Has MathJax --> 狀態，而 <span>$B$</span><!-- Has MathJax --> 也會在過程中被 pop 出去，因此 <span>$\textit{new}B$</span><!-- Has MathJax --> 有時會需要代入 <span>$\text{Take}$</span><!-- Has MathJax --> 操作。</p>
<h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-mproblem-persistent-queue-pre-evaluation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/25/mproblem-persistent-queue-pre-evaluation/" class="article-date">
  <time datetime="2019-12-24T22:20:06.000Z" itemprop="datePublished">2019-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作應用/">工作應用</a>/<a class="article-category-link" href="/categories/工作應用/可持久化/">可持久化</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/25/mproblem-persistent-queue-pre-evaluation/">可持久化隊列 Persistent Queue 續</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2019/12/25/mproblem-persistent-queue-pre-evaluation/" data-id="ckvd6e85l00c69cvnxj3t158o" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2019/12/25/mproblem-persistent-queue-pre-evaluation/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/queue/">queue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可持久化/">可持久化</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <p>接續前一篇 《可持久化隊列 Persistent Queue 序》，開始搬運論文的內容，就當作個翻譯吧</p>
<h2 id="預先評估隊列-Pre-Evaluation"><a href="#預先評估隊列-Pre-Evaluation" class="headerlink" title="預先評估隊列 (Pre-Evaluation)"></a>預先評估隊列 (Pre-Evaluation)</h2><ul>
<li>SIMPLE AND EFFICIENT PURELY FUNCTIONAL QUEUES AND DEQUES, Chris Okasaki, 1995</li>
</ul>
<h3 id="初階定義"><a href="#初階定義" class="headerlink" title="初階定義"></a>初階定義</h3><p>定義：隊列 <span>$Q = \left \langle L, \; R \right \rangle$</span><!-- Has MathJax --> 且滿足 <span>$|R| \le |L|$</span><!-- Has MathJax --></p>
<span>$$\begin{aligned}
\left [ \; \right ]_{q} &amp;= \left \langle \left [ \; \right ], \left [ \; \right ] \right \rangle
\\
\\
|\left \langle L, \; R \right \rangle | &amp;= |L| + |R|
\\
\\
\textit{insert} \; (e, \left \langle L, \; R \right \rangle) &amp;= \textit{makeq} \; (L, \; e : R)
\\
\\
\textit{remove} \left \langle L, \; R \right \rangle &amp;= \left \langle \text{hd} \; L, \textit{makeq} \; (\text{tl} \; L, \; R) \right \rangle
\\
\\
\textit{makeq}  \left \langle L, \; R \right \rangle &amp;=  \left \langle L, \; R \right \rangle &amp;\{ |R| \le |L|\} \\
&amp;= \left \langle \textit{rot}(L, R, \left [ \; \right ]), \left [ \; \right ] \right \rangle &amp;\{ |R| = |L| + 1\}\\
\\
\textit{rot}(L, R, A) &amp;= \text{hd} \; R : A &amp; \{ |L| = 0 \} \\
                      &amp;= \text{hd} \; L : \textit{rot}(\text{tl} \; L, \text{tl} \; R, \text{hd} \; R : A) &amp; \{ |L| &gt; 0 \}
\end{aligned}$$</span><!-- Has MathJax -->
<p>看到這一大串的語法樹，就要開始構思曾經在編譯器學到的 LL Parser，操作完之後仍然是一個隊列，為了找到隊列的頭，我們要去完成 LL(1) 的計算，使用向前探查 (lookahead) 問第一個元素為何。</p>
<p>不幸地，上述語法的 <span>$\textit{remove}$</span><!-- Has MathJax --> 為 <span>$\mathcal{O}(\log n)$</span><!-- Has MathJax -->，其他操作為 <span>$\mathcal{O}(1)$</span><!-- Has MathJax -->。原因很簡單，當我們不斷地 <span>$\textit{insert}$</span><!-- Has MathJax --> 進去時，根據語法樹會不斷地構造長度為 <span>$1,\; 2,\; 4, \cdots, 2^n$</span><!-- Has MathJax --> 長度的 <span>$\textit{rot}$</span><!-- Has MathJax --> 堆疊，這時候若要看第一個元素為何，運算量就等同於遞迴深度。</p>
<p>縱使我們在每個堆疊建構時，預先計算出 <code>front()</code> 的結果，那麼在 <code>pop()</code> 回傳的時候，仍需要付出代價，而我們更不能在建構子中預先計算出 <code>pop()</code> ，這違反遞迴定義，更會落入退化成線性操作，而不是想要的惰性操作。當瞭解上述的問題後，接下來要想辦法把 <span>$\textit{remove}$</span><!-- Has MathJax --> 變成 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 操作。</p>
<h2 id="進階定義"><a href="#進階定義" class="headerlink" title="進階定義"></a>進階定義</h2><p>定義：隊列 <span>$Q = \left \langle L, \; R, \; \hat{L} \right \rangle$</span><!-- Has MathJax --> 且滿足 <span>$|R| \le |L| \wedge |\hat{L}| = |L| - |R|$</span><!-- Has MathJax --></p>
<span>$$\begin{aligned}
\left [ \; \right ]_{q} &amp;= \left \langle \left [ \; \right ], \left [ \; \right ], \left [ \; \right ] \right \rangle
\\
\\
|\left \langle L, \; R, \; \hat{L} \right \rangle | &amp;= |L| + |R|
\\
\\
\textit{insert} \; (e, \left \langle L, \; R, \; \hat{L} \right \rangle) &amp;= \textit{makeq} \; (L, \; e : R, \hat{L})
\\
\\
\textit{remove} \left \langle L, \; R, \; \hat{L} \right \rangle &amp;= \left \langle \text{hd} \; L, \textit{makeq} \; (\text{tl} \; L, \; R, \hat{L}) \right \rangle
\\
\\
\textit{makeq}  \left \langle L, \; R, \; \hat{L} \right \rangle &amp;=  \left \langle L, \; R, \;  \text{tl} \; \hat{L} \right \rangle &amp;\{ |\hat{L}| &gt; 0\} \\
&amp;= \left \langle L&apos;, \left [ \; \right ], L&apos; \right \rangle, \; \text{let} \; L&apos; = \textit{rot}(L, R, \left [ \; \right]) &amp;\{ |\hat{L}| = 0\}\\
\\
\textit{rot}(L, R, A) &amp;= \text{hd} \; R : A &amp; \{ |L| = 0 \} \\
                      &amp;= \text{hd} \; L : \textit{rot}(\text{tl} \; L, \text{tl} \; R, \text{hd} \; R : A) &amp; \{ |L| &gt; 0 \}
\end{aligned}$$</span><!-- Has MathJax -->
<p>透過額外的 <span>$\hat{L}$</span><!-- Has MathJax -->，避開了 LL Parser 和 lookahead 造成的遞迴定義，如此一來每一個操作複雜度皆為 <span>$\mathcal{O}(1)$</span><!-- Has MathJax -->。其概念也很簡單，為了維持條件 <span>$|R| \le |L|$</span><!-- Has MathJax -->，我們將 <span>$\hat{L}$</span><!-- Has MathJax --> 定義為其差值，為即將地部分 <span>$R$</span><!-- Has MathJax --> 反轉到變成 <span>$L$</span><!-- Has MathJax --> 計數做準備。</p>
<p>特別注意到，在 <span>$\text{makeq}$</span><!-- Has MathJax --> 的時候，同步移除掉了一部分的 <span>$\hat{L}$</span><!-- Has MathJax -->，而在長度 <span>$|\hat{L}| = 0$</span><!-- Has MathJax --> 觸發反轉。實作上，可以當作一個長度數值去看待，而在可持久化概念上，它們實際上共享同一塊內存，所以也就沒有太大的差別。</p>
<p>概念與前一篇的 Realtime Queue 構造方式類同。只不過，我們預先將答案放置於 <span>$\textit{rot}$</span><!-- Has MathJax --> 堆疊定義中的 <span>$A$</span><!-- Has MathJax --> 中，而重複使用了 <span>$\hat{L}$</span><!-- Has MathJax --> 找到完成時刻。</p>
<h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-mproblem-persistent-queue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/mproblem-persistent-queue/" class="article-date">
  <time datetime="2019-12-23T22:43:50.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作應用/">工作應用</a>/<a class="article-category-link" href="/categories/工作應用/可持久化/">可持久化</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/mproblem-persistent-queue/">可持久化隊列 Persistent Queue 序</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2019/12/24/mproblem-persistent-queue/" data-id="ckvd6e85m00c99cvn8mc4yv79" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2019/12/24/mproblem-persistent-queue/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/queue/">queue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可持久化/">可持久化</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們完成了持久化堆疊後，必然要去完成隊列 (Queue)。難度遠比想像中的高，很多人的第一個反應是用兩個指標去完成持久化隊列，分別指向最前和最後的兩個元素。不幸地，<strong>直覺無法套用</strong>在不同的領域上。</p>
<p>下述為一個例子，假定每一個節點都往後指到下一次會被 pop 的節點，則我們無法同時描述 B 和 C。如果每一個節點都往前指到前一個加入的節點，則無法解決隊列的 pop 操作。上述的兩種設計都無法滿足可持久化的定義，則得到<strong>用兩個指標是無法完成可持久化隊列</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A = empty().push(1); // [1]</div><div class="line">B = A.push(2);       // [1, 2]</div><div class="line">C = A.push(3);       // [1, 3]</div><div class="line">D = B.pop();         // [2]</div></pre></td></tr></table></figure>
<h3 id="攤銷分析的錯誤"><a href="#攤銷分析的錯誤" class="headerlink" title="攤銷分析的錯誤"></a>攤銷分析的錯誤</h3><p>定義：可持久化隊列 <span>$Q = \left \langle L, \; R \right \rangle$</span><!-- Has MathJax --></p>
<p>在沒有持久化的要求下，我們的確可以用兩個堆疊 <span>$L, \; R$</span><!-- Has MathJax --> 去實作隊列 <span>$Q$</span><!-- Has MathJax -->。當 <span>$|L|  = 0$</span><!-- Has MathJax --> 時，令 <span>$L&apos; = \text{Rev}(R), \; R&apos; = \left [ \; \right ]$</span><!-- Has MathJax -->，每一個操作的時間複雜度為 <span>$\text{amortized} \; \mathcal{O}(1)$</span><!-- Has MathJax -->。</p>
<p>然而，對於可持久化的場合中，這種忽大忽小的成本是不切實際的，因為持久化會複製整體的攤銷成本，而獨立於前一個狀態。達到真正的即時 (realtime)，必須保證每一個操作 <span>$\mathcal{\Theta}(1)$</span><!-- Has MathJax -->，才能防止攤銷最慘情況不會發生。</p>
<h2 id="即時隊列-Realtime"><a href="#即時隊列-Realtime" class="headerlink" title="即時隊列 (Realtime)"></a>即時隊列 (Realtime)</h2><ul>
<li>REAL-TIME QUEUE OPERATIONS IN PURE LISP, Robert HOOD and Robert MEVILL, 1981</li>
</ul>
<p>這快三十年前的論文，給了我們設計函數式的另一種啟發。不透過函數式語言的語法結構，我們可以很直觀地用傳統算法去模擬可持久化隊列。好比 C++ 中的 <code>vector&lt;T&gt;</code> 或者是 Java 中 的<code>ArrayList&lt;T&gt;</code>，每當快滿的時候，我們變將元素複製到兩倍大的容器裡。那可持久化就好比背景程式一般，在每一次操作的過程中，就開始準備好抽換的兩倍容器，直到真的要替換的時候，就可以常數搬移。</p>
<p>定義：隊列 <span>$Q = \left \langle O^{\triangleleft}, I^{\triangleright} \right \rangle$</span><!-- Has MathJax --> 且滿足 <span>$|O^{\triangleleft}| \ge |I^{\triangleright}|$</span><!-- Has MathJax --></p>
<ul>
<li><span>$O^{\triangleleft}$</span><!-- Has MathJax --> 表示出隊的堆疊</li>
<li><span>$I^{\triangleright}$</span><!-- Has MathJax --> 表示入隊的堆疊</li>
</ul>
<p>當發生 <span>$|O^{\triangleleft}| = n, \; |I^{\triangleright}| = n+1$</span><!-- Has MathJax --> 時，我們標記這個隊列為 <strong>轉移中</strong> (<em>transferring</em>)，此時開始可不滿足上述 <span>$|O^{\triangleleft}| \ge |I^{\triangleright}|$</span><!-- Has MathJax --> 的規定。接著，我們將預期在下一次 <span>$|O^{\triangleleft}| = 0$</span><!-- Has MathJax --> 的 pop 操作前，變換成 <span>$Q = \left \langle (OI)^{\triangleleft}, \left [ \; \right ]  \right \rangle$</span><!-- Has MathJax -->。因此這中間至少有 <span>$n$</span><!-- Has MathJax --> 次的 push/pop 操作，讓我們將轉移中隊列變成正規隊列。</p>
<p>需要以下操作：</p>
<ol>
<li>將 <span>$I^{\triangleright}$</span><!-- Has MathJax --> 的所有元素 pop 至 <span>$I_\text{aux} = I^{\triangleleft}$</span><!-- Has MathJax -->，需 <span>$n+2$</span><!-- Has MathJax --> 步。</li>
<li>將 <span>$O^{\triangleleft}$</span><!-- Has MathJax --> 的所有元素 pop 至 <span>$O_\text{aux} = O^{\triangleright}$</span><!-- Has MathJax -->，需 <span>$n+1$</span><!-- Has MathJax --> 步。</li>
<li>將 <span>$O_\text{aux}$</span><!-- Has MathJax --> 的所有元素 pop 至 <span>$I_\text{aux}$</span><!-- Has MathJax -->，<span>$O_\text{new}= (OI)^{\triangleleft}$</span><!-- Has MathJax -->，需 <span>$n+1$</span><!-- Has MathJax --> 步。</li>
</ol>
<p>共計 <span>$3n+4$</span><!-- Has MathJax --> 步。平均在 <span>$n$</span><!-- Has MathJax --> 次操作內完成。變成 <strong>轉移中</strong> 狀態的那一瞬間，操作 <span>$7$</span><!-- Has MathJax --> 次，隨後的每一個 push/pop 完成 <span>$3$</span><!-- Has MathJax --> 次操作。 確保了每一步在常數時間內完成。</p>
<p>在轉移過程中，若進行 push 操作，直接在清空完後的 <span>$I^{\triangleright}$</span><!-- Has MathJax --> 上操作、或者 <span>$I_\text{extra}^{\triangleright}$</span><!-- Has MathJax --> 。若進行 pop 操作時，步驟 3 的最後幾個會成為多餘操作，故需要額外的計數器統計總共完成了幾個 <span>$O_\text{aux}$</span><!-- Has MathJax --> 複製，當完成數量等於當前數量 <span>$|O|$</span><!-- Has MathJax --> 便停止轉移，並標記為正規隊列 <span>$Q = \left \langle O_\text{new}^{\triangleleft}, I^{\triangleright} \right \rangle$</span><!-- Has MathJax -->、或者 <span>$Q = \left \langle O_\text{new}^{\triangleleft}, I_\text{extra}^{\triangleright} \right \rangle$</span><!-- Has MathJax --></p>
<p>宣告不可變物件的類別時，以 Java 為例相當棘手，展開代碼會造成進入 HotSpot 的機會變低，傳遞這個多的參數進行轉移卻要用在回傳值上額外宣告變數來接取。因此，透過平均 <span>$3$</span><!-- Has MathJax --> 次，可能會需要額外宣告 3 次變數，這對 GC 的壓力非同小可。貪心一點，用常數 4 取代，這麼一來可讀性不會下降太多，代碼也能更明確一點，呼叫 2 次的 2 個操作。</p>
<p>實作時，一個可持久化隊列除了一開始的 2 個堆疊，還要維護轉移狀態 5~6 的狀態空間，因此一個隊列需要 7~8 個欄位。</p>
<h2 id="預先評估隊列-Pre-Evaluation"><a href="#預先評估隊列-Pre-Evaluation" class="headerlink" title="預先評估隊列 (Pre-Evaluation)"></a>預先評估隊列 (Pre-Evaluation)</h2><ul>
<li>SIMPLE AND EFFICIENT PURELY FUNCTIONAL QUEUES AND DEQUES, Chris Okasaki, 1995</li>
</ul>
<p>這是另一種設計方法，上述方法用了 7~8 欄位來表示一個隊列，作為一個函數式定義太複雜了，這一概念將只使用 3 個，其他的塞在別的定義中，讓其他函數式定義也能夠共享，下一篇文章再來細說。</p>
<h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>
<h2 id="效能評比"><a href="#效能評比" class="headerlink" title="效能評比"></a>效能評比</h2><p>以 Java 實作，Realtime 與 Pre-Evaluation 效能差不多，但以 OOP 的角度看來 Realtime 很像當初打比賽的精明能幹，Pre-Evaluation 則是代碼量巨大，擴充概念性高。</p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-mproblem-persistent-stack-operators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/23/mproblem-persistent-stack-operators/" class="article-date">
  <time datetime="2019-12-23T13:21:21.000Z" itemprop="datePublished">2019-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作應用/">工作應用</a>/<a class="article-category-link" href="/categories/工作應用/可持久化/">可持久化</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/23/mproblem-persistent-stack-operators/">可持久化堆疊 操作 Persistent Stack Operators</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2019/12/23/mproblem-persistent-stack-operators/" data-id="ckvd6e85n00cb9cvnjomem170" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2019/12/23/mproblem-persistent-stack-operators/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stack/">stack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可持久化/">可持久化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/堆/">堆</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <p>接續前一篇 《可持久化堆疊 Persistent Stack》，接下來要探討可持久化堆疊相互操作，如何照常在常數複雜度內完成。這一連貫的定義，將在後續的隊列、雙向隊列中使用。</p>
<h2 id="串接-Append"><a href="#串接-Append" class="headerlink" title="串接 Append"></a>串接 Append</h2><p>定義：串接堆疊 <span>$A = \text{Append} \; (T, B)$</span><!-- Has MathJax --></p>
<span>$$\begin{aligned}
\left [ \; \right ]_{\textit{append}} &amp;= \left \langle \left [ \; \right ], \left [ \; \right ] \right \rangle
\\
\\
|\left \langle T, \; B \right \rangle | &amp;= |T| + |B|
\\
\\
\textit{push} \; (\textit{e}, \left \langle T, \; B \right \rangle) &amp;= \left \langle e : T, \; B \right \rangle
\\
\\
\textit{pop} \; (\left \langle T, \; B \right \rangle) &amp;= \left \langle \text{hd} \; T, \left \langle \text{tl} \; T, \; B \right \rangle \right \rangle &amp; \{ |T| &gt; 0 \} \\
&amp;= \left \langle \text{hd} \; B, \text{tl} \; B \right \rangle &amp; \{ |T| = 0 \}
\end{aligned}$$</span><!-- Has MathJax -->
<p>串接兩個堆疊 <span>$T, \; B$</span><!-- Has MathJax -->，並且 <span>$T$</span><!-- Has MathJax --> 放置於頂首、<span>$B$</span><!-- Has MathJax --> 放置於末端，這時候串接也可以被視為一個堆疊結構。由於我們只在意堆疊的接口，完成這三項基礎操作並不是難事。皆可以在 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 內完成。</p>
<p>對於大小這一個計算，要特別小心一個錯誤，如果直接以回傳值 <span>$|T| + |B|$</span><!-- Has MathJax --> 撰寫，將在遞迴使用時，其一方也為串接定義出的堆疊而退化成 <span>$\mathcal{O}(n)$</span><!-- Has MathJax --> 的計算。因此在宣告時，紀錄大小是很重要的。</p>
<p>此外，我們也很容易遞迴定義出 Append，如果 <span>$T$</span><!-- Has MathJax --> 本身也是 Append 出來的結果，那麼 pop 時會付出遞迴深度的代價，按照使用的演算法，這種情況會使得時間複雜度為 <span>$\mathcal{O}(\log n)$</span><!-- Has MathJax -->。構造時，如果 <span>$T \in \text{Append}$</span><!-- Has MathJax -->，拆解成 <span>$\text{Append}(T.l, \; \text{Append}(T.r, \; B))$</span><!-- Has MathJax --> 可以避免。</p>
<p>我們透過簡單的工廠模式 (Factory Design Pattern)，防止額外的空間宣告，當 <span>$T$</span><!-- Has MathJax --> 或者 <span>$B$</span><!-- Has MathJax --> 其一為空時，直接回傳其中一方。接著就能保證 <span>$|T| &gt; 0, \; |B| &gt; 0$</span><!-- Has MathJax -->，操作就能簡化許多。</p>
<h2 id="提取-Take"><a href="#提取-Take" class="headerlink" title="提取 Take"></a>提取 Take</h2><p>定義：提取堆疊 <span>$A = \text{Take} \; (n, X)$</span><!-- Has MathJax --></p>
<span>$$\begin{aligned}
\left [ \; \right ]_{\textit{take}} &amp;= \left \langle 0, X \right \rangle
\\
\\
|\left \langle n, X \right \rangle | &amp;= n
\\
\\
\textit{push} \; (\textit{e}, \left \langle n, X \right \rangle) &amp;= \text{Append}(e,\; \left \langle n, X \right \rangle)
\\
\\
\textit{pop} \; (\left \langle n, X \right \rangle) &amp;= \left [ \; \right ] &amp; \{ n = 1 \} \\
&amp;= \left \langle \text{hd} \; X, \left \langle n-1, \text{tl} \; X \right \rangle \right \rangle &amp; \{ n &gt; 1 \}
\end{aligned}$$</span><!-- Has MathJax -->
<p>只提取堆頂的前 <span>$n$</span><!-- Has MathJax --> 個元素，剩餘的都不需要。無疑地，提取堆疊也是可持久化的，並且在 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 時間內完成所有堆疊操作。但是在 push 操作時，將使用串接操作。</p>
<p>發生遞迴定義時，意即 <span>$X \in \text{Take}$</span><!-- Has MathJax -->，則必須提取成 <span>$A = \text{Take}(n, \; X.x)$</span><!-- Has MathJax --> 防止退化成 <span>$\mathcal{O}(\log n)$</span><!-- Has MathJax --></p>
<h2 id="移除-Drop"><a href="#移除-Drop" class="headerlink" title="移除 Drop"></a>移除 Drop</h2><p>定義：移除堆疊 <span>$A = \text{Drop} \; (n, X)$</span><!-- Has MathJax --></p>
<span>$$\begin{aligned}
\text{Drop} \; (n, X) &amp;= X &amp; \{ n = 0 \} \\
                      &amp;= \text{Drop} \; (n-1, X) &amp; \{ n &gt; 1\}
\end{aligned}$$</span><!-- Has MathJax -->
<p>相反於提取，忽略堆頂的前 <span>$n$</span><!-- Has MathJax --> 個元素，從 <span>$n+1$</span><!-- Has MathJax --> 個開始算。</p>
<p>這裡僅提供遞迴定義，由於移除操作並非完全的常數操作，一旦需要拿到堆頂的第一個元素時，勢必要運行 <span>$n$</span><!-- Has MathJax --> 次。唯有在運行操作中，若 <span>$n \le c$</span><!-- Has MathJax --> 小於某個常數定值時，這時候才能把移除操作視為常數且可持久化的堆疊，否則將視為一般的攤平操作。</p>
<p>爾後，我們將提及一些算法的定義 <span>$c = 3$</span><!-- Has MathJax -->，使用這一個 Drop 操作。實作時要特別小心，同時 X 也是一個移除堆疊，那麼在建構前，必然要將 X 攤平，意即把 n 弄成 0 的表示法。防止 pop 操作時，意外地發生 stack overflow 的慘劇。</p>
<p>或許有人會問為什麼不一開始就攤平，早就是常數操作？其實，這就要看理論目標的最壞情況最小化，常數要怎麼分配到不同操作中。在可持久化的領域中，每一個常數操作的大小是每個操作的最大值，而非加總起來，<strong>完全不同於一般算法設計攤銷分析</strong>，因此優化的思維要有所轉變。</p>
<h2 id="反轉-Rev"><a href="#反轉-Rev" class="headerlink" title="反轉 Rev"></a>反轉 Rev</h2><p>定義：反轉堆疊 <span>$A = \text{Rev} \; (X)$</span><!-- Has MathJax --></p>
<span>$$\begin{aligned}
\text{Rev} \; (X) &amp;= \text{Rev}&apos;(X, \left [ \; \right ]) &amp; \\
\\
\text{Rev}&apos;(X, A) &amp;= A &amp; \{ |X| = 0\} \\
                  &amp;= \text{Rev}&apos; \; (\text{tl} \; X, \text{hd} \; X : A) &amp; \{ |X| &gt; 0\}
\end{aligned}$$</span><!-- Has MathJax -->
<p>將整個堆疊 <span>$X$</span><!-- Has MathJax --> 反轉後置放成一個堆疊 <span>$A$</span><!-- Has MathJax -->。</p>
<p>同樣地，若沒有定義 <span>$|X| \le c$</span><!-- Has MathJax -->，反轉操作也<strong>無法在常數時間內完成</strong>。網路上許多實作號稱常數、攤銷持久化，實際上若牽涉到回傳反轉的過程，即使做了快取答案，也可以輕易地將它效能擊破。只需要不斷地呼叫反轉那一瞬間的的操作，或者倒退版本再推進一個版本去觸發攤銷的反轉操作，複雜度就會落入  <span>$\mathcal{O}(n)$</span><!-- Has MathJax -->。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li>SIMPLE AND EFFICIENT PURELY FUNCTIONAL QUEUES AND DEQUES, Chris Okasaki, 1995</li>
</ul>
<h2 id="來點題目-《記憶中的堆疊》"><a href="#來點題目-《記憶中的堆疊》" class="headerlink" title="來點題目 《記憶中的堆疊》"></a>來點題目 《記憶中的堆疊》</h2><h3 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h3><p>不斷地進行「思想實驗」的妮可，終於讓大腦演進到平行思考。假想在腦海裡，我們把狀態以堆疊 (Stack) 的方式儲存，當走投無路的時候，就會退回到上一個狀態，再把新的分支因素堆疊上去。正在全力計算的妮可無法細說每一個思維狀態，而我們可以操作戳記，反推出當前狀態。</p>
<p>操作有以下三種：</p>
<ul>
<li><code>0 v</code>: 退回版本 v</li>
<li><code>1 x</code>: 在當前堆疊，push x 到堆頂</li>
<li><code>2</code>: 印出當前堆疊狀態</li>
</ul>
<p>起始版本編號為 0，第 <span>$i$</span><!-- Has MathJax --> 次操作版本編號為 <span>$i$</span><!-- Has MathJax -->。</p>
<h3 id="範例輸入"><a href="#範例輸入" class="headerlink" title="範例輸入"></a>範例輸入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1 1</div><div class="line">1 2</div><div class="line">2</div><div class="line">0 1</div><div class="line">2</div><div class="line">1 3</div><div class="line">2</div><div class="line">0 3</div><div class="line">2</div></pre></td></tr></table></figure>
<h3 id="範例輸出"><a href="#範例輸出" class="headerlink" title="範例輸出"></a>範例輸出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2 1 ]</div><div class="line">1 ]</div><div class="line">3 1 ]</div><div class="line">2 1 ]</div></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-mproblem-persistent-stack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/22/mproblem-persistent-stack/" class="article-date">
  <time datetime="2019-12-22T12:07:37.000Z" itemprop="datePublished">2019-12-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作應用/">工作應用</a>/<a class="article-category-link" href="/categories/工作應用/可持久化/">可持久化</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/22/mproblem-persistent-stack/">可持久化堆疊 Persistent Stack</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2019/12/22/mproblem-persistent-stack/" data-id="ckvd6e85p00cg9cvns6o41zbq" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2019/12/22/mproblem-persistent-stack/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stack/">stack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可持久化/">可持久化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/堆/">堆</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在某些情況下，我們想要每次操作都能對應一個新的物件，即使變動當前的數據結構，也不影響前一次的數據結構。「可持久化 Persistent」一詞用來描述在這一段時間內，保存所有操作狀態的方法。若用在資料庫儲存概念中，「持久化 Persistence」則是用來描述將內存數據對照寫入檔案的可行性，兩者的意思不盡相同。</p>
<p>在工作發現許多語言開始支援函數式設計，也就是 <span>$\lambda$</span><!-- Has MathJax --> 計算 (lambda function)，以現在手上的 Java 開發，主要發生幾個常見的效能問題：</p>
<ul>
<li><p><strong>惰性求值</strong> (Lazy Evaluation)：<br>每一個惰性求值是需要的時候再計算，然而有些歷史代碼並不是這麼回事，導致一部分函數回傳整個串列，因此消耗了至少為 <span>$\mathcal{O}(n)$</span><!-- Has MathJax --> 的時間，而非函數式所需要的 <span>$\mathcal{O}(1)$</span><!-- Has MathJax -->。如果一個函數只針對前 10 個數值感興趣，大部分的資料都會被捨棄掉，在未來使用這些函數接口時，都還要去檢查每一個相關實作是否為真惰性，而非假性惰性。請參閱 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="external">Java Stream</a> 串流實作細節。</p>
</li>
<li><p><strong>不可變物件</strong> (Immutable Object)：<br>對於某些中間表達式，如檔案系統路徑。若要列出一個資料夾下的所有檔案路徑，在上述的惰性求值中，樸素的實作將會把路徑之間的重複不斷複製。正如同經典的字串問題，每串接一個字串，必然會複製一份，倘若複製的順序相反，時間複雜度將從 <span>$\mathcal{O}(n)$</span><!-- Has MathJax --> 變成 <span>$\mathcal{O}(n^2)$</span><!-- Has MathJax -->。</p>
</li>
</ul>
<p>串流操作 Stream 以 functional-style operation 為主，又細分成好幾種操作。即使運行結果相同，造就的效能與可拓展性也不同，如 <code>reduce</code> 和 <code>collect</code> 的差別，都能將一系列的元素縮合成一個，但是 <code>reduce</code> 採用二合一，容易在合成操作上退化成 <span>$\mathcal{O}(n^2)$</span><!-- Has MathJax -->，對不可變物件操作，其空間消耗量大，唯一個優勢是平行加速的擴充性。相反地，<code>collect</code> 則是逐一將元素納入一個集合，這樣一個簡單的合併操作，是沒辦法并行處理的，好處則是不會產生太多額外使用空間。</p>
<p>為了達到具拓展性且不失效能的設計，函數式編程那些獨特的數據結構和算法，或許能解決我們的問題。</p>
<h2 id="堆疊定義"><a href="#堆疊定義" class="headerlink" title="堆疊定義"></a>堆疊定義</h2><p>堆疊 Stack，主要有兩個操作：</p>
<ul>
<li><span>$\textit{push} \; (\textit{value})$</span><!-- Has MathJax -->：將一個元素 <span>$\textit{value}$</span><!-- Has MathJax --> 放置到堆頂</li>
<li><span>$\textit{pop} \; ()$</span><!-- Has MathJax -->：將堆頂元素移除</li>
</ul>
<p>課堂上總是會教資料結構，使用鏈結串列 (Linked List) 或者是陣列 (Array) 來實作，每一個操作皆為 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 常數。而持久化一個堆疊，我們將要針對改變結構內容的操作進行複製。</p>
<h2 id="可持久化堆疊定義"><a href="#可持久化堆疊定義" class="headerlink" title="可持久化堆疊定義"></a>可持久化堆疊定義</h2><p>可持久化堆疊 Stack 定義：</p>
<ul>
<li><span>$[\;]_{\textit{stack}} = \left \langle [\;] \right \rangle$</span><!-- Has MathJax --></li>
<li><span>$|\left \langle A \right \rangle| = |\left \langle \text{hd} \; A \right \rangle| + |\left \langle \text{tl} \; A \right \rangle|$</span><!-- Has MathJax --></li>
<li><span>$\textit{push} \; (\textit{e}, A) = \left \langle e : A \right \rangle$</span><!-- Has MathJax --></li>
<li><span>$\textit{pop} \; (A) = \left \langle \text{hd} \; A, \left \langle \text{tl} \; A \right \rangle \right \rangle$</span><!-- Has MathJax -->
</li>
</ul>
<p>上述的數學式</p>
<ul>
<li><span>$\text{hd}$</span><!-- Has MathJax --> 為堆疊的首元素。另一個使用術語為 <span>$\textit{car}$</span><!-- Has MathJax -->。</li>
<li><span>$\text{tl}$</span><!-- Has MathJax --> 為剔除首元素之後的結果。另一個使用術語為 <span>$\textit{cdr}$</span><!-- Has MathJax -->。從堆疊來看，即為回傳指向前一個節點的位置。</li>
<li><span>$:$</span><!-- Has MathJax --> 為串接操作。</li>
</ul>
<p>這一簡單結構，又被稱作為 list。只允許對堆頂操作的串列，這麼說很混淆，但在函數式設計中，他們通用的 list 就是這麼構造的，在後續的算法中，我們都用可持久化堆疊來表示 list。</p>
<p>以下述的例子，我們構造 4 個堆疊，每一個堆疊指向堆頂元素。對於加入一個元素到堆疊，我們就額外多一個節點指向先前的堆疊；相同地，移除堆頂元素時，回傳前一個堆疊結果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A = empty.push(X)    // [X]</div><div class="line">B = A.push(Y)        // [X, Y]</div><div class="line">C = B.push(Z)        // [X, Y, Z]</div><div class="line">D = B.push(W)        // [X, Y, W]</div></pre></td></tr></table></figure>
<p>相應的儲存圖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   A         B         C</div><div class="line">+--+-+    +--+-+    +--+-+</div><div class="line">|  |X&lt;----+  |Y&lt;----+  |Z|</div><div class="line">+--+-+    +--+^+    +--+-+</div><div class="line">              |</div><div class="line">              |        D</div><div class="line">              |     +--+-+</div><div class="line">              +-----+  |W|</div><div class="line">                    +--+-+</div></pre></td></tr></table></figure>
<p>此時，<span>$D$</span><!-- Has MathJax --> 進行 <span>$\textit{pop}$</span><!-- Has MathJax --> 操作，回傳值為 <span>$\left \langle W, B \right \rangle$</span><!-- Has MathJax -->。</p>
<p>最後，對於每一個操作在 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 時間內完成，需要額外的 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 空間。對於沒有垃圾回收 (Garbage Collection) 的語言實作上，需要維護參照數量 reference counter 來回收沒有用到的堆疊節點。</p>
<h2 id="Java-實作代碼"><a href="#Java-實作代碼" class="headerlink" title="Java 實作代碼"></a>Java 實作代碼</h2><p>更多細節參閱 <a href="https://github.com/morris821028/immortal-jellyfish" target="_blank" rel="external">morris821028/immortal-jellyfish</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> persistent.stack;</div><div class="line"></div><div class="line"><span class="keyword">import</span> persistent.PStack;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> morrisy</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; The type of element</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">PStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PersistStack&lt;?&gt; EMPTY = <span class="keyword">new</span> PersistStack();</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">PersistStack&lt;T&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (PersistStack&lt;T&gt;) EMPTY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersistStack&lt;T&gt; next;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PersistStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PersistStack</span><span class="params">(T value, PersistStack&lt;T&gt; next, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.size = size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> PersistStack&lt;T&gt; <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> create();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isEmpty())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> PersistStack&lt;T&gt; <span class="title">push</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersistStack&lt;&gt;(value, <span class="keyword">this</span>, size + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> PersistStack&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span> ? next : create();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-diary-201908" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/09/diary-201908/" class="article-date">
  <time datetime="2019-08-09T09:07:42.000Z" itemprop="datePublished">2019-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/手札日記/">手札日記</a>
  </div>

  </div>
  <div class="article-inner ">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="https://i.imgur.com/g1o7Yud.jpg" rel="gallery_ckvd6e82n004a9cvn7i1cb1ml">
        <img src="https://i.imgur.com/g1o7Yud.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/09/diary-201908/">我們是否交會於一點</a>
    </h1>
  

      </header>
    
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2019/08/09/diary-201908/" data-id="ckvd6e82n004a9cvn7i1cb1ml" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2019/08/09/diary-201908/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <p>距離上一次撰寫已經過了六個月，原以為有很多故事可以分享，但卻發現工作後的變化並沒有太多。每天就這麼兩點一線地不斷往返，在通勤往返的路上，尋求那麼一點不同。久而久之，擠身在擁擠的人群中只能感受到與自己對話，那種刻骨銘心的衝勁逐漸地消失。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>從二月開始到八月，工作仍然繞著程式效能在轉，而我早已忘了給予的目標是什麼，看到路上的石子擋路，就拿著大學的基礎理論一路清下去，問題並不難、演算法也並不深。放在那兒好幾年，對我來說不是滋味。</p>
<p>隨著代碼的增長，一定會有人在之後不斷地照著這個思路複製下去，問題就如雪球般地越來越大。「能混就混吧，這樣才能在社會裡討好關係」－到了工作場所後，不是範圍內的事情，即使點出了錯誤，甚至還順便修了它，也不見得是件好事。這樣做下去，甚至還引起了質疑的氛圍，之後就這麼把工作丟給對方去做，要不然就是不給你權限做任何改變。</p>
<p>逐漸地，無法共同成長的我們，也無法將理想好好地發揮，那到底要怎麼好好地顧及這一切，明明能預先看到的問題，現在卻只能無助地看著危機不斷發生。</p>
<p><img src="https://i.imgur.com/dadOzB0.jpg" alt="「即便如此，他們說的話我全都照做」－《我要準時下班》"></p>
<p>起初，總指派著新的功能要著設想架構，但是發現提出來也只有自己去做，大家正襟危坐地聽著規劃，最後問著「大概要花多久的時間，才能看到你們完成？」此時，心中灰了一片。「原來不是要一起走啊」</p>
<p>然而，那些提著都是建立在原有的架構技術下。不斷地嘗試挖掘未來時，卻發現產品的各方面都還欠缺相當嚴重，於是不斷地修正效能、演算法、架構完整與防呆寫法，每天修改上千行的代碼，整體加速了好兩三倍以上，使用內存也少了一大半去，甚至在長期使用的穩定性給予大幅度地調整。</p>
<p><img src="https://i.imgur.com/t1G8V4h.jpg" alt="「旁邊的項目有點不妙」－《賢惠幼妻仙狐小姐》"></p>
<p>在某些層面上，這的確已經超出了原先設定的目標，但也沒有負責的單位去處理，自己動手下去修純屬逼不得已。面對眾人的期待，我再也沒辦法告訴你們多久能完成那些新功能，但聽到「可是那個不知道還要多久，能不能先 …」、「這問題當初你不是說要解決」諸如此類的話語，心中那股熱火就像少了助燃劑而熄滅。原來我們之間的工作切分得這麼細，真的沒有能力來幫忙嗎？明明我只是做基礎功。</p>
<p><img src="https://i.imgur.com/vV7Bb6W.jpg" alt="&quot;I can do anything, I can do absolutely anything&quot;, The Expert"></p>
<p>三月到了，櫃台大姊姊離去。四月到了，同期的同事被女友拖著去讀博班。心裡一沉，現在的我就會這麼一直下去，還是聽著家裡人講的，時間一到乾脆出國繼續讀書去。不知道那些未來還帶有著什麼，而到底是為了什麼賺錢？為什麼要工作？</p>
<p>大神傳了 <a href="https://www.youtube.com/watch?v=gpgXZ5nSCYU" target="_blank" rel="external"><strong>三和大神</strong></a> 的關鍵字給我，又聽著不斷地說不想學技術的烈士們，原先積極向上的朋友們，似乎都逐漸對工作感到人生黯淡。現實早已經變得殘酷不已，社會卻要向我們勸說咬著忍下去，工作就是不斷分析的我們，哪會這麼輕易地照著劇本走。成熟的我們，為了理想而苟且偷生，這才是常態。</p>
<p><img src="https://i.imgur.com/c7SXivE.jpg" alt="「雖然涉足這份工作不是因為想做，但接手了就不能放手不管。雖然涉足這份工作不是因為喜歡，但接手了就不能無功而返，就算我們有誰死了，也不會有人哭，大家肯定會笑著送別，因為誰也不敢保證一定能活到明天」－《灰色：幻影扳機》"></p>
<p>六月的某一天，我發現自己到了極限，對於現況的不滿已經淹沒我的思緒。那一天，我沒有選擇，開了一場 “I Don’t Have a Choice” 為題的會議。說著自己報告的時候，只能說著最重要的那 1% 的修改，剩餘的那 99% 對在場的各位也許不是那麼重要。就算是僅僅的那麼 1%，說了仍不能在各位心中占有一席之地，問題還是一再地發生。</p>
<p>光鮮亮麗的專案報告不是我所能給予的，現在的我很在意每一個技術環節，因為沒有一個可以遵循的準則。我沒辦法決定一個醒目的會議標題，告訴著你們有什麼特別突破，現在的我想要尋找恆久不變的原則。這些說起來很傷人，但也是因為我們並沒有共同走到那一步，無法在同一個平台上討論。</p>
<p>每當聽著報告，原先就聽不懂得我，完全學不到任何知識，當不知道一個項目用在哪裡，怎麼記也記不久，而且從來沒有機會使用的話，那真的非常難以體會其狀態。懵懵懂懂地參與，不知所謂的發問。</p>
<p>如果還有更遠得未來，就想要知道如何走得更遠。如果報告總是特例說明，輪到我啟程的那一天，真的會是一樣的情況嗎？不經地懷疑，那一天我仍要自己從零開始研究。</p>
<p>做事就像捏黏土，往那個目標捏去並不難，也許不是很漂亮，但足以觀賞。如果可以對材質有所研究？或者在捏的過程有所遵循的方法？是不是可以更進一步地完成？</p>
<p>工作帶著一種「勿以惡小而為之，勿以善小而不為」的心境處理代碼。然而，什麼是善？什麼是偽善？非與非惡？上帝向工程師下咒，一旦看到令人傷心的代碼，就會渾身劇痛的詛咒，為了避免自身的痛苦，就向所有代碼伸出了援手。是否伸出援手？如果存在一個純粹的善可以行動，那只剩下代碼自己了不是？</p>
<p><img src="https://i.imgur.com/CiNAkq4.jpg" alt="「只要看過聽過，亦或者思考過。無論何時都能清楚想起來，到目前為止，這種能力的效果只不過比他人記性好而已」－《重啟咲良田》"></p>
<p><img src="https://i.imgur.com/G2u0KIX.jpg" alt="「這是因為你的正義感太強，強烈到就像潔癖症或完美主義的程度。上帝向某位少年下咒，一旦看到傷心的人就會渾身劇痛的詛咒」－《重啟咲良田》"></p>
<p><img src="https://i.imgur.com/4I70LJr.jpg" alt="「少年為了避免自身的痛苦，就向所有悲傷的人伸出援手，之後上帝做了一個少年的複製品。沒有意識，只會模仿少年行為的複製品，假少年也向所有悲傷的人伸出援手，上帝賦予了真假少年各自的名字。一個叫做善，另一個較偽善。你覺得誰是善？誰又是偽善呢？」－《重啟咲良田》"></p>
<p>壞習慣已經養成，思考是難以停止，探究一切可能的心仍處於背景運行中。常常從身邊的人，老是說著我想得太多，應該要好好地放鬆。但是，那是因為我還沒有證明那些不可能，這不就是在三十歲以前的常態嗎？現在的我還不能放棄吧？</p>
<p><img src="https://i.imgur.com/TXBmKkb.jpg" alt="「為什麼考慮那些不會發生的事情」－《切爾諾貝利 》"></p>
<p><img src="https://i.imgur.com/Rxcbgbv.jpg" alt="「『為什麼考慮那些不會發生的事情』，太完美了，應該把這句話印在我們的貨幣上」－《切爾諾貝利 》"></p>
<p><img src="https://i.imgur.com/2iBNykb.jpg" alt="「我想我沒法再努力了」－《我要準時下班》"></p>
<h2 id="一般向"><a href="#一般向" class="headerlink" title="一般向"></a>一般向</h2><p><img src="https://i.imgur.com/caCuOlP.jpg" alt="「抱歉，我逃避到工作裡去了」－《未來的未來》"></p>
<p><img src="https://i.imgur.com/TqLsu7x.jpg" alt="「男人工作不順利的話，不就無路可逃了嗎」－《房仲女王》"></p>
<p>基本上，玩得遊戲還是那十幾年來如一貫的楓之谷，只不過現在裡頭認識的人不多了。有一天，久違上線的人問道：</p>
<p>「如果她不在了，那你怎麼還活著？」<br>「有嗎？」我心中想著，原來看起來還活著。</p>
<p>這幾個月來，沒有什麼特別的目標。看著美劇看看英文。每個休閒的假日就這樣過著，等級也就這樣子上去。</p>
<p><img src="https://i.imgur.com/YVV2aRr.png" alt="本吾 聖騎士"></p>
<p>直到了最近，網上朋友讓我認識了遊戲中的妹子，深入了解了後，沒想到是做 HR 的，談起話來常常總是四處碰壁，完全落不著頭緒。在某一天的上班時間，</p>
<p>「在忙什麼？」 友人 A 傳來的訊息<br>「正處理那些幾何相交的問題，高中數學裡頭的。」 看著手裡已經整合好的代碼說道。<br>「那我們呢？」 友人 A 很快速地傳了過來，腦海裡沒有任何應答的方式。</p>
<p>這句話的涵義相當地多樣，似乎就在玩弄著我，想讓我去思考，我們最終是否會交會？咱這輩子還沒看過有人問過這種問題。</p>
<p>起先，我並不怎麼在意這些，不過就是遊戲內的嘛。隨後在情人節的前一周，在好友頻道爆炸性的誤解來了。</p>
<p>「是做哪一種朋友？」 友人 B 如此問道<br>「靈魂之友」 我開玩笑地插嘴回覆。<br>「靈魂擁抱」 友人 A 不知道向誰說道</p>
<p>友人 C 無法看到友人 A 的詢問，於是莫名其妙陷入了難以解釋的關係。接著，被拉去解釋，在跳進黃河也洗不清的情況下，突然友人 A 這麼說道</p>
<p>「在等本吾過情人節」</p>
<p>這下子，我選擇了死亡。</p>
<p><img src="https://i.imgur.com/VNB9D82.jpg" alt=""></p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/86/">86</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  
</section>
          
          
            <aside id="sidebar">
  <!-- <div id="ukagaka_panel"></div> -->
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/">學校課程</a><span class="category-list-count">115</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/介面設計/">介面設計</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/作業系統/">作業系統</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/即時系統/">即時系統</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/大學專題/">大學專題</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/巨量資料/">巨量資料</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/平行程式/">平行程式</a><span class="category-list-count">43</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/敏捷方法/">敏捷方法</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/數位影像生成/">數位影像生成</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/編譯器/">編譯器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/自然語言/">自然語言</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/虛擬實境/">虛擬實境</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/計算型智慧/">計算型智慧</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/計算幾何/">計算幾何</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/計算機圖學/">計算機圖學</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/資料庫系統/">資料庫系統</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/資訊安全/">資訊安全</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/通識課程/">通識課程</a><span class="category-list-count">14</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/">工作應用</a><span class="category-list-count">38</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/Meme/">Meme</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/其他/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/可持久化/">可持久化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作應用/鬼故事/">鬼故事</a><span class="category-list-count">14</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/手札日記/">手札日記</a><span class="category-list-count">49</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/">網頁設計</a><span class="category-list-count">15</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/About-This-Blog/">About This Blog</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/HTML5/">HTML5</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/JQuery/">JQuery</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/Markdown/">Markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/NodeJs/">NodeJs</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/">解題區</a><span class="category-list-count">633</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/Latex/">Latex</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/出題解題/">出題解題</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-POJ/">解題區 - POJ</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-UVa/">解題區 - UVa</a><span class="category-list-count">483</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-Zerojudge/">解題區 - Zerojudge</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-其他題目/">解題區 - 其他題目</a><span class="category-list-count">45</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-未解題目/">解題區 - 未解題目</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/雜言筆記/">雜言筆記</a><span class="category-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="text" href="/2021/10/28/diary-202110-encrypt/">
              
                <i class="icon-file-o"></i> 
              
            《批改娘串起得那段經歷·序》</a>
          </li>
        
          <li>
            <a class="text" href="/2021/10/28/diary-202110/">
              
                <i class="icon-file-o"></i> 
              
            好多個 28 在這個時刻</a>
          </li>
        
          <li>
            <a class="text" href="/2021/10/28/work/company-ghost-story-14/">
              
                <i class="icon-file-o"></i> 
              
            Company Ghost Story 公司鬼故事 14</a>
          </li>
        
          <li>
            <a class="text" href="/2021/09/12/work/appreciation-letter/">
              
                <i class="icon-file-o"></i> 
              
            Shiny People 感謝</a>
          </li>
        
          <li>
            <a class="text" href="/2021/09/12/work/company-ghost-story-13/">
              
                <i class="icon-file-o"></i> 
              
            Company Ghost Story 公司鬼故事 13</a>
          </li>
        
          <li>
            <a class="text" href="/2021/08/15/diary-202108/">
              
                <i class="icon-file-o"></i> 
              
            被預告要開始管人的我，今天開始學管理？</a>
          </li>
        
          <li>
            <a class="text" href="/2021/08/14/work/company-ghost-story-12/">
              
                <i class="icon-file-o"></i> 
              
            Company Ghost Story 公司鬼故事 12</a>
          </li>
        
          <li>
            <a class="text" href="/2021/07/29/java/java-jni-tls-error-2/">
              
                <i class="icon-file-o"></i> 
              
            Java JNI GC Thread Error (EINVAL)</a>
          </li>
        
          <li>
            <a class="text" href="/2021/07/29/work/company-ghost-story-11/">
              
                <i class="icon-file-o"></i> 
              
            Company Ghost Story 公司鬼故事 11</a>
          </li>
        
          <li>
            <a class="text" href="/2021/06/21/diary-202106/">
              
                <i class="icon-file-o"></i> 
              
            疫情下的工作變化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">   
        <ul>
          <li><a href="http://mypaper.pchome.com.tw/zerojudge" target="_blank" title="Old Blog"><i class="icon-star"></i> Morris' Blog (pchome)</a></li>
        </ul>
    </div>
</div>

  
    
<script src="/js/jquery-ui.js"></script>
<script src="/js/ukagaka/jquery.morris.ukagaka.resource.js"></script>
<script src="/js/ukagaka/typed.js"></script>
  
  
</aside>
          
        
      </div>
      <footer id="footer">
  
  <div class="outer">    
    <div class="social-group">
      
      <a href="https://github.com/morris821028" target="_blank" title="github"><i class="icon-github"></i></a>
      
      
      <a href="https://www.facebook.com/Morris1028" target="_blank" title="facebook"><i class="icon-facebook-sign"></i></a>
      
      
      <a href="http://uhunt.felix-halim.net/id/46705" target="_blank" title="uhunt" ><span class="icon-uhunt">UVa<span></a>
      
    </div>
    <div id="footer-info" class="inner">
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/morris821028/hexo-theme-landscape" target="_blank" title="landscape">landscape</a> &copy; 2021 Shiang-Yun Yang 
    </div>
  </div>
</footer>


    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link"><i class=icon-home ></i>&nbsp&nbspHome</a>
  
    <a href="/about" class="mobile-nav-link"><i class=icon-user ></i>&nbsp&nbspAbout</a>
  
    <a href="/archives" class="mobile-nav-link"><i class=icon-archive ></i>&nbsp&nbspArchives</a>
  
    <a href="/tags" class="mobile-nav-link"><i class=icon-tags ></i>&nbsp&nbspTags</a>
  
    <a href="/picture" class="mobile-nav-link"><i class=icon-camera ></i>&nbsp&nbspPictures</a>
  
    <a href="/works" class="mobile-nav-link"><i class=icon-trophy ></i>&nbsp&nbspWorks</a>
  
</nav>
    
<script>
  var disqus_shortname = 'morris1028';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/jquery.lazyload.js"></script>
<script src="/js/jquery.als-1.6.js"></script>

<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>